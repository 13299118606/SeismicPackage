!<CPS_v1 type="PROCESS"/>


!!------------------------------- tfatt.f90 ---------------------------------!!
!!------------------------------- tfatt.f90 ---------------------------------!!
!!------------------------------- tfatt.f90 ---------------------------------!!

        ! other files are tfatt_crou.c rice.c rice.h

!<license>
!-------------------------------------------------------------------------------
! Copyright (c) 2007 ConocoPhillips Company
!
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.
!-------------------------------------------------------------------------------
!</license>

!<brief_doc>
!-------------------------------------------------------------------------------
!                         C P S   P R O C E S S
!
! Name       : TFATT   (Time-Frequency Attributes)
! Category   : transforms
! Written    : 2001-05-09   by: Randall L. Selzler, Data-Warp, Inc.
! Revised    : 2006-06-20   by: B. Menger
! Maturity   : production
! Purpose    : Generate t-f spectra or t-f attributes of input traces.
! Portability: No known limitations.
! Parallel   : Yes
!
!-------------------------------------------------------------------------------
!</brief_doc>

!<descript_doc>
!-------------------------------------------------------------------------------
!                            GENERAL DESCRIPTION
!
! TFATT performs general time-frequency spectrum analysis of input traces.  The
! Heisenburg Uncertainty Principle sets a minimum value on the product of the
! time resolution and the frequency resolution for t-f spectra.  The algorithms
! used by TFATT honor the Uncertainty Principle.  The t-f spectra generated by
! TFATT are power spectra, not amplitude spectra.
!
!
! If MODE = T_F:
!
!     For each input trace a t-f spectrum is calculated and output as a group
!     of traces where each output trace is a distinct frequency sample.
!     There is one output t-f group of traces for each input trace.  The input
!     traces are not passed through.
!
! If MODE = ATT:
!
!     For each input trace, the t-f spectrum is calculated and then the desired
!     attribute traces are calculated from the t-f spectrum.  The attribute
!     traces are then output.  The input traces are not passed through.
!
!     These t-f attributes are instantaneous in the sense that each time sample
!     of an attribute is calculated from the associated time-slice through the
!     t-f spectrum.  T-f attributes should give results that have a more
!     physical interpretation and less noise than instantaneous attributes
!     based on the Hilbert Transform.
!
! If MODE = BOTH:  DISABLED
!
!     For each input trace, the t-f spectrum is calculated and then the desired
!     attribute traces are calculated from the t-f spectrum.  The attribute
!     traces are output followed by the spectrum traces, all in one gather.
!     The input traces are not passed through.
!
!
! Algorithms 
!
! Three algorithms are available for calculating the t-f spectrum:  Short Window
! Fourier, Wigner and Adaptive Optimized Kernel (AOK) which is an optimized 
! Wigner Transform.  Normally the AOK algorithm provides the optimal compromise
! among resolution, noise and computation time.
!
!
! Attributes 
!
!     T-F Spectrum
!     The time-frequency spectrum (available in MODE = T_F or BOTH).
!
!     Instantaneous Dominant Frequency
!     The square root of the second moment of the spectrum, or the RMS
!     frequency.  Instantaneous Dominant Frequency should be a good
!     approximation to the zero-crossing frequency.
!
!     Instantaneous Q
!     2 pi times the center frequency divided by the bandwidth.  This is
!     analogous to the electrical engineering definition of Q and may not be
!     closely related to the seismic wave propagation definition of Q.
!
!     Instantaneous Center Frequency
!     The average frequency weighted by the spectrum.  (Also can be thought of
!     as the spectrum centroid or the expectation of frequency given the power
!     spectrum.)
!
!     Instantaneous Bandwidth
!     The standard deviation of the spectrum about its center frequency.
!     (Generally this will give lower values than the difference between the
!     high and low half-power frequencies.)
!
!     Instantaneous Maximum Frequency
!     The frequency having maximum power (mode) in the spectrum.
!
!
! Number of Output Traces
!
! If MODE = ATT, there will be n output attribute traces for each input trace,
! where n is the number of attributes selected by the user.
!
! If MODE = T_F, there will be as many traces in the output t-f group of traces
! as time samples used in the FFT, i.e. (1 + (TIM_FFT/DT) / 2).
! These correspond to DC (zero frequency) through Nyquist.  However, the
! FREQ_BEG and FREQ_END parameters define a frequency range such that only
! t-f traces within the range will be output.
!
! If MODE = BOTH, all the traces produced by MODE = T_F and by MODE = ATT will
! be output. 
!
!
! Output Trace Timing and Header Words
!
! Output traces have the same timing as input traces and carry attribute
! information only in the user specified trace time window.  Output traces are
! dead outside the time window.  Header words 2 and 64 are set appropriately
! for the live part of the output trace.
!
! In MODE = T_F and BOTH, the frequency associated with an output trace is 
! written in header word HDR_FREQ and the frequency sample interval is written 
! in header word HDR_FREQ + 1.
!
! For all modes, an integer indicating the trace type is written in header word
! HDR_ATT as follows.
!
!     0     Time-frequency Spectrum
!
!     1     Instantaneous Dominant Frequency
!
!     2     Instantaneous Q
!
!     3     Instantaneous Center Frequency
!
!     4     Instantaneous Bandwidth
!
!     5     Instantaneous Maximum Frequency
!
!-------------------------------------------------------------------------------
!</descript_doc>

!<advice_doc>
!-------------------------------------------------------------------------------
!                              ADVICE FOR USERS
!
!
! Run Time
!
! Because almost all of the TFATT run-time is used to calculate the t-f
! spectrum and very little is used to calculate attribute traces, it is
! preferable to run the dataset through TFATT once and calculate all the
! attributes that may possibly interest you rather than running the dataset
! through TFATT multiple times to calculate additional attributes.
!
!
! T-F Spectrum Normalization
!
! The t-f spectra can be normalized by setting T_F_NORMALIZE to TIME or FREQ.
! Typically this will be necessary only if input traces have not had XP
! or MVXP applied or if datasets with different characteristic amplitudes are
! being compared.
!
! T_F_NORMALIZE = TIME, removes variations in amplitude with time but does not
! alter the shape of the spectra produced by taking time-slices through the
! t-f spectra.
!
! T_F_NORMALIZE = FREQ, removes variations in amplitude with frequency but does
! not alter the shape of the plot of amplitude vs. time for any frequency-slice
! through the t-f spectra.
!
!
! T-F Edge Effects
!
! Because the t-f spectrum calculation uses a sliding window of length TIM_WIN
! seconds, the top and bottom of the spectrum may be inaccurate where this
! window is sliding into and out of the trace time window.  You should specify
! the trace time window larger than your area of interest by TIM_WIN seconds at
! the top and the bottom so that the edge effects lie outside your area of
! interest.
!
!-------------------------------------------------------------------------------
!</advice_doc>

!<trace_in_doc>
!-------------------------------------------------------------------------------
!                      TRACE INPUT REQUIREMENTS
!
!
! Process accepts single or multiple trace input.
!
!
!-------------------------------------------------------------------------------
!</trace_in_doc>

!<trace_out_doc>
!-------------------------------------------------------------------------------
!                     TRACE OUTPUT CHARACTERISTICS
!
!
! This process alters input traces.
!
! Process has one or more output traces.
!
! All output traces have the same number of samples and timing as the input
! traces.
!
! This process outputs traces in a gather, where a gather contains
! all traces derived from one particular input trace.
!
!-------------------------------------------------------------------------------
!</trace_out_doc>

!<global_doc>
!-------------------------------------------------------------------------------
!       PROJECT DATA, JOB DATA, AND GLOBAL PARAMETERS USED OR CHANGED
!
! Name      Description                             Action taken
! ----      -----------                             ------------
! NUMTR     max number of traces input/output       reset to N
! GATHERED  whether traces are a legitimate gather  reset to TRUE
! NWIH      number of words in header               used but not changed
! NDPT      number of sample values in trace        used but not changed
! TSTRT     starting time on trace                  used but not changed
! DT        trace sample interval                   used but not changed
!
!-------------------------------------------------------------------------------
!</global_doc>

!<header_word_doc>
!-------------------------------------------------------------------------------
!                   TRACE HEADER WORDS USED OR CHANGED
!
! Hwd#    Description                Action taken
! ----    -----------                ------------
!
! 1       Sequential Trace Count     Renumbered.
! 2       Head mute index            Reset
! 3       Logical gather index       Reset to input trace number
! 4       Trace number in gather     Reset if MODE = T_F
! 25      LAV                        Reset
! 64      Tail mute index            Reset
!         HDR_FREQ                   Set to output trace frequency
!         HDR_FREQ + 1               Set to output trace frequency sample
!                                    interval
!         HDR_ATT                    Set to integer indicating attribute type
!-------------------------------------------------------------------------------
!</header_word_doc>

!<history_doc>
!-------------------------------------------------------------------------------
!                             REVISION HISTORY
!
!     Date       Author       Description
!     ----       ------       -----------
!007. 2006-06-20  B. Menger   Removed Unused Variables.
!  6. 2002-04-30 Goodger      Fix bug with trace type flag in HDR_ATT.
!                             Disable BOTH option.
!                             Move some error checking to traps.
!  5. 2001-10-30 Selzler      Clarified TIM_WIN and TIM_FFT usage/doc.
!  4. 2001-08-03 Selzler      Added pcps_set calls for parallel setup
!  3. 2001-07-30 Selzler      Added multiple trace input and output
!  2. 2001-07-25 Selzler      Added attribute options
!  1. 2001-07-11 Selzler      Initial version.
!
!-------------------------------------------------------------------------------
!</history_doc>

!<portability_doc>
!-------------------------------------------------------------------------------
!                        PORTABILITY LIMITATIONS
!
! No known limitations.
!
!-------------------------------------------------------------------------------
!</portability_doc>

!<compile_doc>
!-------------------------------------------------------------------------------
!                      SPECIAL COMPILING REQUIREMENTS
!
! No special requirements.
!
!-------------------------------------------------------------------------------
!</compile_doc>

!<calling_doc>
!-------------------------------------------------------------------------------
!                    SPECIFIC CALLING CHARACTERISTICS
! Control
! Parameter     Value
! Name          Reported   Description
! ----          --------   -----------
! NTAPES           0       number of magnetic tapes needed.
! NEED_REQUEST   true      whether this process ever needs to request traces.
! NEED_LABEL     true      whether this process needs a label.
! TWOSETS        true      whether this process needs two trace/header arrays.
! NSCRATCH         0       amount of temporary memory needed.
! NSTORE           0       amount of permanent memory needed.
! IFTD           false     whether this process frees tape drives.
! NDISK            0       disk space needed (megabytes) if large.
! SETUP_ONLY     false     whether this process is setup-only.
!
!
! Upon input, NTR must have one of these values:
!  NTR >= 1              means to process the input traces.
!  NTR == NO_MORE_TRACES means there are no more input traces.
!  NTR == NEED_TRACES    means someone else needs more traces.
!
! Upon output, NTR will have one of these values:
!  NTR >= 1              if this process is outputting traces.
!  NTR == NO_MORE_TRACES if there are no more traces to output.
!  NTR == FATAL_ERROR    if this process has a fatal error.
!  NTR == NEED_TRACES    if this process needs more traces.
!
!-------------------------------------------------------------------------------
!</calling_doc>

!<int_calling_doc>
!-------------------------------------------------------------------------------
!                    ALTERNATE INTERNAL CALLING METHODS
!
!  None provided.
!
!-------------------------------------------------------------------------------
!</int_calling_doc>

!<algorithm_doc>
!-------------------------------------------------------------------------------
!                   ALGORITHM DESCRIPTION FOR DEVELOPERS
!
!-------------------------------------------------------------------------------
!</algorithm_doc>

!<programming_doc>
!-------------------------------------------------------------------------------
!                            PROGRAMMING NOTES
!
!-------------------------------------------------------------------------------
!</programming_doc>

!-------------------------------------------------------------------------------
!<--  XML code for the GUI goes in this section. />
!
!<gui_def>
!<NS tfatt Process/NC=80>
!
! `---------------------------------------------------------------
!  Windowing Options
!
!  OPT_WIN=`CCCCC      TIM_BEG=`FFFFFFFF      TIM_END=`FFFFFFFF
!                      TIM_ADD=`FFFFFFFF      WIN_LEN=`FFFFFFFF
! `---------------------------------------------------------------
!
! `----------------------
!  Display Options
!
!  MODE=~~~~`CCCC
!  FREQ_BEG=`FFFFFFFF
!  FREQ_END=`FFFFFFFF
!  HDR_FREQ=`III
!  HDR_ATT= `III
! `----------------------
!
! `-----------------------------------------------------
!  Time Frequency Options
!
!  OPT_ALG=~~~~~`CCC
!  TIM_WIN=~~~~~`FFFFFFFF  [C1/EN]`IIIII WIN Sample Count
!  TIM_FFT=~~~~~`FFFFFFFF  [C2/EN]`IIIII FFT Sample Count
!  AOK_OPTIMIZE=`FFFFFFFF
!  TYPE_WIN=~~~~`CCCC
!
!  IDF=`CCC  Instantaneous Dominant Frequency
!  IQ =`CCC     Instantaneous Q
!  ICF=`CCC  Instantaneous Center Frequency
!  IBW=`CCC   Instantaneous Bandwidth
!  IMF=`CCC  Instantaneous Maximum Frequency
! `-----------------------------------------------------
!
!  T_F_NORMALIZE=`CCCC
!
!</gui_def>
!
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
!<HelpSection>
!
!<Help KEYWORD="MODE">
!<Tip> Output t-f spectra or t-f attribute traces. </Tip>
! Default = T_F
! Allowed = T_F    (Output t-f spectra traces.)
! Allowed = ATT    (Output t-f attribute traces.)
!
! If MODE = T_F, then for each input trace the t-f spectrum is calculated
! and output as a group of traces where each output trace is a distinct
! frequency sample.  There is one output t-f group of traces for each input
! trace.  The input traces are not passed through.
!
! If MODE = ATT, then for each input trace, the t-f spectrum is calculated and
! then the desired attribute traces are calculated from the t-f spectrum.  The
! attribute traces are then output.  The input traces are not passed through.
!
! These t-f attributes are instantaneous in the sense that each time sample of
! an attribute is calculated from the associated time-slice through the t-f
! spectrum.  T-f attributes should give results that have a more physical
! interpretation than the Hilbert Transform derived instantaneous attributes.
!
! If MODE = BOTH:  DISABLED
!
! For each input trace, the t-f spectrum is calculated and then the desired
! attribute traces are calculated from the t-f spectrum.  The attribute
! traces are output followed by the spectrum traces, all in one gather.
! The input traces are not passed through.
!</Help>
!
!<Help KEYWORD="OPT_ALG">
!<Tip> Algorithm to use for t-f calculation. </Tip>
! Default = AOK
! Allowed = AOK  (Adaptive Optimized Kernel (AOK).)
! Allowed = WIG  (Wigner transform, AOK without optimization) EXPERIMENTAL
! Allowed = SWF  (Short Window Fourier.)
!
! OPT_ALG = AOK is slowest with optimum resolution and optimum noise.
!
! OPT_ALG = WIG is slow with best resolution and highest noise.
!
! OPT_ALG = SWF is fastest with poor resolution and lowest noise.
!</Help>
!
!<Help KEYWORD="IDF">
!<Tip> Instantaneous Dominant Frequency (toggle). </Tip>
! Default = YES (enabled)
! Allowed = YES (enabled)
! Allowed = NO  (disabled)
! IDF (Instantaneous Dominant Frequency) is the square root of the second
! moment of the spectrum, or the RMS frequency.  Instantaneous Dominant
! Frequency should be a good approximation to the zero-crossing frequency.
!
! Active only if MODE = ATT.
!</Help>
!
!<Help KEYWORD="IQ">
!<Tip> Instantaneous Q (toggle). </Tip>
! Default = YES (enabled)
! Allowed = YES (enabled)
! Allowed = NO  (disabled)
! IQ is 2 pi times the center frequency divided by the bandwidth.  This is
! analogous to the electrical engineering definition of Q and may not be
! closely related to the seismic wave propagation definition of Q.
!
! Active only if MODE = ATT.
!</Help>
!
!<Help KEYWORD="ICF">
!<Tip> Instantaneous Center Frequency (toggle). </Tip>
! Default = NO  (disabled)
! Allowed = YES (enabled)
! Allowed = NO  (disabled)
!
! ICF (Instantaneous Center Frequency) is the average frequency weighted by the
! spectrum.  (Also can be thought of as the spectrum centroid or the
! expectation of frequency given the power spectrum.)
!
! Active only if MODE = ATT.
!</Help>
!
!<Help KEYWORD="IBW">
!<Tip> Instantaneous Bandwidth (toggle). </Tip>
! Default = NO  (disabled)
! Allowed = YES (enabled)
! Allowed = NO (disabled)
! IBW (Instantaneous Bandwidth) is the standard deviation of the spectrum about
! its center frequency.  (This will give lower values than the difference
! between the high and low half-power frequencies.)
!
! Active only if MODE = ATT.
!</Help>
!
!<Help KEYWORD="IMF">
!<Tip> Instantaneous Maximum Frequency (toggle). </Tip>
! Default = NO  (disabled)
! Allowed = YES (enabled)
! Allowed = NO (disabled)
! IMF (Instantaneous Maximum Frequency) is the frequency having maximum
! power (mode) in the spectrum.
!
! Active only if MODE = ATT.
!</Help>
!
!<Help KEYWORD="FREQ_BEG">
!<Tip> Lowest frequency to use for t-f output traces. </Tip>
! Default = 0.0
! Allowed = real >= 0.0
!
! The FREQ_BEG and FREQ_END parameters allow the user to restrict the frequency
! band represented by t-f output traces.
!</Help>
!
!<Help KEYWORD="FREQ_END">
!<Tip> Highest frequency to use for t-f output traces. </Tip>
! Default = Nyquist
! Allowed = real > FREQ_BEG
!
! The FREQ_BEG and FREQ_END parameters allow the user to restrict the frequency
! band represented by t-f output traces.
!</Help>
!
!<Help KEYWORD="HDR_FREQ">
!<Tip> Header word to carry frequency of output t-f spectrum traces. </Tip>
! Default = 48
! Allowed = 1 - NWIH
!
! Header word HDR_FREQ + 1 will carry the frequency sample interval of output
! t-f spectrum traces.
!</Help>
!
!<Help KEYWORD="HDR_ATT">
!<Tip> Header word to carry integer indicating attribute type of trace. </Tip>
! Default = 50
! Allowed = 1 - NWIH
! If MODE = ATT, an integer indicating the trace attribute type is 
! written in header word HDR_ATT of output traces as follows.
!
!     0     Time-frequency Spectra
!     1     Instantaneous Dominant Frequency
!     2     Instantaneous Q
!     3     Instantaneous Center Frequency
!     4     Instantaneous Bandwidth
!     5     Instantaneous Maximum Frequency
!
!</Help>
!
!-------------------------Trace Time Window Parameters--------------------------
!
!<Help KEYWORD="OPT_WIN">
!<Tip> Method to use for specifying trace time window. </Tip>
! Default = MUTE
! Allowed = MUTE      (Window defined by times measured from the head mute.)
! Allowed = FIXED     (Window is fixed.)
!
! TFATT only analyzes the trace samples within the trace time window.
!
! If OPT_WIN = MUTE then the window is specified by TIM_ADD and WIN_LEN.
!
! If OPT_WIN = FIXED then the window is specified by TIM_BEG and TIM_END.
!</Help>
!
!<Help KEYWORD="TIM_ADD">
!<Tip> Time at top of window = mute time + TIM_ADD. </Tip>
! Default = 0.0
! Allowed = real >= 0.0
!
! TIM_ADD has units of seconds.
!
! Active only if OPT_WIN = MUTE.
!</Help>
!
!<Help KEYWORD="WIN_LEN">
!<Tip> Time at bottom of window = time at top of window + WIN_LEN. </Tip>
! Default = -
! Allowed = real > 0.0
!
! WIN_LEN is the length of the trace window in seconds.
!
! Active only if OPT_WIN = MUTE.
!</Help>
!
!<Help KEYWORD="TIM_BEG">
!<Tip> Time at top of window, in seconds, if OPT_WIN = FIXED. </Tip>
! Default = TSTRT
! Allowed = real >= TSTRT
!
! Top of window will be set to the larger of TIM_BEG or the head mute time.
!
! Active only if OPT_WIN = FIXED.
!</Help>
!
!<Help KEYWORD="TIM_END">
!<Tip> Time at bottom of window, in seconds, if OPT_WIN = FIXED. </Tip>
! Default = end of trace
! Allowed = real > TIM_BEG
!
! Bottom of window will be set to the smaller of TIM_END or the tail mute time.
!
! Active only if OPT_WIN = FIXED.
!</Help>
!
!------------------------ Algorithm Parameters ---------------------------------
!
!<Help KEYWORD="T_F_NORMALIZE">
!<Tip> Method to use for normalizing t-f spectra. </Tip>
! Default = NONE
! Allowed = NONE (No spectrum normalization.)
! Allowed = TIME (Integral of each t-f spectrum time-slice is set to unity.)
! Allowed = FREQ (Integral of each t-f spectrum frequency-slice is set to unity)
!</Help>
!
!<Help KEYWORD="TIM_WIN">
!<Tip> Sliding time window to use in the t-f calculations. </Tip>
! Default = 10*DT
! Allowed = real > 0.0 (an even multiple of DT)
!
! TIM_WIN is the length, in seconds, of the sliding time window used in the
! t-f calculations.  Lower values give better time resolution and worse
! frequency resolution and conversely.
!</Help>
!
!<Help KEYWORD="C1">
!<Tip> TIM_WIN sample count. </Tip>
! Number of time samples in sliding time window.
!
! TIM_WIN = N * DT.
!</Help>
!
!<Help KEYWORD="TIM_FFT">
!<Tip> Total time, in seconds, to use in each AOK and SWF calculation. </Tip>
! Default = dt * 64
! Allowed = real = dt * (2**N) where (2**N) > (TIM_WIN sample count).
!
! TIM_FFT is the total time, in seconds, used in each AOK and SWF 
! calculation.  As a preliminary step, these calculations pad the data in the
! TIM_WIN window with zeros to the larger total time of TIM_FFT. The number of
! frequency values calculated is given by (1 + (TIM_FFT/DT) / 2).
!</Help>
!                             
!<Help KEYWORD="C2">
!<Tip> Number of time samples in FFT. </Tip>
! Must be a power of 2 greater than TIM_WIN sample count.
!
! TIM_FFT = N * DT.
!</Help>
!
!<Help KEYWORD="AOK_OPTIMIZE">
!<Tip> Optimization parameter for the AOK calculation. </Tip>
! Default = 2.0
! Allowed = 1.0 =< real =< 5.0
!
! AOK_OPTIMIZE is the parameter that controls optimization of the AOK
! calculation (this optimization reduces non-physical artifacts).  Small
! changes in AOK_OPTIMIZE will not make a noticable difference in the output.
!
! Active only if OPT_ALG = AOK.
!</Help>
!
!<Help KEYWORD="TYPE_WIN">
!<Tip> Type of windowing to use in SWF calculations. </Tip>
! Default = HAMM
! Allowed = HAMM   (Hamming window)
! Allowed = BOX    (Boxcar window)
! Allowed = BLAC   (Blackman window)
! Allowed = BART   (Bartlet window)
!
! Active only if OPT_ALG = SWF.
!</Help>
!
!</HelpSection>


  module tfatt_module
  use pc_module
  use named_constants_module
  use mth_module
  use lav_module
  use mem_module
  implicit none
  private
  public :: tfatt_create
  public :: tfatt_initialize
  public :: tfatt_update
  public :: tfatt_delete
!<execute_only>
  public :: tfatt            ! main execution (trace processing) routine.
  public :: tfatt_wrapup
!</execute_only>


  character(len=100),public,save :: tfatt_IDENT = &
'$Id: tfatt.f90,v 1.7 2006/06/20 13:12:11 Menger prod sps $'

  ! Subscripts for type_att logical flags.
  integer, parameter              :: type_att_itf = 1
  integer, parameter              :: type_att_idf = 2
  integer, parameter              :: type_att_iq  = 3
  integer, parameter              :: type_att_icf = 4
  integer, parameter              :: type_att_ibw = 5
  integer, parameter              :: type_att_imf = 6

  integer, parameter              :: type_att_max = type_att_imf

  integer,dimension(2,6)          :: rice_mode_c_strings

!!---------------------- parameter structure -------------------------------!!
!!---------------------- parameter structure -------------------------------!!
!!---------------------- parameter structure -------------------------------!!

  type,public :: tfatt_struct
    private
    logical                    :: skip_wrapup      ! wrapup flag.
! PROCESS PARAMETERS
    character(len=4)           :: mode             ! process parameters.
      ! Allowed = ATT, T_F, BOTH and SE.
      ! In cbyt this implies "Spectrum Type" is "Time/Frequency".
      ! ATT implies cbyt "Distribution Options" is ICF, IBW, IDF, IMF or IQ.
      ! ATT does NOT imply any Time Frequency distrubution (nor TF slice).
      ! T_F implies cbyt "Distribution Option" is "Time Freq Distribution",
      ! aka cbyt TF_DISTRUBUTION ("tfdist", TFDIST).
    character(len=3)           :: opt_alg          ! process parameters.
      ! Allowed values are AOK, SWF.
      ! See cbyt "Distribution Algorithm" (tf_distribution_opts) pull-down.
      ! See cbyt _tf_distribution_options->whichSelected().
      !   opt_alg = cbyt mode (not rice or tfatt version of mode).
      !   AOK= cbyt TF_ADAPTIVE_OPTIMIZED= "aok"= "Adaptive Optimized Kernal".
      !   SWF= cbyt TF_SHORT_TIME_FOURIER= "stft"= "Short Time Fourier".
      ! See rice_timefreq kernal argument.
      !   opt_alg= rice kernal = tfpar.tfmode
      !   Allowed= "aok" and "stft".
      ! No analogy in  sine_timefreq.
    logical, dimension(type_att_max) :: type_att         ! process parameters.
      ! Allowed subscripts are TYPE_ATT_ITF, ICF, IBW, IDF, IMF, IQ.
      ! See cbyt "Distribution Options" (tf_mode_options) pull-down and ...
      !   TF_DISTRIBUTION_MODE, "Time Freq Distribution".
      !   TF_ICENTERFREQ_MODE, "Instantaneous Center Freq". 
      !   TF_IBAND_MODE, "Instantaneous Bandwidth".
      !   TF_IDOMINANTFREQ_MODE, "Instantaneous Dominant Freq".
      !   TF_IMAXIMALFREQ_MODE, "Instantaneous Maximal Freq".
      !   TF_IQ_MODE, "Instantaneous Q".
      ! See rice_timefreq mode argument.
      !   type_att = rice mode (cbyt or tfatt mode)  = tfpar.mode.
      !   N/A = rice "tfdist"  = TFDIST
      !   ICF = rice "cfreq"   = CENTFREQ
      !   IBW = rice "band"    = BANDWIDTH
      !   IDF = rice "dfreq"   = DOMFREQ
      !   IMF = rice "maxfreq" = MAXFREQ
      !   IQ  = rice "q"       = Q
    real                       :: freq_beg         ! process parameters.
      ! See cbyt "Displayed Limits", _display_low_freq, _display_freq_box,
      !   DISPLAY_LOW_FREQ = displayfreqbox[0]
      ! No analogy in rice_timefreq.
    real                       :: freq_end         ! process parameters.
      ! See cbyt "Displayed Limits", _display_hi_freq, _display_freq_box,
      !   DISPLAY_HI_FREQ = displayfreqbox[1]
      ! No analogy in rice_timefreq.
    integer                    :: hdr_freq         ! process parameters.
      ! No analogy in cbyt or rice_timefreq.
    integer                    :: hdr_att          ! process parameters.
      ! No analogy in cbyt or rice_timefreq.
    character(len=5)           :: opt_win          ! process parameters.
      ! Allowed = MUTE, FIXED.
      ! See cbyt "Windowing Options", winopts, _window_type_box
      !   MUTE  = "mute_window"  = MUTE_WINDOW
      !   FIXED = "fixed_window" = FIXED_WINDOW
      ! No analogy in rice_timefreq.
    real                       :: tim_add          ! process parameters.
      ! See cbyt "Add to Mute Time", _window_beginning_mute
      !   aka /.window_beginning./, /window_beginning_box[1]/,
      !   tim_add = cbyt WINDOW_BEGINNING_MUTE = "winbeginmute"
      !           = getMuteWindowBeginningTime()
      ! No analogy in rice_timefreq.
    real                       :: win_len          ! process parameters.
      ! See cbyt "Window Length", _window_end_mute
      !   aka /.window_end./, /window_end_box[1]/
      !   win_len = cbyt WINDOW_END_MUTE = "winendmute"
      !           = getMuteWindowEndingTime()
      ! No analogy in rice_timefreq.
    real                       :: tim_beg          ! process parameters.
      ! See cbyt "Start Window Time", _window_beginning_fixed
      !   aka /.window_beginning./, /window_beginning_box[0]/,
      !   tim_beg = cbyt WINDOW_BEGINNING_FIXED = "winbeginfixed"
      !           = getFixedWindowBeginningTime()
      ! No analogy in rice_timefreq.
    real                       :: tim_end          ! process parameters.
      ! See cbyt "End Window Time", _window_end_fixed
      !   aka /.window_end./, /window_end_box[0]/
      !           = getFixedWindowEndingTime()
      !   tim_end = cbyt WINDOW_END_FIXED = "windendfixed"
      ! No analogy in rice_timefreq.
    character(len=4)           :: t_f_normalize    ! process parameters.
      ! Allowed = NONE, TIME, FREQ.
      ! See cbyt "Time Frequency Marginal Correction" = tf_marginal_options
      !   NONE = cbyt TF_NONE_TFMARGINAL = "None"
      !   TIME = cbyt TF_NORMALIZE_TIMEMARGINAL = "Normalize Time Marginal"
      !   FREQ = cbyt TF_NORMALIZE_FREQMARGINAL = "Normalize Freq Marginal"
      ! See rice_timefreq correct argument.
      !   t_f_normalize = rice correct = tfpar.correct
      !   NONE = rice "none"
      !   TIME = rice "time"
      !   FREQ = rice "freq"
    real                       :: tim_win          ! process parameters.
      ! See cbyt "Window Length" = _tf_window_length
      !     aka TF_WINDOW_LENGTH = "tfwindowlength"
      !   tim_win = cbyt _tf_text_params->SetValue()
      ! See rice_timefreq winlen argument.
      !   tim_win = rice winlen = tfpar.nw
      ! See sine_timefreq tlen argument
    real                       :: tim_fft          ! process parameters.
      ! See cbyt "Fft Length" = _tf_fft_length
      !     aka TF_FFT_LENGTH = "tffftlength"
      !   tim_fft = cbyt _tf_fft_length
      ! See rice_timefreq fftlen argument.
      !   tim_fft = rice fftlen = tfpar.fftlen
    real                       :: aok_optimize     ! process parameters.
      ! See cbyt "Optimization Level" = _tf_opt_level
      !     aka TF_OPT_LEVEL = "tfoptlevel"
      !   aok_optimize = cbyt _tf_opt_level
      ! See rice_timefreq vol argument.
      !   aok_optimize = rice vol = tfpar.vol
    character(len=4)           :: type_win         ! process parameters.
      ! Allowed = HAMM, BOX, BLAC, BART.
      !   Note: tfatt drops support for Hanning.
      ! See cbyt "Short Time Fourier Window" = "tf_short_time_win"
      !   type_win = cbyt _tf_short_time_window
      !   HAMM = cbyt "Hamming"
      !   BOX  = cbyt "Rectangular"
      !   BLAC = cbyt "Blackman"
      !   BART = cbyt "Bartlet"
      ! See rice_timefreq window argument.
      !   type_win = rice window = tfpar.window
      !   HAMM = rice "Hamming"
      !   BOX  = cbyt "Rectangular"
      !   BLAC = cbyt "Blackman"
      !   BART = cbyt "Bartlet"

! GLOBAL PARAMETERS
    integer                    :: ndpt             ! Num Data PoinTs
      ! See rice_timefreq nsamp_in argument.
    integer                    :: nwih             ! Num Word In Header
    real                       :: dt               ! trace sample rate
      ! See cbyt's _displayed_sp->sampleRate().
      ! See rice_timefreq srval argument.
    real                       :: tstrt            ! time first sample

! DEPENDENT PARAMTERS
    integer                    :: in_cnt           ! number of input traces
                                                   ! (original ntr)
    integer                    :: out_cnt          ! number of output traces
                                                   ! for each input trace
    integer                    :: in_trcnum        ! input trace number within
                                                   ! group (1->in_cnt)
    integer                    :: trc_num          ! sequential trace number
                                                   ! of last output trace
    integer                    :: nsamp_length     ! length of sliding
                                                   ! analysis window.
                                                   ! Odd sample count.
    integer                    :: rfft_len         ! length of real fft.
                                                   ! Power of 2 > power
                                                   ! of 2 for nsamp_length.
    integer                    :: cfft_len         ! length of complex fft.
                                                   ! = 1 + rfft_len / 2
    integer                    :: tf_cnt           ! T_F trace count
    integer,dimension(:),pointer :: rice_kernal    ! C string buffer.
                                                   ! "aok" for adaptive.
                                                   ! "stft" for short time.
    integer                    :: rice_mode_cnt    ! Count of C strings
    integer,dimension(2,6)     :: rice_mode        ! C string buffer array
                                                   ! Valid strings are:
                                                   !   "tfdist" time-freq dist
                                                   !   "band" instant bandwidth
                                                   !   "cfreq" instant center
                                                   !   "dfreq" instant dominant
                                                   !   "maxfreq" instant max
                                                   !   "q" instantaneous Q
    integer,dimension(6)       :: rice_mode_idx    ! rice mode index 0-5
                                                   ! corresponding to rice_mode
    integer,dimension(:),pointer :: rice_window    ! C string buffer
                                                   ! Valid strings are:
                                                   !   "Hamming"
                                                   !   "Rectangular"
                                                   !   "Hanning"
                                                   !   "Blackman"
                                                   !   "Bartlet"
    integer,dimension(:),pointer :: rice_scale     ! C string buffer
                                                   ! Valid is "lin" or "db".
    integer,dimension(:),pointer :: rice_correct   ! C string buffer
                                                   ! Valid strings are:
                                                   !   "none" no normal
                                                   !   "time" margins
                                                   !   "freq" margins
    integer                    :: rice_winlen      ! num of samples in
                                                   ! sliding analysis win
    integer                    :: rice_fftlen      ! length of the fft
                                                   ! (power of 2 > power
                                                   ! of 2 of winlen)
    real                       :: rice_dBthr       ! db threshold
                                                   ! normally 100.0
    real                       :: rice_vol         ! optimization level
                                                   ! 1.0 to 5.0
    integer,dimension(:),pointer :: sine_mode      ! C string buffer
                                                   ! Analysis type (only
                                                   ! "spec" supported).
    integer                    :: sine_icomp       ! Component for
                                                   ! attribute (not used?).
    integer                    :: sine_iopt        ! sine_timefreq iopt arg
                                                   ! Interpolation to use
                                                   ! 0=Linear, 1=Spline
    real                       :: sine_tlen        ! Length of window in
                                                   ! milliseconds.
  end type tfatt_struct

!!---------------------------- interfaces ---------------------------------!!
!!---------------------------- interfaces ---------------------------------!!
!!---------------------------- interfaces ---------------------------------!!

!!--------------------------------- data -----------------------------------!!
!!--------------------------------- data -----------------------------------!!
!!--------------------------------- data -----------------------------------!!

  type(tfatt_struct),pointer,save :: object      ! needed for traps.

  ! mode 'SE' is not implemented yet, hence its not listed.
  character(len=4),dimension(2),parameter :: mode_options = &
    (/'T_F ','ATT '/)

  character(len=3),dimension(2),parameter :: opt_alg_options = &
    (/'AOK','SWF'/)

  ! 'itf' should lower case, because its only a place holder
  character(len=3),dimension(6),parameter :: type_att_options = &
    (/'itf', 'IDF','IQ ','ICF','IBW','IMF'/)

  character(len=5),dimension(2),parameter :: opt_win_options = &
    (/'MUTE ','FIXED'/)

  character(len=4),dimension(3),parameter :: t_f_normalize_options = &
    (/'NONE','TIME','FREQ'/)

  character(len=4),dimension(4),parameter :: type_win_options = &
    (/'HAMM','BOX ','BLAC','BART'/)

  contains

!!----------------------------- create -------------------------------------!!
!!----------------------------- create -------------------------------------!!
!!----------------------------- create -------------------------------------!!

  subroutine tfatt_create (obj)
  implicit none
  type(tfatt_struct),pointer :: obj       ! arguments

  allocate (obj)

  nullify(obj%rice_kernal)
  nullify(obj%rice_window)
  nullify(obj%rice_scale)
  nullify(obj%rice_correct)

  nullify(obj%sine_mode)

  call tfatt_initialize (obj)
  return
  end subroutine tfatt_create

!!------------------------------- delete -----------------------------------!!
!!------------------------------- delete -----------------------------------!!
!!------------------------------- delete -----------------------------------!!

  subroutine tfatt_delete (obj)
  implicit none
  type(tfatt_struct),pointer :: obj       ! arguments

!<execute_only>
  call tfatt_wrapup (obj)
!</execute_only>

  call mem_free(obj%rice_kernal)
  call mem_free(obj%rice_window)
  call mem_free(obj%rice_scale)
  call mem_free(obj%rice_correct)

  call mem_free(obj%sine_mode)

  deallocate(obj)
  return
  end subroutine tfatt_delete

!!----------------------------- initialize ---------------------------------!!
!!----------------------------- initialize ---------------------------------!!
!!----------------------------- initialize ---------------------------------!!

  subroutine tfatt_initialize (obj)
  implicit none
  type(tfatt_struct),intent(inout) :: obj       ! arguments

  call pc_get_global('ndpt', obj%ndpt)
  call pc_get_global('nwih', obj%nwih)
  call pc_get_global('dt', obj%dt)
  call pc_get_global('tstrt', obj%tstrt)

  obj%mode = 'T_F'
  obj%opt_alg = 'AOK'

  obj%type_att = .false.
  obj%type_att(type_att_idf) = .true.
  obj%type_att(type_att_iq)  = .true.

  obj%freq_beg = 0.0
  obj%freq_end = 1.0 / (2.0 * obj%dt)
  obj%hdr_freq = 48
  obj%hdr_att = 50
  obj%opt_win = 'MUTE'
  obj%tim_add = 0.0
  obj%win_len = obj%dt * (obj%ndpt - 1)
  obj%tim_beg = obj%tstrt
  obj%tim_end = obj%tstrt + (obj%ndpt - 1) * obj%dt
  obj%t_f_normalize = 'NONE'
  obj%tim_win = 10.0 * obj%dt
  obj%tim_fft = 64.0 * obj%dt
  obj%aok_optimize = 2.0
  obj%type_win = 'HAMM'

  obj%in_cnt = 0
  obj%out_cnt = 0
  obj%in_trcnum = 0
  obj%trc_num = 0
  obj%nsamp_length = 0
  obj%rfft_len = 0
  obj%cfft_len = 0
  obj%tf_cnt = 0

  obj%rice_mode_cnt = 0
  obj%rice_mode = 0
  obj%rice_mode_idx = 0
  obj%rice_winlen = 0
  obj%rice_fftlen = 0
  obj%rice_dBthr = 100.0
  obj%rice_vol = 2.0

  obj%sine_icomp = 0
  obj%sine_iopt = 0
  obj%sine_tlen = 0

  call string_cc2hh('tfdist',  rice_mode_c_strings(:,1))
  call string_cc2hh('dfreq',   rice_mode_c_strings(:,2))
  call string_cc2hh('q',       rice_mode_c_strings(:,3))
  call string_cc2hh('cfreq',   rice_mode_c_strings(:,4))
  call string_cc2hh('band',    rice_mode_c_strings(:,5))
  call string_cc2hh('maxfreq', rice_mode_c_strings(:,6))

  call tfatt_update (obj)

  return
  end subroutine tfatt_initialize

!!------------------------- start of update --------------------------------!!
!!------------------------- start of update --------------------------------!!
!!------------------------- start of update --------------------------------!!

  subroutine tfatt_update (obj)
  implicit none
  type(tfatt_struct),intent(inout),target :: obj             ! arguments

  integer :: numtr
  real :: nyquist, end_time

  integer :: m, mm, n, i
  integer :: min_fftlen, old_fftlen, new_fftlen
  double precision :: exponent

  object => obj               ! needed for traps.
  obj%skip_wrapup = .true.    ! needed for the wrapup routine.

!!------------------------- read parameters --------------------------------!!
!!------------------------- read parameters --------------------------------!!
!!------------------------- read parameters --------------------------------!!

  call pc_get_global('ndpt', obj%ndpt)
  call pc_get_global('nwih', obj%nwih)
  call pc_get_global('dt', obj%dt)
  call pc_get_global('tstrt', obj%tstrt)

  call pc_get_global('numtr', numtr)


  call pc_get ('opt_alg', obj%opt_alg)

  do i = 2, type_att_max
    call pc_get (type_att_options(i), obj%type_att(i))
  end do

  call pc_get ('mode', obj%mode, tfatt_mode_trap)

  call pc_get ('freq_beg', obj%freq_beg)
  call pc_get ('freq_end', obj%freq_end)
  call pc_get ('hdr_freq', obj%hdr_freq)
  call pc_get ('hdr_att', obj%hdr_att)

  call pc_get ('opt_win', obj%opt_win)
  call string_to_upper (obj%opt_win)

  call pc_get ('tim_add', obj%tim_add)
  call pc_get ('win_len', obj%win_len)
  call pc_get ('tim_beg', obj%tim_beg)
  call pc_get ('tim_end', obj%tim_end)

  call pc_get ('t_f_normalize', obj%t_f_normalize)
  call string_to_upper (obj%t_f_normalize)

  call pc_get ('tim_win', obj%tim_win)
  call pc_get ('tim_fft', obj%tim_fft)
  call pc_get ('aok_optimize', obj%aok_optimize)

  call pc_get ('type_win', obj%type_win)
  call string_to_upper (obj%type_win)

!!-------------------------- verify parameters -----------------------------!!
!!-------------------------- verify parameters -----------------------------!!
!!-------------------------- verify parameters -----------------------------!!


  if(all(opt_alg_options /= obj%opt_alg)) then
    call pc_error( &
      'Invalid OPT_ALG value. Valid values are AOK, SWF')
    obj%opt_alg = 'AOK'
  else if('SWF' == obj%opt_alg) then
    call pc_error( &
      'Invalid OPT_ALG value. SWF is not implemented yet')
    obj%opt_alg = 'AOK'
  end if


  nyquist = 1.0 / (2.0 * obj%dt)

  if(obj%freq_beg < 0.0 .or. obj%freq_beg >= nyquist) then
    call pc_error( &
      'Invalid FREQ_BEG, 0.0 <= real < NYQUIST, required')
    obj%freq_beg = 0.0
  end if

  if(mth_compare(obj%freq_end, obj%freq_beg) <= 0 .or. &
     mth_compare(obj%freq_end, nyquist) > 0) then
!???  if(obj%freq_end <= obj%freq_beg .or. obj%freq_end > nyquist) then
    call pc_error( &
      'Invalid FREQ_END, FREQ_BEG < real <= NYQUIST, required')
    obj%freq_end = nyquist
  end if

  if(obj%hdr_freq <= 1 .or. obj%hdr_freq >= obj%nwih) then
    call pc_error( &
      'Invalid HDR_FREQ, 1 < int < NWIH, required')
    obj%hdr_freq = 48
  end if

  if(obj%hdr_att <= 1 .or. obj%hdr_att >= obj%nwih) then
    call pc_error( &
      'Invalid HDR_ATT, 1 < int < NWIH, required')
    obj%hdr_att = 50
  end if

  if(all(opt_win_options /= obj%opt_win)) then
    call pc_error( &
      'Invalid OPT_WIN value. Valid values are MUTE, FIXED')
    obj%opt_win = 'MUTE'
  end if

  end_time = obj%tstrt + (obj%ndpt - 1) * obj%dt

  if(obj%opt_win == 'MUTE') then
    if(obj%tim_add < 0.0 .or. obj%tim_add >= end_time) then
      call pc_error( &
        'Invalid TIM_ADD, 0.0 <= real < end_time, required')
      obj%tim_add = 0.0
    end if

    if(obj%win_len <= 0.0) then
      call pc_error( &
        'Invalid WIN_LEN, 0.0 < real, required')
      obj%win_len = obj%dt * (obj%ndpt - 1) - obj%tim_add
    end if
  else
    ! assume OPT_WIN == FIXED
    if(obj%tim_beg < obj%tstrt .or. obj%tim_beg >= end_time) then
      call pc_error( &
        'Invalid TIM_BEG, TSTRT <= real < end_time, required')
      obj%tim_beg = obj%tstrt
    end if

    if(obj%tim_end <= obj%tim_beg .or. obj%tim_end > end_time) then
      call pc_error( &
        'Invalid TIM_END, TIM_BEG < real <= end_time, required')
      obj%tim_end = end_time
    end if
  end if

  if(all(t_f_normalize_options /= obj%t_f_normalize)) then
    call pc_error( &
      'Invalid T_F_NORMALIZE value. Valid values are NONE, TIME, FREQ')
    obj%t_f_normalize = 'NONE'
  end if

  ! nsamp_length must be an odd number of samples
  obj%nsamp_length = 1 + nint(obj%tim_win/obj%dt)

  if(1 /= mod(obj%nsamp_length, 2)) then
    call pc_error( &
      'Invalid TIM_WIN, resetting to even sample count')
    obj%nsamp_length = obj%nsamp_length + 1
  end if

  obj%tim_win = (obj%nsamp_length - 1) * obj%dt

  if(obj%mode /= 'SE') then
    ! The following logic for TIM_FFT was derived from
    ! spectra_menu.cc, originally developed by Mike Sherrill.

    ! Make sure the fft length is not smaller than the
    ! smallest power of two >= window length

    n = 1 + nint(obj%tim_win / obj%dt)
    m = 0
    mm = 1
    do while(mm < n)
      m = m + 1
      mm = 2 * mm
    end do

    min_fftlen = 2.0 ** m
    old_fftlen = nint(obj%tim_fft / obj%dt)

    if(old_fftlen < min_fftlen) then
      call pc_error( &
        'Invalid TIM_FFT, 0.0 < real ???, required')
      obj%tim_fft = min_fftlen * obj%dt
    end if

    ! Make sure the fft length is a power of 2
    old_fftlen = nint(obj%tim_fft / obj%dt)
    exponent = log(real(old_fftlen)) / log(2.0)
    exponent = ceiling(exponent)
    new_fftlen = 2.0 ** exponent

    if(old_fftlen /= new_fftlen) then
      call pc_error( &
        'Resetting TIM_FFT (must be DT * power of 2)')
      obj%tim_fft = new_fftlen * obj%dt
    end if

    if(obj%opt_alg == 'AOK') then
      if(obj%aok_optimize < 1.0 .or. obj%aok_optimize > 5.0) then
        call pc_error( &
          'Invalid AOK_OPTIMIZE, 1.0 <= real <= 5.0, required')
        obj%aok_optimize = 2.0
      end if
    end if
  end if

  if(all(type_win_options /= obj%type_win)) then
    call pc_error( &
      'Invalid TYPE_WIN value. Valid values are HAMM, BOX, BLAC, BART')
    obj%type_win = 'HAMM'
  end if

  call tfatt_end_trap

!!------------------------- call processes internally ----------------------!!
!!------------------------- call processes internally ----------------------!!
!!------------------------- call processes internally ----------------------!!

!!----------------------- write parameters ---------------------------------!!
!!----------------------- write parameters ---------------------------------!!
!!----------------------- write parameters ---------------------------------!!

  call pc_put_options_field('mode', mode_options, 2)
  call pc_put ('mode', obj%mode)

  call pc_put_options_field('opt_alg', opt_alg_options, 2)
  call pc_put ('opt_alg', obj%opt_alg)

  do i = 2, type_att_max
    call pc_put (type_att_options(i), obj%type_att(i))
  end do

  call pc_put ('freq_beg', obj%freq_beg)
  call pc_put ('freq_end', obj%freq_end)
  call pc_put ('hdr_freq', obj%hdr_freq)
  call pc_put ('hdr_att', obj%hdr_att)

  call pc_put_options_field('opt_win', opt_win_options, 2)
  call pc_put ('opt_win', obj%opt_win)

  call pc_put ('tim_add', obj%tim_add)
  call pc_put ('win_len', obj%win_len)
  call pc_put ('tim_beg', obj%tim_beg)
  call pc_put ('tim_end', obj%tim_end)

  call pc_put_options_field('t_f_normalize', t_f_normalize_options, 3)
  call pc_put ('t_f_normalize', obj%t_f_normalize)

  call pc_put ('tim_win', obj%tim_win)
  call pc_put ('c1', nint(obj%tim_win/obj%dt))
  call pc_put ('tim_fft', obj%tim_fft)
  call pc_put ('c2', nint(obj%tim_fft/obj%dt))
  call pc_put ('aok_optimize', obj%aok_optimize)

  call pc_put_options_field('type_win', type_win_options, 4)
  call pc_put ('type_win', obj%type_win)

  call pc_put_global('numtr', obj%out_cnt)
  call pc_put_global  ('gathered'    , .true.)
  call pc_put_control ('need_request', .true.)
  call pc_put_control ('need_label'  , .true.)
  call pc_put_control ('twosets'  , .true.)

  if(obj%mode == 'T_F' .or. obj%mode == 'ATT' .or. obj%mode == 'BOTH') then
    call pc_put_sensitive_field_flag('opt_alg', .true.)
    call pc_put_sensitive_field_flag('tim_fft', .true.)

    if(obj%opt_alg == 'AOK') then
      call pc_put_sensitive_field_flag('aok_optimize', .true.)
      call pc_put_sensitive_field_flag('type_win', .false.)
    else
      call pc_put_sensitive_field_flag('aok_optimize', .false.)
      call pc_put_sensitive_field_flag('type_win', .true.)
    end if
  else
    call pc_put_sensitive_field_flag('opt_alg', .false.)
    call pc_put_sensitive_field_flag('tim_fft', .false.)

    call pc_put_sensitive_field_flag('aok_optimize', .false.)
    call pc_put_sensitive_field_flag('type_win', .false.)
  end if

  if(obj%mode == 'SE') then
    call pc_put_sensitive_field_flag('hdr_att', .false.)
  else
    call pc_put_sensitive_field_flag('hdr_att', .true.)
  end if

  if(obj%mode == 'ATT' .or. obj%mode == 'BOTH') then
    do i = 2, type_att_max
      call pc_put_sensitive_field_flag(type_att_options(i), .true.)
    end do
  else
    do i = 2, type_att_max
      call pc_put_sensitive_field_flag(type_att_options(i), .false.)
    end do
  end if

  if(obj%mode == 'T_F' .or. obj%mode == 'BOTH') then
    call pc_put_sensitive_field_flag('freq_beg', .true.)
    call pc_put_sensitive_field_flag('freq_end', .true.)
    call pc_put_sensitive_field_flag('hdr_freq', .true.)
    call pc_put_sensitive_field_flag('t_f_normalize', .true.)
  else
    call pc_put_sensitive_field_flag('freq_beg', .false.)
    call pc_put_sensitive_field_flag('freq_end', .false.)
    call pc_put_sensitive_field_flag('hdr_freq', .false.)
    call pc_put_sensitive_field_flag('t_f_normalize', .false.)
  end if

  if(obj%opt_win == 'MUTE') then
    call pc_put_sensitive_field_flag('tim_add', .true.)
    call pc_put_sensitive_field_flag('win_len', .true.)
    call pc_put_sensitive_field_flag('tim_beg', .false.)
    call pc_put_sensitive_field_flag('tim_end', .false.)
  else
    ! assume OPT_WIN == FIXED
    call pc_put_sensitive_field_flag('tim_add', .false.)
    call pc_put_sensitive_field_flag('win_len', .false.)
    call pc_put_sensitive_field_flag('tim_beg', .true.)
    call pc_put_sensitive_field_flag('tim_end', .true.)
  end if

  if (obj%out_cnt > 1) then
    call pc_put_control ('PARALLEL_SAFE'         , .true.)
    call pc_put_control ('PCPS_SEND_MODE'        , 'PCPS_SEND_FIRST_AVAIL')
    call pc_put_control ('PCPS_RECEIVE_MODE'     , 'PCPS_RECEIVE_PASSTHRU')
    call pc_put_control ('PCPS_SEND_EOF_MODE'    , 'PCPS_SEND_ALL_EOF')
    call pc_put_control ('PCPS_ALT_SEND_MODE'    , 'PCPS_SEND_ALL')
    call pc_put_control ('PCPS_ALT_RECEIVE_MODE' , 'PCPS_RECEIVE_ALL_EOF')
    call pc_put_control ('PCPS_RESEQUENCE_MODE'  , 'PCPS_RESEQUENCE')
    call pc_put_control ('PCPS_GENERATOR_MODE'   , 'PCPS_TRACE_GEN')
    call pc_put_control ('PCPS_BUNCH_MODE'       , 'PCPS_BUNCH_GROUPS')
  else
    call pc_put_control ('PARALLEL_SAFE'         , .true.)
    call pc_put_control ('PCPS_SEND_MODE'        , 'PCPS_SEND_FIRST_AVAIL')
    call pc_put_control ('PCPS_RECEIVE_MODE'     , 'PCPS_RECEIVE_PASSTHRU')
    call pc_put_control ('PCPS_SEND_EOF_MODE'    , 'PCPS_SEND_ALL_EOF')
    call pc_put_control ('PCPS_ALT_SEND_MODE'    , 'PCPS_SEND_ALL')
    call pc_put_control ('PCPS_ALT_RECEIVE_MODE' , 'PCPS_RECEIVE_GROUP')
    call pc_put_control ('PCPS_RESEQUENCE_MODE'  , 'PCPS_NO_RESEQUENCE')
    call pc_put_control ('PCPS_GENERATOR_MODE'   , 'PCPS_NO_TRACE_GEN')
    call pc_put_control ('PCPS_BUNCH_MODE'       , 'PCPS_BUNCH_TRACES')
  endif

!!----------------------- prepare for execution ----------------------------!!
!!----------------------- prepare for execution ----------------------------!!
!!----------------------- prepare for execution ----------------------------!!

!<execute_only>

  if (pc_do_not_process_traces()) return

  obj%skip_wrapup = .false.     ! to run wrapup code after processing.

  obj%rice_winlen = 1 + nint(obj%tim_win / obj%dt)
  obj%rice_fftlen =     nint(obj%tim_fft / obj%dt)

  if(obj%opt_alg == 'AOK') then
    call string_cc2hh_alloc('aok', obj%rice_kernal)
  else if(obj%opt_alg == 'SWF') then
    call string_cc2hh_alloc('stft', obj%rice_kernal)
  end if

  if(obj%type_win == 'HAMM') then
    call string_cc2hh_alloc('Hamming', obj%rice_window)
  else if(obj%type_win == 'BOX') then
    call string_cc2hh_alloc('Rectangular', obj%rice_window)
  else if(obj%type_win == 'BLAC') then
    call string_cc2hh_alloc('Blackman', obj%rice_window)
  else if(obj%type_win == 'BART') then
    call string_cc2hh_alloc('Bartlet', obj%rice_window)
  end if

  call string_cc2hh_alloc('lin', obj%rice_scale)

  if(obj%t_f_normalize == 'NONE') then
    call string_cc2hh_alloc('none', obj%rice_correct)
  else if(obj%t_f_normalize == 'TIME') then
    call string_cc2hh_alloc('time', obj%rice_correct)
  else if(obj%t_f_normalize == 'FREQ') then
    call string_cc2hh_alloc('freq', obj%rice_correct)
  end if

  call string_cc2hh_alloc('spec', obj%sine_mode)

  if (pc_do_not_process_traces()) return   ! in case of allocation errors.

!</execute_only>

!!------------------------- finish update ----------------------------------!!
!!------------------------- finish update ----------------------------------!!
!!------------------------- finish update ----------------------------------!!

  return
  end subroutine tfatt_update

!!------------------------------- traps ------------------------------------!!
!!------------------------------- traps ------------------------------------!!
!!------------------------------- traps ------------------------------------!!

      subroutine tfatt_mode_trap (keyword)
      implicit none
      character(len=*),intent(in) :: keyword

      if(object%mode.eq.'T_F')then
        object%type_att(2)=.false.
        object%type_att(3)=.false.
      endif
      object%tf_cnt = 1 + nint(object%tim_fft / object%dt) / 2
      object%out_cnt = 0
      object%rice_mode_cnt = 0

      if(object%mode == 'T_F' .or. object%mode == 'BOTH') then
        object%out_cnt = object%tf_cnt
        object%rice_mode_cnt = 1
        call string_cc2hh('tfdist', object%rice_mode(:,1))
        object%rice_mode_idx(1) = 0
      endif


      return
      end subroutine tfatt_mode_trap

      subroutine tfatt_end_trap

      integer :: i

        if(object%mode == 'ATT' .or. object%mode == 'BOTH') then
           do i = 2, type_att_max
             if(object%type_att(i)) then
               object%out_cnt = object%out_cnt + 1
               object%rice_mode_cnt = object%rice_mode_cnt + 1
               object%rice_mode(:,object%rice_mode_cnt) = &
                 rice_mode_c_strings(:,i)
               object%rice_mode_idx(object%rice_mode_cnt) = i - 1
             end if
           enddo
         endif
         if(object%rice_mode_cnt == 0) then
          object%type_att(type_att_idf) = .true.
          object%type_att(type_att_iq)  = .true.
          object%out_cnt = 2
          object%rice_mode_cnt = 2
          object%rice_mode(:,1) = rice_mode_c_strings(:,type_att_idf)
          object%rice_mode(:,2) = rice_mode_c_strings(:,type_att_iq)
          object%rice_mode_idx(1) = type_att_idf
          object%rice_mode_idx(2) = type_att_iq
        end if

        if((object%mode == 'ATT' .or. object%mode == 'BOTH') .and. &
          (.not. object%type_att(type_att_idf) .or. &
           .not. object%type_att(type_att_iq))) then
          call pc_warning('MODE=ATT does NOT include IDF and IQ')
        end if

      end subroutine tfatt_end_trap
!!--------------------------- main execution -------------------------------!!
!!--------------------------- main execution -------------------------------!!
!!--------------------------- main execution -------------------------------!!

!<execute_only>

  subroutine tfatt (obj,ntr,hdi,tri,hdo,tro)
  implicit none
  type(tfatt_struct),intent(inout) :: obj                    ! arguments
  integer          ,intent(inout) :: ntr                     ! arguments
  double precision ,intent(in) :: hdi(:,:)                   ! arguments
  real             ,intent(in) :: tri(:,:)                   ! arguments
  double precision ,intent(inout) :: hdo(:,:)                ! arguments
  real             ,intent(inout) :: tro(:,:)                ! arguments

  integer i,ier, out_trcnum
  real nyquist, df
  integer tfatt_crou_rice_timefreq
  external tfatt_crou_rice_timefreq

  if (ntr == NO_MORE_TRACES .or. ntr == FATAL_ERROR) then
    call tfatt_wrapup (obj)
    return
  else if(ntr == NEED_TRACES .and. obj%in_trcnum >= obj%in_cnt) then
    ! TFATT needs more traces too.
    return
  else if(ntr >= 1) then
    ! create traces from this input gather
    obj%in_cnt = ntr
    obj%in_trcnum = 0
  end if

  ntr = obj%out_cnt
  obj%in_trcnum = obj%in_trcnum + 1

!!  if(obj%mode == "T_F" .or. obj%mode == 'ATT') then
    ! create the entire distribution for T_F and ATT.
    ier = tfatt_crou_rice_timefreq(tri(:obj%ndpt,obj%in_trcnum), obj%ndpt, &
      tro(:obj%ndpt,:obj%out_cnt), obj%dt, 1, obj%rice_kernal, &
      obj%rice_mode_cnt, obj%rice_mode, obj%rice_window, obj%rice_scale, &
      obj%rice_correct, obj%rice_winlen, obj%rice_fftlen, &
      obj%rice_dBthr, obj%rice_vol)
!!  else
!???call tfatt_sine_timefreq(obj%sine_mode, obj%sine_icomp, &
!???  obj%sine_iopt, obj%sine_tlen, obj%dt, obj%ndpt, tri,
!???  obj%tro(:obj%ndpt,:obj%out_cnt) if
!!  end if

  i=2
  do out_trcnum = 1, ntr
    obj%trc_num = obj%trc_num + 1

    ! default output header to values from original input trace
    hdo(1:obj%nwih,out_trcnum) = hdi(1:obj%nwih,obj%in_trcnum)

    hdo(1,out_trcnum) = obj%trc_num
    hdo(2,out_trcnum) = 1
    hdo(3,out_trcnum) = hdi(1,obj%in_trcnum)
    hdo(4,out_trcnum) = out_trcnum
    hdo(64,out_trcnum) = obj%ndpt

    if(obj%mode == 'T_F' .or. obj%mode == 'BOTH') then
      if(out_trcnum <= obj%tf_cnt) then
        ! Preserve frequency description for TF spectrum traces
        nyquist = 1.0 / (2.0 * obj%dt)
        df = nyquist / (obj%tf_cnt - 1)
        hdo(obj%hdr_freq,out_trcnum) = (out_trcnum - 1) * df
        hdo(obj%hdr_freq + 1,out_trcnum) = df
      else
        ! Zero frequency description for Attribute traces
        hdo(obj%hdr_freq,out_trcnum) = 0.0
        hdo(obj%hdr_freq + 1,out_trcnum) = 0.0
      end if
      if(obj%mode .eq.'T_F')then
        hdo(obj%hdr_att,out_trcnum)=0.0
      else
        if(out_trcnum.le.obj%tf_cnt)then
          hdo(obj%hdr_att,out_trcnum) = 0.0
        else
          hdo(obj%hdr_att,out_trcnum)=obj%rice_mode_idx(i)
          i=i+1
        endif
      endif
    else if(obj%mode == 'ATT') then
      hdo(obj%hdr_att,out_trcnum) = obj%rice_mode_idx(out_trcnum)
    end if
  end do

  call lav_set_hdr(hdo, tro, obj%ndpt, ntr)

  return
  end subroutine tfatt

!</execute_only>

!!------------------------------- wrapup -----------------------------------!!
!!------------------------------- wrapup -----------------------------------!!
!!------------------------------- wrapup -----------------------------------!!

!<execute_only>

  subroutine tfatt_wrapup (obj)
  implicit none
  type(tfatt_struct),intent(inout) :: obj       ! arguments

  if (obj%skip_wrapup) return
  obj%skip_wrapup = .true.

  return
  end subroutine tfatt_wrapup

!</execute_only>

!!----------------------------- end of module ------------------------------!!
!!----------------------------- end of module ------------------------------!!
!!----------------------------- end of module ------------------------------!!

  end module tfatt_module

!!--------------------------------- end ------------------------------------!!
!!--------------------------------- end ------------------------------------!!
!!--------------------------------- end ------------------------------------!!
