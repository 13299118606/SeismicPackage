!<CPS_v1 type="PROCESS"/>


!<license>
!-------------------------------------------------------------------------------
! Copyright (c) 2007 ConocoPhillips Company
!
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.
!-------------------------------------------------------------------------------
!</license>

!<brief_doc>
!-------------------------------------------------------------------------------
!                         C P S   P R O C E S S                  
!
! Name       : DMO3D         (3D DMO macro)
! Category   : migrations
! Written    : 1991-10-29   by: Mike Howard
! Revised    : 2006-06-20   by: B. Menger
! Maturity   : production
! Purpose    : Macro for performing DMO on 3D data.
! Portability: No known limitations.
! Parallel   : NO
!
!-------------------------------------------------------------------------------
!</brief_doc>

!<descript_doc>
!-------------------------------------------------------------------------------
!                          GENERAL DESCRIPTION                   
!
! DMO3D is a macro designed to perform 3D DMO on 3D datasets.  It can also be
! used as a general DMO process for special cases, including 2D datasets for 
! which CODMO is too restrictive.
! 
! DMO3D uses the DMO process KDMO, a Kirchhoff DMO with the Hale algorithm to
! prevent operator aliasing.  (Unlike previous versions, DMO3D now uses only 
! the Kirchhoff-Hale algorithm.)  DMO3D calls the RESTH, KDMO, GSTK, RESTH and 
! MUTE processes internally with the following parameters.
!
! (Parameter values indicated by "*" below are set identical to DMO3D input 
! parameter values.)
!
!        RESTH
!          HDR_INL = *,  INL_INIT = *,  INL_INC = *,  INL_WID = *,  INL_TOT = *
!          HDR_CRL = *,  CRL_INIT = *,  CRL_INC = *,  CRL_WID = *,  CRL_TOT = *
! 
!        KDMO
!          COORD = 3D, BIN_WID = computed , VEL_DMO = *, FREQ_MAX = *, 
!          OFF_MAX = *
!          
!        GSTK
!          NTIM=* , TVFSE= 0.0, OPT_MDT = *,
!
!          HDR_INL  = *,      HDR_CRL  = *,        HDR_OFF  = *, 
!          INL_INIT = *,      CRL_INIT = *,        OFF_INIT = *,
!          INL_INC  = *,      CRL_INC  = *,        OFF_INC  = *, 
!          INL_WID  = *,      CRL_WID  = *,        OFF_WID  = *, 
!          INL_LAST = *,      CRL_LAST = *,        OFF_LAST = *,
!          INL_TOT  = *,      CRL_TOT  = *,        OFF_TOT  = * 
!
!        RESTH
!          MODE = APPLY
!
!        MUTE
!          OPT_MUTE = REST_HEAD, LEN_TAPER = 0.0
!
!
! Missing or Dead Input Trace Option
!
! The OPT_MDT parameter allows the user to control processing of missing or 
! dead input traces.  Output traces corresponding to missing or dead input 
! traces are deleted (OPT_MDT = DEL), filled in (OPT_MDT = FILL) or killed 
! (OPT_MDT = KILL).  Traces affected by the FILL option will always have 
! their mute headers set to the first and last non-zero samples. FILL option
! will only output traces with non-zero samples.  However, KILL option  
! outputs all traces including dead and live traces. Users may need to fix
! up the headers of those traces generated by FILL or KILL option,  
! which have -1 in header word 32.  
!
!
! Muting Option
!
! If OPT_MUTE = YES, then the output trace mute header words are reset to the
! corresponding input trace values and the MUTE process is called to restore 
! the previous mute.
! If OPT_MUTE = NO, then the output trace mute header words are set to the 
! first and last non-zero samples.  The MUTE process is not called. 
!
!
! Offset Calculation Option
!
! If CALC_OFFSET = YES, the source and receiver surveyed coordinates are used
! to calculate the offset as follows. 
!
!       Offset      = SQRT( (HDR(11)-HDR(14))**2 +
!                           (HDR(12)-HDR(15))**2  )
!
! If CALC_OFFSET = NO, header word 6 is used for offset. 
!-------------------------------------------------------------------------------
!</descript_doc>

!<advice_doc>
!-------------------------------------------------------------------------------
!                            ADVICE FOR USERS                      
!
!
! *** WARNING ***
!
! DMO3D requires well sampled data for proper operation.  Poor sampling is 
! frequently caused by trace editing, wide range of azimuth, holes (missing 
! traces) in common offset panels and acquisition design.  Sampling problems 
! can produce amplitude imbalance, noise and other artifacts.  
!
! Poor sampling can be addressed in several ways.
!
!     1.  Use before stack migration.
!
!     2.  Use data reconstruction.
!
!     3.  Use DMOPREP to rotate the source - receiver azimuth to the inline
!     direction. 
!
!     4.  Use CODMO on 2D sail lines.
!
!
! Common Offset Operation
!
! In 3D common offset operation normally the input data is sorted by inline and
! crossline header words and has a restricted range of offset.  OFF_TOT should 
! be set to 1 and OFF_INIT should be set to the nominal offset of the dataset. 
! DMO3D will set the offset header word of the output data to the value of 
! OFF_INIT.
!
!
! Compositing Offsets Operation
!
! When using DMO3D to composite over offsets (DMO with stacked data output), 
! inline and crossline parameters should be set normally, but OFF_TOT should be
! set to 1 and OFF_INIT should normally be set to 0.0.  DMO3D will set the 
! offset header word of the output data to the value of OFF_INIT.
!
!
! 3D Velocity Analysis Operation
!
! When DMO3D is used to prepare a 3D dataset that will be used for semblance 
! velocity analysis only, the offset parameters should be set normally,  
! INL_INC and CRL_INC should be set based on the desired velocity analysis
! location spacing and INL_WID and CRL_WID should be set to the desired widths 
! of the velocity analysis bins.  (Normally in this case INL_WID and CRL_WID
! will be much smaller than INL_INC and CRL_INC.)
!
!
! Memory Allocation
!
! Generally NTIM should be set large enough so that disk swapping is minimized,
! but small enough to control cost and avoid restrictions on memory 
! availability.
!
! NTIM should be set to a minimum of the number of bins in a rectangular array 
! that might be populated by a DMO broadcast operator for the largest offset 
! within the job.  Larger values may increase efficiency, but at some point 
! limits on memory availability and memory cost will establish an upper limit 
! on NTIM.
!
!
! Source and Receiver Locations After DMO or Stack
!
! Even though GSTK calculates values for source and receiver surveyed 
! coordinate header words, source and receiver locations after DMO or stack are
! not well defined.
!
!
!-------------------------------------------------------------------------------
!</advice_doc>

!<trace_in_doc>
!-------------------------------------------------------------------------------
!                      TRACE INPUT REQUIREMENTS                
!
! Process is a single-trace process.
!
! No special requirements.
!
!-------------------------------------------------------------------------------
!</trace_in_doc>

!<trace_out_doc>
!-------------------------------------------------------------------------------
!                     TRACE OUTPUT CHARACTERISTICS             
!
! This process alters input traces.
!
! This process outputs one trace at a time.
!
! GSTK sets the offset header word (6) of output traces to the nominal value of
! their offset bin.
!
!-------------------------------------------------------------------------------
!</trace_out_doc>

!<global_doc>
!-------------------------------------------------------------------------------
!                    GLOBAL PARAMETERS USED OR CHANGED          
!
! 
! Name     Description                           Action taken
! ----     -----------                           ------------
! NDPT     number of sample values in trace      used but not changed
! TSTRT    starting time on trace                used but not changed
! DT       trace sample interval                 used but not changed
! GRID     grid transform                        used but not changed 
!
!-------------------------------------------------------------------------------
!</global_doc>

!<header_word_doc>
!-------------------------------------------------------------------------------
!                   TRACE HEADER WORDS USED OR CHANGED           
! 
! Hwd#    Description                Action taken
! ----    -----------                ------------
! 1       Sequential Trace Count     Renumbered.
! 2       Head mute                  Reset
! 3       Current gather number      Set
! 4       Number within gather       Set
! 5       Fold                       Set
! 6       Offset                     Used and set
! 7       CMP x grid                 Used
! 8       CMP y grid                 Used
! 11      Source easting             Set
! 12      Source northing            Set
! 14      Receiver easting           Set
! 15      Receiver northing          Set
! 17      Midpoint easting           Set
! 18      Midpoint northing          Set
! 64      Tail mute                  Reset
!
! If headers 7 and 8 are used to set up bins, 17 and 18 are calculated using 
! the grid transform global and headers 11, 12, 14 and 15 are calculated from 
! 17, 18 and 6.
! 
! See also underlying processes.
!-------------------------------------------------------------------------------
!</header_word_doc>

!<history_doc>
!-------------------------------------------------------------------------------
!                             REVISION HISTORY                    
! 
!     Date       Author     Description
!     ----       ------     -----------
!020. 2006-06-20  B. Menger   Removed Unused Variables.
! 19. 2002-03-07 CI Burch   Documentation change only
! 18. 2002-02-28 Chiu       Change output header word 1 to have sequential 
!                           increment.
! 17. 2002-02-21 Chiu       Fix frontend problem of CALC_OFFSET parameter.
! 16  2001-05-14 Chiu       Fix frontend problem in pattern_stop2
! 15. 2001-03-21 Chiu       Add pc_get_update_state() /= PC_GUI in checking
!                           parameters.
! 14. 2001-02-14 Chiu       Change wrapped_up to skip_wrapup.
! 13. 2000-08-23 Chiu       Use new coordinate for header 7 and 8.
! 12. 2000-06-23 Chiu       Conform with the review team's standard.
! 11. 2000-06-14 Chiu       Add Gui.
! 10. 2000-03-21 Chiu       Remove PC_BACKEND check for pc_put_contol.
! 9.  2000-01-27 Chiu       Convert into New CPS.
! 8.  1998-11-13 Vunderink  Begin using the f90 compiler.
! 7.  1998-04-28 Vunderink  Changed COKDMO to COKDMO3 and added Howard
!                           version of COKDMO.
! 6.  1998-04-28 Vunderink  Added KDMO algorithm.
! 5.  1997-02-11 Vunderink  Added bin width parameters and BIN4 option.
! 4.  1997-01-21 Vunderink  Added offset parameters
! 3.  1997-01-19 Vunderink  Documentation change only.
! 2.  1997-12-30 Vunderink  Added HB# and HL# parameters
! 1.  1991-10-29 Howard     Original Version
!    
!
!-------------------------------------------------------------------------------
!</history_doc>

!<portability_doc>
!-------------------------------------------------------------------------------
!                        PORTABILITY LIMITATIONS               
!
! No known limitations.
!
!
!-------------------------------------------------------------------------------
!</portability_doc>

!<compile_doc>
!-------------------------------------------------------------------------------
!                      SPECIAL COMPILING REQUIREMENTS             
!
! No special requirements.
!
! 
!-------------------------------------------------------------------------------
!</compile_doc>

!<calling_doc>
!-------------------------------------------------------------------------------
!                    SPECIFIC CALLING CHARACTERISTICS            
!
! This process uses a single set of trace and header arrays.
!
! Upon input, NTR must have one of these values:
!    NTR >= 1              means to process the input traces.
!    NTR == NO_MORE_TRACES means there are no more imput traces.
!
! Upon output, NTR will have one of these values:
!    NTR >= 1              if this process is outputting traces.
!    NTR == NO_MORE_TRACES if there are no more traces to output.
!    NTR == FATAL_ERROR    if this process has a fatal error.
!
!-------------------------------------------------------------------------------
!</calling_doc>

!<int_calling_doc>
!-------------------------------------------------------------------------------
!                    ALTERNATE INTERNAL CALLING METHODS          
!
!  None provided.
!
!-------------------------------------------------------------------------------
!</int_calling_doc>

!<algorithm_doc>
!-------------------------------------------------------------------------------
!                   ALGORITHM DESCRIPTION FOR DEVELOPERS         
!
!
!
!-------------------------------------------------------------------------------
!</algorithm_doc>

!<programming_doc>
!-------------------------------------------------------------------------------
!                            PROGRAMMING NOTES                 
!
!
! The design of the bandpass filter was changed. The KDMO output will not    
! match exactly as the output from the old CPS.
!
! NUM_OFF is changed to match the one from GSTK. This change may produce  
! a slightly different result when comparing with old CPS module. 
! 
! The DMO output from the new CPS may not match exactly as the old CPS 
! module, because the new DMO output location may be off one CMP bin when  
! comparing with old CPS module. 
! 
! As a result of all these changes, users expect to see a slight difference
! in background signal between the new and old DMO outputs. 
!
!
!-------------------------------------------------------------------------------
!</programming_doc>

!-------------------------------------------------------------------------------
!<--  XML code for the GUI goes in this section. />
!
!<gui_def>
!<NS DMO3D Process/NC=80>
!
!                      3D DMO macro Process
!               Macro for performing DMO on 3D data.
!
! OFF_MAX=`FFFFFFFFFFF    FREQ_MAX=`FFFFFFFFFFF    VEL_DMO=`FFFFFFFFFFF
!
! OPT_MDT=`CCCC   OPT_MUTE=`CCC    NTIM=`IIIIIIIIII    CALC_OFFSET=`CCC
!
!   `----------------------------------------------------------------------
!     HDR_INL= `IIIIIIIIII
!
!     INL_INIT=`FFFFFFFFFFF   INL_INC=`FFFFFFFFFFF   INL_WID=`FFFFFFFFFFF
!     INL_LAST=`FFFFFFFFFFF   INL_TOT=`IIIIIIIIII
!
!     HDR_CRL= `IIIIIIIIII
!
!     CRL_INIT=`FFFFFFFFFFF   CRL_INC=`FFFFFFFFFFF   CRL_WID=`FFFFFFFFFFF
!     CRL_LAST=`FFFFFFFFFFF   CRL_TOT=`IIIIIIIIII
!
!     HDR_OFF= `IIIIIIIIII
!
!     OFF_INIT=`FFFFFFFFFFF   OFF_INC=`FFFFFFFFFFF   OFF_WID=`FFFFFFFFFFF
!     OFF_LAST=`FFFFFFFFFFF   OFF_TOT=`IIIIIIIIII
!</gui_def>
!
!
!<HelpSection>
!
!<Help KEYWORD="OFF_MAX">
!<Tip> Maximum offset in dataset. </Tip>
! Default = 3000
! Allowed = real > 0.0 
!</Help>
!
!<Help KEYWORD="FREQ_MAX">
!<Tip> Maximum frequency to be preserved in data, in Hz. </Tip>
! Default = 90
! Allowed = real > 0.0
! FREQ_MAX is used in the DMO operator calculation as the highest frequency to 
! preserve in the data.  Larger values of FREQ_MAX require significantly more 
! run-time.
!</Help>
!
!<Help KEYWORD="VEL_DMO">
!<Tip> Minimum propagation velocity in medium. </Tip>
! Default = 1500
! Allowed = real > 0.0
! VEL_DMO is used to calculate the maximum dip to be preserved in the data.
!</Help>
!
!<Help KEYWORD="OPT_MDT">
!<Tip> Option for handling Missing or Dead input Traces. </Tip>
! Default = DEL
! Allowed = DEL   
! Allowed = FILL
! Allowed = KILL
! Output traces corresponding to missing or dead input traces are deleted 
! (OPT_MDT = DEL), filled in (OPT_MDT = FILL) or killed (OPT_MDT = KILL).
! Traces affected by the FILL option will always have their mute headers set to
! the first and last non-zero samples.
!</Help>
!
!<Help KEYWORD="OPT_MUTE">
!<Tip> Whether to restore the previous mute. </Tip>
! Default = YES
! Allowed = YES/NO   
! If OPT_MUTE = YES, then the output trace mute header words are reset to the
! corresponding input trace values and the MUTE process is called to restore 
! the previous mute.
! If OPT_MUTE = NO, then the output trace mute header words are set to the 
! first and last non-zero samples.  The MUTE process is not called. 
!</Help>
!
!<Help KEYWORD="NTIM">
!<Tip> Number of Traces In Memory for GSTK. </Tip>
! Default = 1
! Allowed = int > 0
! Generally NTIM should be set large enough so that disk swapping is minimized,
! but small enough to avoid restrictions on memory availability or cost.
!
! NTIM should be set to a minimum of the number of bins in a rectangular array 
! that might be populated by a DMO broadcast operator for the largest offset.  
! Larger values may increase efficiency, but at some point limits on memory 
! availability and memory cost will establish an upper limit on NTIM.
!</Help>
!
!<Help KEYWORD="CALC_OFFSET">
!<Tip> Re-calculate offsets for 3D data only. </Tip>
! Default = YES
! Allowed = YES
! Allowed = NO
! If CALC_OFFSET = YES, offsets are re-calculated as above.
! If CALC_OFFSET = NO, offsets are assigned from values of header word 6.
!</Help>
!
!<Help KEYWORD="HDR_INL">
!<Tip> Header word for inline coordinate. </Tip>
! Default = 7
! Allowed = 1 - NWIH
!</Help>
!
!<Help KEYWORD="INL_INIT">
!<Tip> Value of HDR_INL for center of first bin. </Tip>
! Default = 1.0
! Allowed = real
!</Help>
!
!<Help KEYWORD="INL_INC">
!<Tip> Increment between bins in inline direction. </Tip>
! Default = 1.0
! Allowed = real > 0.0
!</Help>
!
!<Help KEYWORD="INL_WID">
!<Tip> Width of bins in inline direction. </Tip>
! Default = INL_INC
! Allowed = INL_INC >= real > 0.0
!</Help>
!
!<Help KEYWORD="INL_LAST">
!<Tip> Value of HDR_INL for center of last bin. </Tip>
! Default = 1.0
! Allowed = real >= INL_INIT
!</Help>
!
!<Help KEYWORD="INL_TOT">
!<Tip> Total number of bins in inline direction. </Tip>
! Default = 1
! Allowed = int > 0
!</Help>
!
!<Help KEYWORD="HDR_CRL">
!<Tip> Header word for crossline coordinate. </Tip>
! Default = 8
! Allowed = 1 - NWIH
!</Help>
!
!<Help KEYWORD="CRL_INIT">
!<Tip> Value of HDR_CRL for center of first bin. </Tip>
! Default = 1.0
! Allowed = real
!</Help>
!
!<Help KEYWORD="CRL_INC">
!<Tip> Increment between bins in crossline direction. </Tip>
! Default = 1.0
! Allowed = real > 0.0
!</Help>
!
!<Help KEYWORD="CRL_WID">
!<Tip> Width of bins in crossline direction. </Tip>
! Default = CRL_INC
! Allowed = CRL_INC >= real > 0.0
!</Help>
!
!<Help KEYWORD="CRL_LAST">
!<Tip> Value of HDR_CRL for center of last bin. </Tip>
! Default = 1.0
! Allowed = real >= CRL_INIT
!</Help>
!
!<Help KEYWORD="CRL_TOT">
!<Tip> Total number of bins in crossline direction. </Tip>
! Default = 1
! Allowed = int > 0
!</Help>
!
!<Help KEYWORD="HDR_OFF">
!<Tip> Header word for offsets. </Tip>
! Default = 6
! Allowed = 1 - NWIH
!</Help>
!
!<Help KEYWORD="OFF_INIT">
!<Tip> Value of HDR_OFF for center of first offset bin. </Tip>
! Default = 1.0
! Allowed = real
!</Help>
!
!<Help KEYWORD="OFF_INC">
!<Tip> Increment between offset bins. </Tip>
! Default = 1.0
! Allowed = real > 0.0
!</Help>
!
!<Help KEYWORD="OFF_WID">
!<Tip> Width of offset bins. </Tip>
! Default = OFF_INC
! Allowed = OFF_INC >= real > 0.0
!</Help>
!
!<Help KEYWORD="OFF_LAST">
!<Tip> Value of HDR_OFF for center of last offset bin. </Tip>
! Default = 1.0
! Allowed = real >= OFF_INIT
!</Help>
!
!<Help KEYWORD="OFF_TOT">
!<Tip> Total number of offset bins. </Tip>
! Default = 1
! Allowed = int > 0
!</Help>
!
!</HelpSection>
!-------------------------------------------------------------------------------
!
!
! NOTES FOR CONVERSION PROGRAMMER
!
!  1. Check how best to handle XXX_TOT = 1 as a flag for "do not use this 
!     dimension" in binning.  Again proceed same as for GSTK.
!  2. Implement OPT_MDT and OPT_MUTE consistent with GSTK. It is possible this
!      may be done in the macro itself and not entirely within GSTK.  (Check 
!      on a NEWLIB option on muting on CODMO and DMO3D.)
!  3.  Check on how best to implement "BIN_4" option (currently BIN_4 is not
!      implemented in this version).
!
!!--------------------------- start of module ------------------------------!!
!!--------------------------- start of module ------------------------------!!
!!--------------------------- start of module ------------------------------!!


      module dmo3d_module
      use pc_module
      use named_constants_module
      use grid_module           ! grid transformation.
      use string_module
      use mutehw_module
      use resth_module          ! calling resth process internally.  
      use kdmo_module           ! calling kdmo process internally. 
      use gstk_module           ! calling gstk process internally. 
      use mute_module           ! calling mute process internally.           
      use pattern_module
      use lav_module

      implicit none
      private
      public :: dmo3d_create     ! uses the parameter cache.
      public :: dmo3d_initialize
      public :: dmo3d_update     ! uses the parameter cache.
      public :: dmo3d_delete
!<execute_only>
      public :: dmo3d            ! main execution (trace processing) routine.
      public :: dmo3d_wrapup
!</execute_only>


      integer,public,save ::  ncount

      character(len=100),public,save :: dmo3d_IDENT = &
       '$Id: dmo3d.f90,v 1.20 2006/06/20 13:11:50 Menger prod sps $'
!!
!!
!!---------------------- parameter structure -------------------------------!!
!!---------------------- parameter structure -------------------------------!!
!!---------------------- parameter structure -------------------------------!!

      type,public :: dmo3d_struct              
 
      private
      logical               :: skip_wrapup         ! wrapup flag.

      real                  :: off_max            ! process parameters
      real                  :: freq_max           ! process parameters 
      real                  :: vel_dmo            ! process parameters
      character (len=4)     :: opt_mdt            ! process parameters
      character (len=3)     :: opt_mute           ! process parameters 
      integer               :: ntim               ! process parameters. 
      character(len=3)      :: calc_offset        ! process parameters.
 
        integer             :: hdr_inL           ! process parameters. 
        real                :: inL_init          ! process parameters. 
        real                :: inL_inc           ! process parameters.
        real                :: inL_wid           ! process parameters. 
        real                :: inL_last          ! process parameters.
        integer             :: inL_tot           ! process parameters.

        integer             :: hdr_crl            ! process parameters.
        real                :: crl_init           ! process parameters.
        real                :: crl_inc            ! process parameters.
        real                :: crl_wid            ! process parameters. 
        real                :: crl_last           ! process parameters.
        integer             :: crl_tot            ! process parameters.

        integer             :: hdr_off            ! process parameters.
        real                :: off_init           ! process parameters.
        real                :: off_inc            ! process parameters.
        real                :: off_wid            ! process parameters.
        real                :: off_last           ! process parameters. 
        integer             :: off_tot            ! process parameters.
!
      integer               :: ndpt               ! Common globals
      integer               :: nwih               ! Common globals
      real                  :: dt                 ! Common globals
      real                  :: tstrt              ! Common globals 
      type(grid_struct)     :: grid               ! Common globals
!
      logical               :: done               ! dependent variables.
      integer               :: ifb                ! dependent variables.
      integer               :: nskip              ! dependent variables.
      integer               :: print_lun          ! dependent variables.
      integer               :: hd1_cnt            ! dependent variables.

      type(resth_struct),pointer    :: resth      ! dependent variables. 
      type(kdmo_struct), pointer    :: kdmo       ! dependent variables. 
      type(gstk_struct), pointer    :: gstk       ! dependent variables. 
      type(mute_struct), pointer    :: mute       ! dependent variables. 

      end type dmo3d_struct


!!--------------------------------- data -----------------------------------!!
!!--------------------------------- data -----------------------------------!!
!!--------------------------------- data -----------------------------------!!


      type(dmo3d_struct),pointer,save :: object      ! needed for traps.

      integer,parameter     :: opt_mdt_noptions = 3
      character(len=4),save :: opt_mdt_options(opt_mdt_noptions)
      data opt_mdt_options/'DEL','FILL', 'KILL'/

      integer,parameter     :: opt_mute_noptions = 2
      character(len=3),save :: opt_mute_options(opt_mute_noptions)
      data opt_mute_options/'YES','NO'/

      integer,parameter     :: calc_offset_noptions = 2
      character(len=3),save :: calc_offset_options(calc_offset_noptions)
      data calc_offset_options/'YES','NO'/

      contains


!!----------------------------- create -------------------------------------!!
!!----------------------------- create -------------------------------------!!
!!----------------------------- create -------------------------------------!!


      subroutine dmo3d_create (obj)
      implicit none
      type(dmo3d_struct),pointer :: obj       ! arguments

      allocate (obj)


!! Nullify ALL POINTERS in your parameter structure as follows:
!! These might be pointers to arrays or pointers to the data structures
!! of internally called processes.
!!  
      nullify  (obj%resth)  
      nullify  (obj%kdmo)  
      nullify  (obj%gstk)  
      nullify  (obj%mute)  

      call dmo3d_initialize (obj)

      return
      end subroutine dmo3d_create


!!------------------------------- delete -----------------------------------!!
!!------------------------------- delete -----------------------------------!!
!!------------------------------- delete -----------------------------------!!


      subroutine dmo3d_delete (obj)
      implicit none
      type(dmo3d_struct),pointer :: obj       ! arguments

!<execute_only>
      call dmo3d_wrapup (obj)
!</execute_only>

!! deallocate ALL POINTERS in parameter structure 


      if (associated(obj%resth))  call resth_delete (obj%resth)  
      if (associated(obj%kdmo))   call kdmo_delete  (obj%kdmo)  
      if (associated(obj%gstk))   call gstk_delete  (obj%gstk)  
      if (associated(obj%mute))   call mute_delete  (obj%mute) 

      deallocate(obj)

      return
      end subroutine dmo3d_delete


!!----------------------------- initialize ---------------------------------!!
!!----------------------------- initialize ---------------------------------!!
!!----------------------------- initialize ---------------------------------!!


      subroutine dmo3d_initialize (obj)
      implicit none
      type(dmo3d_struct),intent(inout) :: obj       ! arguments

!! Initialize ALL NON-POINTER VARIABLES in the parameter structure

      obj%off_max   = 1.
      obj%freq_max  = 90.
      obj%vel_dmo   = 1500.
      obj%opt_mdt   = 'DEL'           
      obj%opt_mute  = 'YES'
      obj%ntim      = 5000
      obj%calc_offset  = 'YES'

      obj%hdr_inL  = 7
      obj%inL_init = 1.
      obj%inL_inc  = 1.
      obj%inL_wid  = obj%inL_inc
      obj%inL_last = 1
      obj%inL_tot  = 1

      obj%hdr_crl   = 8 
      obj%crl_init  = 1.  
      obj%crl_inc   = 1.
      obj%crl_wid  = obj%crl_inc
      obj%crl_last  = 1
      obj%crl_tot   = 1
 
      obj%hdr_off   = 6 
      obj%off_init  = 1. 
      obj%off_inc   = 1.
      obj%off_wid   = obj%off_inc 
      obj%off_last  = 1
      obj%off_tot   = 1
  
      obj%print_lun = pc_get_lun()
      call grid_initialize(obj%grid)
      call dmo3d_update (obj)

      return
      end subroutine dmo3d_initialize


!!------------------------- start of update --------------------------------!!
!!------------------------- start of update --------------------------------!!
!!------------------------- start of update --------------------------------!!


      subroutine dmo3d_update (obj)
      implicit none
      type(dmo3d_struct),intent(inout),target :: obj           ! arguments




      logical                    :: gathered,iftd              ! local
      integer                    :: nstore, nscratch           ! local
      integer                    :: ntapes,ndisk               ! local
      integer                    :: istatus                    ! local
      integer                    :: numtr                      ! local
      character(len=3)           :: need_label,need_request    ! local
      character(len=3)           :: twosets                    ! local  
      character(len=3)           :: coord                      ! local


       integer                   :: napert,len_taper           ! local

       double precision          :: dx11,dx12,dx21,dx22        ! local
       real                      :: tim_beg,tim_end            ! local
       real                      :: tvfse, binsize             ! local
       real                      :: taper                      ! local
      integer                    :: state                      ! local
      logical                    :: verify                     ! local


      state = pc_get_update_state()

      if(state == PC_FRONTEND .or. state == PC_BACKEND) then
        verify = .true.
      else
        verify = .false.
      end if

      object => obj               ! needed for traps.
      obj%skip_wrapup = .true.    ! needed for the wrapup routine.

!!------------------------- read parameters --------------------------------!!
!!------------------------- read parameters --------------------------------!!
!!------------------------- read parameters --------------------------------!!

      call pc_get_global ('nwih', obj%nwih)  ! number of header words.
      call pc_get_global ('ndpt', obj%ndpt)  ! number of trace samples.
      call pc_get_global ('dt',   obj%dt)    ! trace sample interval (sec).
      call pc_get_global ('tstrt',obj%tstrt) ! time of 1st trace sample(sec).
      call pc_get_global ('grid', obj%grid)  ! grid transform data structure.
      call pc_get_global ('numtr'       , numtr)           
      call pc_get_global ('gathered'    , gathered) 

      if ( gathered .or. numtr > 1) then
         call pc_error                                                   &
         ('Invalid in DMO3D: Input data must not be gathered ')
      end if 
        
      call pc_get ('off_max',      obj%off_max)
      call pc_get ('freq_max',     obj%freq_max)
      call pc_get ('vel_dmo',      obj%vel_dmo)
      call pc_get ('opt_mdt',      obj%opt_mdt)           
      call pc_get ('opt_mute',     obj%opt_mute) 
      call pc_get ('ntim'      ,   obj%ntim) 
      call pc_get ('calc_offset'  , obj%calc_offset)

      call pc_get ('hdr_inL'  , obj%hdr_inL)
      call pc_get ('inL_init' , obj%inL_init) 
      call pc_get ('inL_inc'  , obj%inL_inc)
      call pc_get ('inL_wid'  , obj%inL_wid)   
      call pc_get ('inL_last' , obj%inL_last)  
      call pc_get ('inL_tot'  , obj%inL_tot) 
 
      call pc_get ('hdr_crl'   , obj%hdr_crl)
      call pc_get ('crl_init'  , obj%crl_init)   
      call pc_get ('crl_inc'   , obj%crl_inc) 
      call pc_get ('crl_wid'   , obj%crl_wid)   
      call pc_get ('crl_last'  , obj%crl_last)   
      call pc_get ('crl_tot'   , obj%crl_tot) 
  
      call pc_get ('hdr_off'   , obj%hdr_off)
      call pc_get ('off_init'  , obj%off_init)  
      call pc_get ('off_inc'   , obj%off_inc) 
      call pc_get ('off_wid'   , obj%off_wid)    
      call pc_get ('off_last'  , obj%off_last)  
      call pc_get ('off_tot'   , obj%off_tot)    
      call string_to_upper (obj%opt_mdt)
      call string_to_upper (obj%opt_mute)


!!-------------------------- verify parameters -----------------------------!!
!!-------------------------- verify parameters -----------------------------!!
!!-------------------------- verify parameters -----------------------------!!

       if(obj%off_max <= 0) then
         call pc_error                                                   &
         ('Invalid in DMO3D: OFF_MAX MUST BE > 0')
      end if

      if(obj%freq_max <= 0.0) then
         call pc_error                                                   &
         ('Invalid in DMO3D: FREQ_MAX MUST BE > 0')
      end if

      if(obj%freq_max > nint(0.5/obj%dt)) then
         obj%freq_max = (0.5/obj%dt)
         call pc_warning(' Reset FREQ_MAX in DMO3D to Nyquist frequency ', &
                           (0.5/obj%dt)  )
       end if

       if(obj%vel_dmo <=0.) then
         call pc_error('Invalid in DMO3D: VEL_DMO MUST BE > 0')
       end if

      if(obj%opt_mdt /='DEL' .and. obj%opt_mdt /='FILL'                   &
        .and. obj%opt_mdt /='KILL') then 
        call pc_error('Invalid in DMO3D: OPT_MDT must be DEL, FILL or KILL')  
      end if

      if(obj%opt_mute /='YES' .and. obj%opt_mute /='NO') then 
        call pc_error('Invalid in DMO3D: OPT_MUTE must be YES/NO')  
      end if

      if(obj%ntim <= 0) then 
        call pc_error('NTIM MUST BE > 0')  
      end if

      call string_to_upper (obj%calc_offset)
      if(obj%calc_offset /= 'YES'.and. obj%calc_offset /= 'NO') then
         call pc_error('Invalid in KDMO: CALC_OFFSET MUST BE YES OR NO')
      end if
 
      if(obj%hdr_inL < 1) then 
        call pc_error('HDR_INL MUST BE >=  1')  
      else if(obj%hdr_inL > obj%nwih) then 
        call pc_error('HDR_INL MUST BE =<  64 ')  
      end if

      if(obj%inL_inc <= 0) then 
        call pc_error('INL_INC MUST BE > 0')  
      end if

      if(obj%inL_wid <= 0.0) then 
        call pc_error('INL_WID MUST BE > 0')   
      end if

      if(obj%inL_tot <= 0) then 
        call pc_error('INL_TOT MUST BE > 0')  
      end if

      if(obj%hdr_crl < 1) then 
        call pc_error('HDR_CRL MUST BE >=  1')  
      else if(obj%hdr_crl > obj%nwih) then 
        call pc_error('HDR_CRL MUST BE =< 64 ')  
      end if

      if(obj%crl_inc <= 0) then 
        call pc_error('CRL_INC MUST BE > 0 ')  
      end if

      if(obj%crl_wid <= 0.0) then 
        call pc_error('CRL_WID MUST BE > 0')  
      end if

      if(obj%crl_tot <= 0) then 
        call pc_error('CRL_TOT MUST BE > 0')  
      end if

      if(obj%hdr_off < 1) then
        call pc_error('HDR_OFF MUST BE >=  1')  
      else if(obj%hdr_off > obj%nwih) then 
        call pc_error('HDR_OFF MUST BE =< 64 ')  
      end if

      if(obj%off_inc <= 0) then 
        call pc_error('OFF_INC MUST BE > 0')  
      end if

      if(obj%off_wid <= 0.0) then 
        call pc_error('OFF_WID MUST BE > 0 ')  
      end if

      if(obj%off_tot <= 0) then 
        call pc_error('OFF_TOT MUST BE > 0')  
      end if

       istatus = pattern_stop2('DMO3D:', verify, &
       obj%inL_init, obj%inL_inc, obj%inL_last, obj%inL_tot, &
       'INL_INIT', 'INL_INC', 'INL_LAST', 'INL_TOT', &
       pc_verify_scalar('INL_INIT'), pc_verify_scalar('INL_INC'), &
       pc_verify_scalar('INL_LAST'), pc_verify_scalar('INL_TOT')) 

       istatus = pattern_stop2('DMO3D:', verify, &
       obj%crl_init, obj%crl_inc, obj%crl_last, obj%crl_tot, &
       'CRL_INIT', 'CRL_INC', 'CRL_LAST', 'CRL_TOT', &
       pc_verify_scalar('CRL_INIT'), pc_verify_scalar('CRL_INC'), &
       pc_verify_scalar('CRL_LAST'), pc_verify_scalar('CRL_TOT')) 

       istatus = pattern_stop2('DMO3D:', verify, &
       obj%off_init, obj%off_inc, obj%off_last, obj%off_tot, &
       'OFF_INIT', 'OFF_INC', 'OFF_LAST', 'OFF_TOT', &
       pc_verify_scalar('OFF_INIT'), pc_verify_scalar('OFF_INC'), &
       pc_verify_scalar('OFF_LAST'), pc_verify_scalar('OFF_TOT')) 
                                ! end trap

!!------------------------- call processes internally ----------------------!!
!!------------------------- call processes internally ----------------------!!
!!------------------------- call processes internally ----------------------!!

     tim_beg = obj%tstrt 
     tim_end = (obj%ndpt - 1)*obj%dt 

     call grid_get_dx(obj%grid,dx11,dx12,dx21,dx22) 
     binsize = sqrt( abs(dx11*dx22 - dx12*dx21) )
     napert = 2*obj%off_max/binsize + 1

! resth

      call pc_clear
      call pc_put_process ('mode',      'CALC')
      call pc_put_process ('hdr_crl',   obj%hdr_crl)        
      call pc_put_process ('crl_tot',   obj%crl_tot)     
      call pc_put_process ('crl_init',  obj%crl_init)    
      call pc_put_process ('crl_inc',   obj%crl_inc) 
      call pc_put_process ('crl_wid',   obj%crl_wid)
      call pc_put_process ('crl_last',  obj%crl_last)
       
      call pc_put_process ('hdr_inL',  obj%hdr_inL)        
      call pc_put_process ('inL_tot',  obj%inL_tot)     
      call pc_put_process ('inL_init', obj%inL_init)    
      call pc_put_process ('inL_inc',  obj%inL_inc)
      call pc_put_process ('inL_wid',  obj%inL_wid)
      call pc_put_process ('inL_last', obj%inL_last)
      
  
      if (associated(obj%resth)) then
          call resth_update (obj%resth)
      else
           call resth_create (obj%resth)
      end if
      call pc_restore

! end resth


! kdmo
!     coord = 3d, bin_wid = *, vel_dmo = *, freq_max = *, off_max = off_max

      coord = '3D'
      call pc_clear
      call pc_put_process ('bin_wid',    binsize)
      call pc_put_process ('freq_max',   obj%freq_max)
      call pc_put_process ('coord',      coord)
      call pc_put_process ('off_max',    obj%off_max)
      call pc_put_process ('vel_dmo',    obj%vel_dmo)
      call pc_put_process ('calc_offset', obj%calc_offset)
      call pc_put_process ('hdr_crl',    obj%hdr_crl)
      call pc_put_process ('hdr_inL',    obj%hdr_inL)

      if (associated(obj%kdmo)) then
          call kdmo_update (obj%kdmo)
      else
          call kdmo_create (obj%kdmo)
      end if
      call pc_restore

!   end kdmo


!   gstk

      tvfse = 0.0

      call pc_clear

      call pc_put_process ('ntim',      obj%ntim) 
      call pc_put_process ('tvfse',     tvfse)
      call pc_put_process ('tim_beg',   tim_beg)
      call pc_put_process ('tim_end',   tim_end)
      call pc_put_process ('opt_mdt',   obj%opt_mdt)

      call pc_put_process ('hdr_inL',  obj%hdr_inL)
      call pc_put_process ('inL_init', obj%inL_init)  
      call pc_put_process ('inL_inc',  obj%inL_inc)
      call pc_put_process ('inL_wid' , obj%inL_wid)    
      call pc_put_process ('inL_tot',  obj%inL_tot)  
      call pc_put_process ('inL_last', obj%inL_last)

      call pc_put_process ('hdr_crl',   obj%hdr_crl)             
      call pc_put_process ('crl_init',  obj%crl_init)    
      call pc_put_process ('crl_inc',   obj%crl_inc)
      call pc_put_process ('crl_wid',   obj%crl_wid)        
      call pc_put_process ('crl_tot',   obj%crl_tot)
      call pc_put_process ('crl_last',  obj%crl_last) 
 
      call pc_put_process ('hdr_off',   obj%hdr_off)
      call pc_put_process ('off_init',  obj%off_init)  
      call pc_put_process ('off_inc',   obj%off_inc)
      call pc_put_process ('off_wid',   obj%off_wid)     
      call pc_put_process ('off_tot',   obj%off_tot)
      call pc_put_process ('off_last',  obj%off_last)

      if (associated(obj%gstk)) then
          call gstk_update (obj%gstk)
      else
           call gstk_create (obj%gstk)
      end if
      call pc_restore

!  end  gstk


! mute
!       opt_mute = rest_head, taper = 0.06 sec

      taper = 0.06
      len_taper = nint(0.06/obj%dt) - 1 

      call pc_clear
      call pc_put_process ('opt_mute',   'REST_HEAD')
      call pc_put_process ('len_taper',   taper)
        
      if (associated(obj%mute)) then
          call mute_update (obj%mute)
      else
           call mute_create (obj%mute)
      end if
      call pc_restore

! end mute

!
!!----------------------- write parameters ---------------------------------!!
!!----------------------- write parameters ---------------------------------!!
!!----------------------- write parameters ---------------------------------!!

      call pc_put_options_field ('opt_mdt', opt_mdt_options,   &
                                   opt_mdt_noptions)

      call pc_put_options_field ('opt_mute', opt_mute_options,   &
                                   opt_mute_noptions)

      call pc_put_options_field ('calc_offset', calc_offset_options,   &
                                   calc_offset_noptions)

      gathered = .false.

      call pc_put_global  ('numtr'       , napert)           ! if changed.
      call pc_put_global  ('gathered'    , gathered)         ! if changed.

      call pc_put ('off_max',      obj%off_max)
      call pc_put ('freq_max',     obj%freq_max)
      call pc_put ('vel_dmo',      obj%vel_dmo)
      call pc_put ('opt_mdt',      obj%opt_mdt)           
      call pc_put ('opt_mute',     obj%opt_mute) 
      call pc_put ('ntim',         obj%ntim) 
      call pc_put ('calc_offset',  obj%calc_offset)

      call pc_put ('hdr_inL'  , obj%hdr_inL)
      call pc_put ('inL_init' , obj%inL_init)
      call pc_put ('inL_inc'  , obj%inL_inc) 
      call pc_put ('inL_wid'  , obj%inL_wid)
      call pc_put ('inL_last' , obj%inL_last) 
      call pc_put ('inL_tot'  , obj%inL_tot)

      call pc_put ('hdr_crl'   , obj%hdr_crl)
      call pc_put ('crl_init'  , obj%crl_init) 
      call pc_put ('crl_inc'   , obj%crl_inc)
      call pc_put ('crl_wid'   , obj%crl_wid)
      call pc_put ('crl_last'  , obj%crl_last) 
      call pc_put ('crl_tot'   , obj%crl_tot)

      call pc_put ('hdr_off'   , obj%hdr_off)
      call pc_put ('off_init'  , obj%off_init)
      call pc_put ('off_inc'   , obj%off_inc)
      call pc_put ('off_wid'   , obj%off_wid)  
      call pc_put ('off_last'  , obj%off_last) 
      call pc_put ('off_tot'   , obj%off_tot)

!!----------------------- prepare for execution ----------------------------!!
!!----------------------- prepare for execution ----------------------------!!
!!----------------------- prepare for execution ----------------------------!!


        need_label   = 'YES'
        need_request = 'YES'
        twosets      = 'NO'
        iftd         = .false.
        ndisk        = 0
        ntapes       = 0 
 
        nstore =        1
        nscratch =      1                                ! scratch storage 

        call pc_put_control ('nstore',             nstore)
        call pc_put_control ('nscratch',         nscratch)
        call pc_put_control ('need_label',     need_label)
        call pc_put_control ('need_request', need_request)
        call pc_put_control ('twosets',           twosets)
 

!<execute_only>

      if (pc_do_not_process_traces()) return
      obj%skip_wrapup = .false.
 
      obj%nskip = 0
      obj%ifb = 1                      ! initialize to show entry from above  
      obj%done = .false.
      obj%hd1_cnt = 0
      
!   RESTH
      write (obj%print_lun, *) ' RESTH : ' 

      write (obj%print_lun, *) '  HDR_INL = ', obj%hdr_inL,                &
        '  INL_TOT = ', obj%inL_tot,'  INL_INIT = ',  obj%inL_init,      &  
        '  INL_INC = ', obj%inL_inc, '  INL_WID = ', obj%inL_wid 

      write (obj%print_lun, *) '  HDR_CRL = ', obj%hdr_crl,                  &
        '  CRL_TOT = ', obj%crl_tot,'  CRL_INIT = ',  obj%crl_init,          &  
        '  CRL_INC = ', obj%crl_inc, '  CRL_WID = ', obj%crl_wid

!   KDMO
     write (obj%print_lun, *) ' KDMO : '  
     write (obj%print_lun, *) '  COORD = ',coord, '  BIN_WID = ',            &
       binsize, '  VEL_DMO = ', obj%vel_dmo

     write (obj%print_lun, *) ' FREQ_MAX = ', obj%freq_max,                  &
       '  OFF_MAX = ', obj%off_max, ' CALC_OFFSET = ',obj%calc_offset
       
!   GSTK
     write (obj%print_lun, *) ' GSTK : '
     write (obj%print_lun, *) '  NTIM = ', obj%ntim, '  TVFSE =', tvfse,     &
     '  TIM_BEG = ', tim_beg,'  TIM_END =', tim_end
 
      write (obj%print_lun, *) '  HDR_INL = ', obj%hdr_inL,                &
        '  INL_TOT = ', obj%inL_tot,'  INL_INIT = ',  obj%inL_init,      &  
        '  INL_INC = ', obj%inL_inc,'  INL_WID = ', obj%inL_wid

      write (obj%print_lun, *) '  HDR_CRL = ', obj%hdr_crl,                  &
        '  CRL_TOT = ', obj%crl_tot,'  CRL_INIT = ',  obj%crl_init,          &  
        '  CRL_INC = ', obj%crl_inc, '  CRL_WID = ', obj%crl_wid

      write (obj%print_lun, *) '  OFF_CRL = ', obj%hdr_off,                  &
        '  OFF_TOT = ', obj%off_tot,'  OFF_INIT = ',  obj%off_init,          &  
        '  OFF_INC = ', obj%off_inc, '  OFF_WID = ', obj%off_wid

!   RESTH
      write (obj%print_lun, *) ' RESTH : '
      write (obj%print_lun, *) '  MODE = APPLY  '
!
!   MUTE
     write (obj%print_lun, *) ' MUTE : '
     write (obj%print_lun, *)'  OPT_MUTE =', obj%opt_mute,                   &
                         '  LEN_TAPER =',  len_taper

      if (pc_do_not_process_traces()) return

!</execute_only>

!!------------------------- finish update ----------------------------------!!
!!------------------------- finish update ----------------------------------!!
!!------------------------- finish update ----------------------------------!!


      return
      end subroutine dmo3d_update


!!------------------------------- traps ------------------------------------!!
!!------------------------------- traps ------------------------------------!!
!!------------------------------- traps ------------------------------------!!


!!--------------------------- main execution -------------------------------!!
!!--------------------------- main execution -------------------------------!!
!!--------------------------- main execution -------------------------------!!


!! Upon input, NTR will have one of these values:
!!   NTR >= 1              means to process the input traces.
!!   NTR == NO_MORE_TRACES means there are no more imput traces.
!!   NTR == NEED_TRACES    means someone from below needs more traces.
!!   NTR == NEED_TRACES    might mean this is a trace-supplying process.
!!   NTR == NEED_TRACES    will not occur unless this process has a label.
!!
!! Upon output, NTR must have one of these values:
!!   NTR >= 1              if you are outputting traces.
!!   NTR == NO_MORE_TRACES if there are no more traces to output.
!!   NTR == FATAL_ERROR    if you have a fatal error.
!!   NTR == NEED_TRACES    if you need another trace before passing any out.
!!   NTR == NEED_TRACES    must not occur unless you specified that you
!!                           might need to request more traces.
!!
!<execute_only>
 
      subroutine dmo3d (obj,ntr,hdi, tri)
      implicit none
      type(dmo3d_struct),intent(inout) :: obj                   ! arguments
      integer          ,intent(inout) :: ntr                    ! arguments
      double precision ,intent(inout) :: hdi(:,:)               ! arguments
      real             ,intent(inout) :: tri(:,:)               ! arguments

      real                            :: fmute,tmute            ! local
      

      if ( (ntr==NO_MORE_TRACES .and. obj%done)             &
       .or. ntr == FATAL_ERROR) then
         call dmo3d_wrapup (obj)
         return
      end if

      if (obj%ifb < 0) go to 300 

!    end if data flag: output from gstk 

        if (ntr==NO_MORE_TRACES) then 
          call kdmo (obj%kdmo, ntr, hdi, tri)     
          ntr = NEED_TRACES
          go to 300
        end if

!      if trace is dead, let's skip it  

      if (ntr==1 .and. hdi(25,ntr)<=0 ) then 
        obj%nskip = obj%nskip + 1
        ntr = NEED_TRACES 
        go to 500 
      end if 

      call resth (obj%resth, ntr, hdi, tri) 
      if (ntr == FATAL_ERROR) then
        call pc_error('FATAL_ERROR in routine RESTH in DMO3D ') 
        return
      end if 
 
      call kdmo (obj%kdmo, ntr, hdi, tri) 
      if (ntr == FATAL_ERROR) then
        call pc_error('FATAL_ERROR in routine KDMO in DMO3D ') 
        return
      end if
 
  300 continue 
      call gstk (obj%gstk, ntr, hdi, tri) 
      if (ntr == FATAL_ERROR) then
        call pc_error('FATAL_ERROR in routine GSTK in DMO3D ') 
        return
      end if

      if (ntr == NEED_TRACES) go to 500
      if (ntr == NO_MORE_TRACES) then
         obj%done = .true.
         go to 550
      end if 

      fmute = hdi(2,ntr)
      tmute = hdi(64,ntr)

      resth_mode = 'APPLY'
      call resth (obj%resth, ntr, hdi, tri) 
      if (ntr == FATAL_ERROR) then
        call pc_error('FATAL_ERROR in routine RESTH in DMO3D ') 
        return
      end if  

      if (hdi(32,ntr) <= 0.0 .and. obj%opt_mdt =='FILL') then
         hdi(2,ntr)  = fmute
         hdi(64,ntr) = tmute
      end if 

      if (obj%opt_mute=='YES') then
         call mute (obj%mute, ntr, hdi, tri) 
         if (ntr == FATAL_ERROR) then
           call pc_error('FATAL_ERROR in routine  MUTE in DMO3D ') 
           return
         end if
      end if

      obj%hd1_cnt = obj%hd1_cnt + 1
      hdi(1,ntr) = obj%hd1_cnt
      
      call lav_set_hdr (hdi, tri, obj%ndpt, ntr)    

!     exit down 
 550  continue
      obj%ifb = -1 
      return  
!     exit up 
  500 continue 
      obj%ifb = 1  
      return  

      end subroutine dmo3d

!</execute_only>

!!------------------------------- wrapup -----------------------------------!!
!!------------------------------- wrapup -----------------------------------!!
!!------------------------------- wrapup -----------------------------------!!


!<execute_only>

      subroutine dmo3d_wrapup (obj)
      implicit none
      type(dmo3d_struct),intent(inout) :: obj       ! arguments

      if (obj%skip_wrapup) return
      obj%skip_wrapup = .true.

!!
!!  --> Put any required wrapup code here.
!!

      if (associated(obj%resth))  call resth_wrapup (obj%resth)  
      if (associated(obj%kdmo))   call kdmo_wrapup  (obj%kdmo)  
      if (associated(obj%gstk))   call gstk_wrapup  (obj%gstk)  
      if (associated(obj%mute))   call mute_wrapup  (obj%mute) 

      return
      end subroutine dmo3d_wrapup

!</execute_only>


!!----------------------------- end of module ------------------------------!!
!!----------------------------- end of module ------------------------------!!
!!----------------------------- end of module ------------------------------!!


      end module dmo3d_module


!!--------------------------------- end ------------------------------------!!
!!--------------------------------- end ------------------------------------!!
!!--------------------------------- end ------------------------------------!!
