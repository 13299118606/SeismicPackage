
!<CPS_v1 type="PRIMITIVE"/>
!!------------------------------- csvd.f90 --------------------------------!!
!!------------------------------- csvd.f90 --------------------------------!!
!!------------------------------- csvd.f90 --------------------------------!!
!
!<license>
!-------------------------------------------------------------------------------
! Copyright (c) 2007 ConocoPhillips Company
!
! Permission is hereby granted, free of charge, to any person obtaining a copy
! of this software and associated documentation files (the "Software"), to deal
! in the Software without restriction, including without limitation the rights
! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
! copies of the Software, and to permit persons to whom the Software is
! furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in all
! copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
! SOFTWARE.
!-------------------------------------------------------------------------------
!</license>


!<brief_doc>
!-------------------------------------------------------------------------------
!                        C P S   P R I M I T I V E
!
! Name       : CSVD     (Complex Single Value Decomposition)
! Category   : math
! Written    : 2005-01-20   by: Stephen chiu
! Revised    : 2005-03-22   by: Stephen chiu
! Maturity   : production
! Purpose    : Single value decomposition of a complex matrix.
! Portability: No known limitations.
!
!-------------------------------------------------------------------------------
!</brief_doc>


!<descript_doc>
!-------------------------------------------------------------------------------
!                         GENERAL DESCRIPTION            
!
! Singular value decomposition of an M by N complex matrix, where M > N.
!                                                                       
!  CSVD computes the singular value decomposition (SVD) of a complex  
!  M-by-N matrix A, optionally computing the left and/or right singular 
!  vectors. The SVD is written                                          
!                                                                       
!       A = U * SIGMA * conjugate-transpose(V)                          
!                                                                       
!  where SIGMA is an M-by-N matrix which is zero except for its         
!  min(m,n) diagonal elements, U is an M-by-M unitary matrix, and       
!  V is an N-by-N unitary matrix.  The diagonal elements of SIGMA       
!  are the singular values of A; they are real and non-negative, and    
!  are returned in descending order.  The first min(m,n) columns of     
!  U and V are the left and right singular vectors of A.                
!                                                                       
!  Note that the routine returns V**H, not V.                           
!                                              
!     From LAPACK (version 3.0)                           
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University  
!     October 31, 1999 
!
!-------------------------------------------------------------------------------
!</descript_doc>


!<calling_doc>
!-------------------------------------------------------------------------------
!                      INPUT AND OUTPUT ARGUMENTS        
!
! For each subroutine or function documented below, each argument is
! flagged as follows:
!   i = intent(in)    = value required upon INPUT.
!   o = intent(out)   = value set by the routine upon OUTPUT.
!   b = intent(inout) = value BOTH required upon input and changed upon output.
!
! Optional arguments are also flagged as follows:
!   opt = this argument is optional.
!
!-------------------------------------------------------------------------------
!                          CALLING SEQUENCE               
!                                                          
!                           i     i    i  i  b   i   o  o   i   o    i
!    SUBROUTINE CSVD_CGE( JOBU, JOBVT, M, N, A, LDA, S, U, LDU, VT, LDVT,  &
!                         WORK, LWORK, RWORK, INFO )                     
!                          b      i      b     b
!
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  JOBU    (input) CHARACTER*1                                          
!          Specifies options for computing all or part of the matrix U: 
!          = 'A':  all M columns of U are returned in array U:          
!          = 'S':  the first min(m,n) columns of U (the left singular   
!                  vectors) are returned in the array U;                
!          = 'O':  the first min(m,n) columns of U (the left singular   
!                  vectors) are overwritten on the array A;             
!          = 'N':  no columns of U (no left singular vectors) are       
!                  computed.                                            
!                                                                       
!  JOBVT   (input) CHARACTER*1                                          
!          Specifies options for computing all or part of the matrix    
!          V**H:                                                        
!          = 'A':  all N rows of V**H are returned in the array VT;     
!          = 'S':  the first min(m,n) rows of V**H (the right singular  
!                  vectors) are returned in the array VT;               
!          = 'O':  the first min(m,n) rows of V**H (the right singular  
!                  vectors) are overwritten on the array A;             
!          = 'N':  no rows of V**H (no right singular vectors) are      
!                  computed.                                            
!                                                                       
!          JOBVT and JOBU cannot both be 'O'.                           
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the input matrix A.  M &gt;= 0.        
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the input matrix A.  N &gt;= 0.     
!                                                                       
!  A       (input/output) COMPLEX array, dimension (LDA,N)              
!          On entry, the M-by-N matrix A.                               
!          On exit,                                                     
!          if JOBU = 'O',  A is overwritten with the first min(m,n)     
!                          columns of U (the left singular vectors,     
!                          stored columnwise);                          
!          if JOBVT = 'O', A is overwritten with the first min(m,n)     
!                          rows of V**H (the right singular vectors,    
!                          stored rowwise);                             
!          if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A       
!                          are destroyed.                               
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA &gt;= max(1,M).   
!                                                                       
!  S       (output) REAL array, dimension (min(M,N))                    
!          The singular values of A, sorted so that S(i) &gt;= S(i+1).  
!                                                                       
!  U       (output) COMPLEX array, dimension (LDU,UCOL)                 
!          (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.       
!          If JOBU = 'A', U contains the M-by-M unitary matrix U;       
!          if JOBU = 'S', U contains the first min(m,n) columns of U    
!          (the left singular vectors, stored columnwise);              
!          if JOBU = 'N' or 'O', U is not referenced.                   
!                                                                       
!  LDU     (input) INTEGER                                              
!          The leading dimension of the array U.  LDU &gt;= 1; if       
!          JOBU = 'S' or 'A', LDU &gt;= M.                              
!                                                                       
!  VT      (output) COMPLEX array, dimension (LDVT,N)                   
!          If JOBVT = 'A', VT contains the N-by-N unitary matrix        
!          V**H;                                                        
!          if JOBVT = 'S', VT contains the first min(m,n) rows of       
!          V**H (the right singular vectors, stored rowwise);           
!          if JOBVT = 'N' or 'O', VT is not referenced.                 
!                                                                       
!  LDVT    (input) INTEGER                                              
!          The leading dimension of the array VT.  LDVT &gt;= 1; if     
!          JOBVT = 'A', LDVT &gt;= N; if JOBVT = 'S', LDVT &gt;= min(M,N
!                                                                       
!  WORK    (workspace/output) COMPLEX array, dimension (LWORK)          
!          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.     
!                                                                       
!  LWORK   (input) INTEGER                                              
!          The dimension of the array WORK. LWORK &gt;= 1.              
!          LWORK &gt;=  2*MIN(M,N)+MAX(M,N).                            
!          For good performance, LWORK should generally be larger.      
!                                                                       
!          If LWORK = -1, then a workspace query is assumed; the routine
!          only calculates the optimal size of the WORK array, returns  
!          this value as the first entry of the WORK array, and no error
!          message related to LWORK is issued by CSVD_XERBLA.                
!                                                                       
!  RWORK   (workspace) REAL array, dimension (5*min(M,N))               
!          On exit, if INFO &gt; 0, RWORK(1:MIN(M,N)-1) contains the    
!          unconverged superdiagonal elements of an upper bidiagonal    
!          matrix B whose diagonal is in S (not necessarily sorted).    
!          B satisfies A = U * B * VT, so it has the same singular      
!          values as A, and singular vectors related by U and VT.       
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0:  successful exit.                                       
!          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
!          &gt; 0:  if CSVD_CBDSQR did not converge, INFO specifies how many 
!                superdiagonals of an intermediate bidiagonal form B    
!                did not converge to zero. See the description of RWORK 
!                above for details.                                     
!                                                                       
!-------------------------------------------------------------------------------
!</calling_doc>


!<advice_doc>
!-------------------------------------------------------------------------------
!                            ADVICE FOR USERS             
!
!
!-------------------------------------------------------------------------------
!</advice_doc>


!<history_doc>
!-------------------------------------------------------------------------------
!                             REVISION HISTORY              
!
!     Date        Author     Description
!     ----        ------     -----------
!  1. 2005-03-22  S. chiu    Initial version
!
!-------------------------------------------------------------------------------
!</history_doc>


!<portability_doc>
!-------------------------------------------------------------------------------
!                         PORTABILITY LIMITATIONS         
!
! No known limitations.
!
!-------------------------------------------------------------------------------
!</portability_doc>


!!-------------------------- start of module ------------------------------!!
!!-------------------------- start of module ------------------------------!!
!!-------------------------- start of module ------------------------------!!


        module csvd_module
        implicit none

        ! subroutine
        public :: CSVD_CGE
        public :: CSVD_SVBKSB 
        public :: CSVD_CBDSQR 
        public :: CSVD_CGEBD2
        public :: CSVD_CGEBRD
        public :: CSVD_CGELQ2
        public :: CSVD_CGELQF
        public :: CSVD_CGEQR2 
        public :: CSVD_CGEQRF
        public :: CSVD_CLABRD
        public :: CSVD_CLACGV
        public :: CSVD_CLACPY
        public :: CSVD_CLARFB
        public :: CSVD_CLARFG
        public :: CSVD_CLARFT
        public :: CSVD_CLASCL 
        public :: CSVD_CLASET
        public :: CSVD_CLASR
        public :: CSVD_CLASSQ
        public :: CSVD_CSROT
        public :: CSVD_CUNG2R
        public :: CSVD_CUNGBR
        public :: CSVD_CUNGL2
        public :: CSVD_CUNGLQ
        public :: CSVD_CUNGQR
        public :: CSVD_CUNM2R
        public :: CSVD_CUNMBR
        public :: CSVD_CUNML2
        public :: CSVD_CUNMQR
        public :: CSVD_SLADIV
        public :: CSVD_SLARTG
        public :: CSVD_SLAS2
        public :: CSVD_SLASCL
        public :: CSVD_SLASQ2
        public :: CSVD_SLASQ3
        public :: CSVD_SLASQ4
        public :: CSVD_SLASQ5
        public :: CSVD_SLASQ6
        public :: CSVD_SLASRT
        public :: CSVD_SLASV2
        public :: CSVD_SLAMC1 
        public :: CSVD_SLAMC2 
        public :: CSVD_SLAMC4
        public :: CSVD_XERBLA 
        public :: CSVD_scopy
        public :: CSVD_ccopy
        public :: CSVD_csscal
        public :: CSVD_cscal
        public :: CSVD_CGEMV
        public :: CSVD_CGEMM
        public :: CSVD_CTRMM

        ! function

        public :: CSVD_ILAENV 
        public :: CSVD_LSAME
        public :: CSVD_SLAMCH
        public :: CSVD_CLANGE
        public :: CSVD_SCNRM2
        public :: CSVD_SLAPY3
        public :: CSVD_CLADIV
        public :: CSVD_IEEECK     
        public :: CSVD_SLAMC3

        character(len=100),public,save :: CSVD_IDENT = &
  '$Id: csvd.f90,v 1.1 2005/03/22 13:56:18 chiu prod sps $'

        contains


!!----------------------------- csvd --------------------------------------!!
!!----------------------------- csvd --------------------------------------!!
!!----------------------------- csvd --------------------------------------!!


      SUBROUTINE CSVD_CGE( JOBU, JOBVT, M, N, A, LDA, S, U, LDU, VT, LDVT,  &
                         WORK, LWORK, RWORK, INFO )                     
                                                          
!     .. Scalar Arguments ..                                            
      CHARACTER          JOBU, JOBVT                                    
      INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N              
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               RWORK( * ), S( * )                             
      COMPLEX            A( LDA, * ), U( LDU, * ), VT( LDVT, * ),         &
                         WORK( * )                                              
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  JOBU    (input) CHARACTER*1                                          
!          Specifies options for computing all or part of the matrix U: 
!          = 'A':  all M columns of U are returned in array U:          
!          = 'S':  the first min(m,n) columns of U (the left singular   
!                  vectors) are returned in the array U;                
!          = 'O':  the first min(m,n) columns of U (the left singular   
!                  vectors) are overwritten on the array A;             
!          = 'N':  no columns of U (no left singular vectors) are       
!                  computed.                                            
!                                                                       
!  JOBVT   (input) CHARACTER*1                                          
!          Specifies options for computing all or part of the matrix    
!          V**H:                                                        
!          = 'A':  all N rows of V**H are returned in the array VT;     
!          = 'S':  the first min(m,n) rows of V**H (the right singular  
!                  vectors) are returned in the array VT;               
!          = 'O':  the first min(m,n) rows of V**H (the right singular  
!                  vectors) are overwritten on the array A;             
!          = 'N':  no rows of V**H (no right singular vectors) are      
!                  computed.                                            
!                                                                       
!          JOBVT and JOBU cannot both be 'O'.                           
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the input matrix A.  M &gt;= 0.        
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the input matrix A.  N &gt;= 0.     
!                                                                       
!  A       (input/output) COMPLEX array, dimension (LDA,N)              
!          On entry, the M-by-N matrix A.                               
!          On exit,                                                     
!          if JOBU = 'O',  A is overwritten with the first min(m,n)     
!                          columns of U (the left singular vectors,     
!                          stored columnwise);                          
!          if JOBVT = 'O', A is overwritten with the first min(m,n)     
!                          rows of V**H (the right singular vectors,    
!                          stored rowwise);                             
!          if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A       
!                          are destroyed.                               
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA &gt;= max(1,M).   
!                                                                       
!  S       (output) REAL array, dimension (min(M,N))                    
!          The singular values of A, sorted so that S(i) &gt;= S(i+1).  
!                                                                       
!  U       (output) COMPLEX array, dimension (LDU,UCOL)                 
!          (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.       
!          If JOBU = 'A', U contains the M-by-M unitary matrix U;       
!          if JOBU = 'S', U contains the first min(m,n) columns of U    
!          (the left singular vectors, stored columnwise);              
!          if JOBU = 'N' or 'O', U is not referenced.                   
!                                                                       
!  LDU     (input) INTEGER                                              
!          The leading dimension of the array U.  LDU &gt;= 1; if       
!          JOBU = 'S' or 'A', LDU &gt;= M.                              
!                                                                       
!  VT      (output) COMPLEX array, dimension (LDVT,N)                   
!          If JOBVT = 'A', VT contains the N-by-N unitary matrix        
!          V**H;                                                        
!          if JOBVT = 'S', VT contains the first min(m,n) rows of       
!          V**H (the right singular vectors, stored rowwise);           
!          if JOBVT = 'N' or 'O', VT is not referenced.                 
!                                                                       
!  LDVT    (input) INTEGER                                              
!          The leading dimension of the array VT.  LDVT &gt;= 1; if     
!          JOBVT = 'A', LDVT &gt;= N; if JOBVT = 'S', LDVT &gt;= min(M,N
!                                                                       
!  WORK    (workspace/output) COMPLEX array, dimension (LWORK)          
!          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.     
!                                                                       
!  LWORK   (input) INTEGER                                              
!          The dimension of the array WORK. LWORK &gt;= 1.              
!          LWORK &gt;=  2*MIN(M,N)+MAX(M,N).                            
!          For good performance, LWORK should generally be larger.      
!                                                                       
!          If LWORK = -1, then a workspace query is assumed; the routine
!          only calculates the optimal size of the WORK array, returns  
!          this value as the first entry of the WORK array, and no error
!          message related to LWORK is issued by CSVD_XERBLA.                
!                                                                       
!  RWORK   (workspace) REAL array, dimension (5*min(M,N))               
!          On exit, if INFO &gt; 0, RWORK(1:MIN(M,N)-1) contains the    
!          unconverged superdiagonal elements of an upper bidiagonal    
!          matrix B whose diagonal is in S (not necessarily sorted).    
!          B satisfies A = U * B * VT, so it has the same singular      
!          values as A, and singular vectors related by U and VT.       
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0:  successful exit.                                       
!          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
!          &gt; 0:  if CSVD_CBDSQR did not converge, INFO specifies how many 
!                superdiagonals of an intermediate bidiagonal form B    
!                did not converge to zero. See the description of RWORK 
!                above for details.                                     
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      COMPLEX            CZERO, CONE                                    

      REAL               ZERO, ONE                                      
      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0 )                  
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            LQUERY, WNTUA, WNTUAS, WNTUN, WNTUO, WNTUS,      &
                         WNTVA, WNTVAS, WNTVN, WNTVO, WNTVS             
      INTEGER            BLK, CHUNK, I, IE, IERR, IR, IRWORK, ISCL,       &
                         ITAU, ITAUP, ITAUQ, IU, IWORK, LDWRKR, LDWRKU,   &
                         MAXWRK, MINMN, MINWRK, MNTHR, NCU, NCVT, NRU,    &
                         NRVT, WRKBL                                    
      REAL               ANRM, BIGNUM, EPS, SMLNUM                      
!     ..                                                                
!     .. Local Arrays ..                                                
      REAL               DUM( 1 )                                       
      COMPLEX            CDUM( 1 )                                      
!     ..                                                                
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_CBDSQR, CSVD_CGEBRD, CSVD_CGELQF,    &
!                         CSVD_CGEMM, CSVD_CGEQRF, CSVD_CLACPY,     & 
!                         CSVD_CLASCL, CSVD_CLASET, CSVD_CUNGBR,    & 
!                         CSVD_CUNGLQ, CSVD_CUNGQR, CSVD_CUNMBR,    &   
!                         CSVD_SLASCL, CSVD_XERBLA
!     ..                                                                
!     .. External Functions ..                                          
!      LOGICAL            csvd_lsame                                          
!      INTEGER            csvd_ilaenv                                         
!      REAL               csvd_clange, csvd_slamch 
!      EXTERNAL           csvd_lsame, csvd_ilaenv, csvd_clange, csvd_slamch
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN, SQRT                                 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       

      CZERO = CMPLX( 0.0E0, 0.0E0 ) 
      CONE = CMPLX( 1.0E0, 0.0E0 )  

      INFO = 0                                                          
      MINMN = MIN( M, N )                                               
      MNTHR = csvd_ilaenv( 6, 'CSVD', JOBU // JOBVT, M, N, 0, 0 )          
      WNTUA = csvd_lsame( JOBU, 'A' )                                        
      WNTUS = csvd_lsame( JOBU, 'S' )                                        
      WNTUAS = WNTUA .OR. WNTUS                                         
      WNTUO = csvd_lsame( JOBU, 'O' )                                        
      WNTUN = csvd_lsame( JOBU, 'N' )                                        
      WNTVA = csvd_lsame( JOBVT, 'A' )                                       
      WNTVS = csvd_lsame( JOBVT, 'S' )                                       
      WNTVAS = WNTVA .OR. WNTVS                                         
      WNTVO = csvd_lsame( JOBVT, 'O' )                                       
      WNTVN = csvd_lsame( JOBVT, 'N' )                                       
      MINWRK = 1                                                        
      LQUERY = ( LWORK.EQ.-1 )                                          
!                                                                       
      IF( .NOT.( WNTUA .OR. WNTUS .OR. WNTUO .OR. WNTUN ) ) THEN        
         INFO = -1                                                      
      ELSE IF( .NOT.( WNTVA .OR. WNTVS .OR. WNTVO .OR. WNTVN ) .OR.       &
               ( WNTVO .AND. WNTUO ) ) THEN                             
         INFO = -2                                                      
      ELSE IF( M.LT.0 ) THEN                                            
         INFO = -3                                                      
      ELSE IF( N.LT.0 ) THEN                                            
         INFO = -4                                                      
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN                                
         INFO = -6                                                      
      ELSE IF( LDU.LT.1 .OR. ( WNTUAS .AND. LDU.LT.M ) ) THEN           
         INFO = -9                                                      
      ELSE IF( LDVT.LT.1 .OR. ( WNTVA .AND. LDVT.LT.N ) .OR.              &
               ( WNTVS .AND. LDVT.LT.MINMN ) ) THEN                     
         INFO = -11                                                     
      END IF                                                            
!                                                                       
!     Compute workspace                                                 
!      (Note: Comments in the code beginning "Workspace:" describe the  
!       minimal amount of workspace needed at that point in the code,   
!       as well as the preferred amount for good performance.           
!       CWorkspace refers to complex workspace, and RWorkspace to       
!       real workspace. NB refers to the optimal block size for the     
!       immediately following subroutine, as returned by csvd_ilaenv.)       
!                                                                       
      IF( INFO.EQ.0 .AND. ( LWORK.GE.1 .OR. LQUERY ) .AND. M.GT.0 .AND.   &
         N.GT.0 ) THEN                                                  
         IF( M.GE.N ) THEN                                              
!                                                                       
!           Space needed for CSVD_CBDSQR is BDSPAC = 5*N                     
!                                                                       
            IF( M.GE.MNTHR ) THEN                                       
               IF( WNTUN ) THEN                                         
!                                                                       
!                 Path 1 (M much larger than N, JOBU='N')               
!                                                                       
                  MAXWRK = N + N*csvd_ilaenv( 1, 'CSVD_CGEQRF', ' ', M, N, -1, &
                           -1 )                                         
                  MAXWRK = MAX( MAXWRK, 2*N+2*N*                          &
                           csvd_ilaenv( 1, 'CSVD_CGEBRD', ' ', N, N, -1, -1 ) )
                  IF( WNTVO .OR. WNTVAS )                                 &
                     MAXWRK = MAX( MAXWRK, 2*N+( N-1 )*                   &
                              csvd_ilaenv( 1, 'CSVD_CUNGBR', 'P', N, N, N, -1 ))
                  MINWRK = 3*N                                          
                  MAXWRK = MAX( MINWRK, MAXWRK )                        
               ELSE IF( WNTUO .AND. WNTVN ) THEN                        
!                                                                       
!                 Path 2 (M much larger than N, JOBU='O', JOBVT='N')    
!                                                                       
                  WRKBL = N + N*csvd_ilaenv( 1, 'CSVD_CGEQRF', ' ', M, N, -1,-1)
                  WRKBL = MAX( WRKBL, N+N*csvd_ilaenv( 1, 'CSVD_CUNGQR', ' ', &
                           M, N, N, -1 ) )                                  
                  WRKBL = MAX( WRKBL, 2*N+2*N*                            &
                          csvd_ilaenv( 1, 'CSVD_CGEBRD', ' ', N, N, -1, -1 ))
                  WRKBL = MAX( WRKBL, 2*N+N*                              &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'Q', N, N, N, -1 ) )
                  MAXWRK = MAX( N*N+WRKBL, N*N+M*N )                    
                  MINWRK = 2*N + M                                      
                  MAXWRK = MAX( MINWRK, MAXWRK )                        
               ELSE IF( WNTUO .AND. WNTVAS ) THEN                       
!                                                                       
!                 Path 3 (M much larger than N, JOBU='O', JOBVT='S' or  
!                 'A')                                                  
!                                                                       
                  WRKBL = N + N*csvd_ilaenv(1, 'CSVD_CGEQRF', ' ', M, N, -1,-1)
                  WRKBL = MAX( WRKBL, N+N*csvd_ilaenv( 1, 'CSVD_CUNGQR', ' ',  &
                          M, N, N, -1 ) )                                  
                  WRKBL = MAX( WRKBL, 2*N+2*N*                            &
                          csvd_ilaenv( 1, 'CSVD_CGEBRD', ' ', N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+N*                              &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'Q', N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+( N-1 )*                        &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'P', N, N, N, -1 ) )
                  MAXWRK = MAX( N*N+WRKBL, N*N+M*N )                    
                  MINWRK = 2*N + M                                      
                  MAXWRK = MAX( MINWRK, MAXWRK )                        
               ELSE IF( WNTUS .AND. WNTVN ) THEN                        
!                                                                       
!                 Path 4 (M much larger than N, JOBU='S', JOBVT='N')    
!                                                                       
                  WRKBL = N + N*csvd_ilaenv( 1, 'CSVD_CGEQRF', ' ', M, N, -1,-1)
                  WRKBL = MAX( WRKBL, N+N*csvd_ilaenv( 1, 'CSVD_CUNGQR', ' ', &
                           M, N, N, -1 ) )                                  
                  WRKBL = MAX( WRKBL, 2*N+2*N*                            &
                          csvd_ilaenv( 1, 'CSVD_CGEBRD', ' ', N, N, -1, -1 ))
                  WRKBL = MAX( WRKBL, 2*N+N*                              &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'Q', N, N, N, -1 ) )
                  MAXWRK = N*N + WRKBL                                  
                  MINWRK = 2*N + M                                      
                  MAXWRK = MAX( MINWRK, MAXWRK )                        
               ELSE IF( WNTUS .AND. WNTVO ) THEN                        
!                                                                       
!                 Path 5 (M much larger than N, JOBU='S', JOBVT='O')    
!                                                                       
                  WRKBL = N + N*csvd_ilaenv( 1, 'CSVD_CGEQRF', ' ', M, N, -1,-1)
                  WRKBL = MAX( WRKBL, N+N*csvd_ilaenv( 1, 'CSVD_CUNGQR', ' ',  &
                          M, N, N, -1 ) )                                  
                  WRKBL = MAX( WRKBL, 2*N+2*N*                            &
                          csvd_ilaenv( 1, 'CSVD_CGEBRD', ' ', N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+N*                              &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'Q', N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+( N-1 )*                        &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'P', N, N, N, -1 ) )
                  MAXWRK = 2*N*N + WRKBL                                
                  MINWRK = 2*N + M                                      
                  MAXWRK = MAX( MINWRK, MAXWRK )                        
               ELSE IF( WNTUS .AND. WNTVAS ) THEN                       
!                                                                       
!                 Path 6 (M much larger than N, JOBU='S', JOBVT='S' or  
!                 'A')                                                  
!                                                                       
                  WRKBL = N + N*csvd_ilaenv( 1, 'CSVD_CGEQRF', ' ', M, N, -1,-1)
                  WRKBL = MAX( WRKBL, N+N*csvd_ilaenv( 1, 'CSVD_CUNGQR', ' ',  &
                          M, N, N, -1 ) )                                  
                  WRKBL = MAX( WRKBL, 2*N+2*N*                            &
                          csvd_ilaenv( 1, 'CSVD_CGEBRD', ' ', N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+N*                              &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'Q', N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+( N-1 )*                        &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'P', N, N, N, -1 ) )
                  MAXWRK = N*N + WRKBL                                  
                  MINWRK = 2*N + M                                      
                  MAXWRK = MAX( MINWRK, MAXWRK )                        
               ELSE IF( WNTUA .AND. WNTVN ) THEN                        
!                                                                       
!                 Path 7 (M much larger than N, JOBU='A', JOBVT='N')    
!                                                                       
                  WRKBL = N + N*csvd_ilaenv( 1, 'CSVD_CGEQRF', ' ', M, N, -1,-1)
                  WRKBL = MAX( WRKBL, N+M*csvd_ilaenv( 1, 'CSVD_CUNGQR', ' ',M,&
                          M, N, -1 ) )                                  
                  WRKBL = MAX( WRKBL, 2*N+2*N*                            &
                          csvd_ilaenv( 1, 'CSVD_CGEBRD', ' ', N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+N*                              &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'Q', N, N, N, -1 ) )
                  MAXWRK = N*N + WRKBL                                  
                  MINWRK = 2*N + M                                      
                  MAXWRK = MAX( MINWRK, MAXWRK )                        
               ELSE IF( WNTUA .AND. WNTVO ) THEN                        
!                                                                       
!                 Path 8 (M much larger than N, JOBU='A', JOBVT='O')    
!                                                                       
                  WRKBL = N + N*csvd_ilaenv( 1, 'CSVD_CGEQRF', ' ', M, N, -1,-1)
                  WRKBL = MAX( WRKBL, N+M*csvd_ilaenv( 1, 'CSVD_CUNGQR', ' ',M,&
                          M, N, -1 ) )                                  
                  WRKBL = MAX( WRKBL, 2*N+2*N*                            &
                          csvd_ilaenv( 1, 'CSVD_CGEBRD', ' ', N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+N*                              &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'Q', N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+( N-1 )*                        &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'P', N, N, N, -1 ) )
                  MAXWRK = 2*N*N + WRKBL                                
                  MINWRK = 2*N + M                                      
                  MAXWRK = MAX( MINWRK, MAXWRK )                        
               ELSE IF( WNTUA .AND. WNTVAS ) THEN                       
!                                                                       
!                 Path 9 (M much larger than N, JOBU='A', JOBVT='S' or  
!                 'A')                                                  
!                                                                       
                  WRKBL = N + N*csvd_ilaenv( 1, 'CSVD_CGEQRF', ' ', M, N, -1,-1)
                  WRKBL = MAX( WRKBL, N+M*csvd_ilaenv( 1, 'CSVD_CUNGQR', ' ',M,&
                          M, N, -1 ) )                                  
                  WRKBL = MAX( WRKBL, 2*N+2*N*                            &
                          csvd_ilaenv( 1, 'CSVD_CGEBRD', ' ', N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+N*                              &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'Q', N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+( N-1 )*                        &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'P', N, N, N, -1 ) )
                  MAXWRK = N*N + WRKBL                                  
                  MINWRK = 2*N + M                                      
                  MAXWRK = MAX( MINWRK, MAXWRK )                        
               END IF                                                   
            ELSE                                                        
!                                                                       
!              Path 10 (M at least N, but not much larger)              
!                                                                       
               MAXWRK = 2*N + ( M+N )*csvd_ilaenv( 1, 'CSVD_CGEBRD', ' ', &
                         M, N, -1, -1 )                                        
               IF( WNTUS .OR. WNTUO )                                     &
                  MAXWRK = MAX( MAXWRK, 2*N+N*                            &
                           csvd_ilaenv( 1, 'CSVD_CUNGBR', 'Q', M, N, N, -1 ) )
               IF( WNTUA )                                                &
                  MAXWRK = MAX( MAXWRK, 2*N+M*                            &
                           csvd_ilaenv( 1, 'CSVD_CUNGBR', 'Q', M, M, N, -1 ) )
               IF( .NOT.WNTVN )                                           &
                  MAXWRK = MAX( MAXWRK, 2*N+( N-1 )*                      &
                           csvd_ilaenv( 1, 'CSVD_CUNGBR', 'P', N, N, N, -1 ) )
               MINWRK = 2*N + M                                         
               MAXWRK = MAX( MINWRK, MAXWRK )                           
            END IF                                                      
         ELSE                                                           
!                                                                       
!           Space needed for CSVD_CBDSQR is BDSPAC = 5*M                     
!                                                                       
            IF( N.GE.MNTHR ) THEN                                       
               IF( WNTVN ) THEN                                         
!                                                                       
!                 Path 1t(N much larger than M, JOBVT='N')              
!                                                                       
                  MAXWRK = M + M*csvd_ilaenv( 1, 'CSVD_CGELQF', ' ', M, N,-1,&
                           -1 )                                         
                  MAXWRK = MAX( MAXWRK, 2*M+2*M*                          &
                           csvd_ilaenv( 1, 'CSVD_CGEBRD', ' ', M, M, -1, -1 ) )
                  IF( WNTUO .OR. WNTUAS )                                 &
                     MAXWRK = MAX( MAXWRK, 2*M+M*                         &
                              csvd_ilaenv( 1, 'CSVD_CUNGBR', 'Q', M, M, M, -1) )
                  MINWRK = 3*M                                          
                  MAXWRK = MAX( MINWRK, MAXWRK )                        
               ELSE IF( WNTVO .AND. WNTUN ) THEN                        
!                                                                       
!                 Path 2t(N much larger than M, JOBU='N', JOBVT='O')    
!                                                                       
                  WRKBL = M + M*csvd_ilaenv( 1, 'CSVD_CGELQF', ' ', M, N, -1,-1)
                  WRKBL = MAX( WRKBL, M+M*csvd_ilaenv( 1, 'CSVD_CUNGLQ', ' ',M,&
                          N, M, -1 ) )                                  
                  WRKBL = MAX( WRKBL, 2*M+2*M*                            &
                          csvd_ilaenv( 1, 'CSVD_CGEBRD', ' ', M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+( M-1 )*                        &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'P', M, M, M, -1 ) )
                  MAXWRK = MAX( M*M+WRKBL, M*M+M*N )                    
                  MINWRK = 2*M + N                                      
                  MAXWRK = MAX( MINWRK, MAXWRK )                        
               ELSE IF( WNTVO .AND. WNTUAS ) THEN                       
!                                                                       
!                 Path 3t(N much larger than M, JOBU='S' or 'A',        
!                 JOBVT='O')                                            
!                                                                       
                  WRKBL = M + M*csvd_ilaenv( 1, 'CSVD_CGELQF', ' ', M, N, -1,-1)
                  WRKBL = MAX( WRKBL, M+M*csvd_ilaenv( 1, 'CSVD_CUNGLQ', ' ',M,&
                          N, M, -1 ) )                                  
                  WRKBL = MAX( WRKBL, 2*M+2*M*                            &
                          csvd_ilaenv( 1, 'CSVD_CGEBRD', ' ', M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+( M-1 )*                        &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'P', M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+M*                              &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'Q', M, M, M, -1 ) )
                  MAXWRK = MAX( M*M+WRKBL, M*M+M*N )                    
                  MINWRK = 2*M + N                                      
                  MAXWRK = MAX( MINWRK, MAXWRK )                        
               ELSE IF( WNTVS .AND. WNTUN ) THEN                        
!                                                                       
!                 Path 4t(N much larger than M, JOBU='N', JOBVT='S')    
!                                                                       
                  WRKBL = M + M*csvd_ilaenv( 1, 'CSVD_CGELQF', ' ', M, N, -1,-1)
                  WRKBL = MAX( WRKBL, M+M*csvd_ilaenv( 1, 'CSVD_CUNGLQ', ' ',M,&
                          N, M, -1 ) )                                  
                  WRKBL = MAX( WRKBL, 2*M+2*M*                            &
                          csvd_ilaenv( 1, 'CSVD_CGEBRD', ' ', M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+( M-1 )*                        &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'P', M, M, M, -1 ) )
                  MAXWRK = M*M + WRKBL                                  
                  MINWRK = 2*M + N                                      
                  MAXWRK = MAX( MINWRK, MAXWRK )                        
               ELSE IF( WNTVS .AND. WNTUO ) THEN                        
!                                                                       
!                 Path 5t(N much larger than M, JOBU='O', JOBVT='S')    
!                                                                       
                  WRKBL = M + M*csvd_ilaenv( 1, 'CSVD_CGELQF', ' ', M, N, -1,-1)
                  WRKBL = MAX( WRKBL, M+M*csvd_ilaenv( 1, 'CSVD_CUNGLQ', ' ',M,&
                          N, M, -1 ) )                                  
                  WRKBL = MAX( WRKBL, 2*M+2*M*                            &
                          csvd_ilaenv( 1, 'CSVD_CGEBRD', ' ', M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+( M-1 )*                        &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'P', M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+M*                              &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'Q', M, M, M, -1 ) )
                  MAXWRK = 2*M*M + WRKBL                                
                  MINWRK = 2*M + N                                      
                  MAXWRK = MAX( MINWRK, MAXWRK )                        
               ELSE IF( WNTVS .AND. WNTUAS ) THEN                       
!                                                                       
!                 Path 6t(N much larger than M, JOBU='S' or 'A',        
!                 JOBVT='S')                                            
!                                                                       
                  WRKBL = M + M*csvd_ilaenv( 1, 'CSVD_CGELQF', ' ', M, N, -1,-1)
                  WRKBL = MAX( WRKBL, M+M*csvd_ilaenv( 1, 'CSVD_CUNGLQ', ' ',M,&
                          N, M, -1 ) )                                  
                  WRKBL = MAX( WRKBL, 2*M+2*M*                            &
                          csvd_ilaenv( 1, 'CSVD_CGEBRD', ' ', M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+( M-1 )*                        &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'P', M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+M*                              &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'Q', M, M, M, -1 ) )
                  MAXWRK = M*M + WRKBL                                  
                  MINWRK = 2*M + N                                      
                  MAXWRK = MAX( MINWRK, MAXWRK )                        
               ELSE IF( WNTVA .AND. WNTUN ) THEN                        
!                                                                       
!                 Path 7t(N much larger than M, JOBU='N', JOBVT='A')    
!                                                                       
                  WRKBL = M + M*csvd_ilaenv( 1, 'CSVD_CGELQF', ' ', M, N, -1,-1)
                  WRKBL = MAX( WRKBL, M+N*csvd_ilaenv( 1, 'CSVD_CUNGLQ', ' ',N,&
                          N, M, -1 ) )                                  
                  WRKBL = MAX( WRKBL, 2*M+2*M*                            &
                          csvd_ilaenv( 1, 'CSVD_CGEBRD', ' ', M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+( M-1 )*                        &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'P', M, M, M, -1 ) )
                  MAXWRK = M*M + WRKBL                                  
                  MINWRK = 2*M + N                                      
                  MAXWRK = MAX( MINWRK, MAXWRK )                        
               ELSE IF( WNTVA .AND. WNTUO ) THEN                        
!                                                                       
!                 Path 8t(N much larger than M, JOBU='O', JOBVT='A')    
!                                                                       
                  WRKBL = M + M*csvd_ilaenv( 1, 'CSVD_CGELQF', ' ', M, N, -1,-1)
                  WRKBL = MAX( WRKBL, M+N*csvd_ilaenv( 1, 'CSVD_CUNGLQ', ' ',N,&
                          N, M, -1 ) )                                  
                  WRKBL = MAX( WRKBL, 2*M+2*M*                            &
                          csvd_ilaenv( 1, 'CSVD_CGEBRD', ' ', M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+( M-1 )*                        &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'P', M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+M*                              &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'Q', M, M, M, -1 ) )
                  MAXWRK = 2*M*M + WRKBL                                
                  MINWRK = 2*M + N                                      
                  MAXWRK = MAX( MINWRK, MAXWRK )                        
               ELSE IF( WNTVA .AND. WNTUAS ) THEN                       
!                                                                       
!                 Path 9t(N much larger than M, JOBU='S' or 'A',        
!                 JOBVT='A')                                            
!                                                                       
                  WRKBL = M + M*csvd_ilaenv( 1, 'CSVD_CGELQF', ' ', M, N, -1,-1)
                  WRKBL = MAX( WRKBL, M+N*csvd_ilaenv( 1, 'CSVD_CUNGLQ', ' ',N,&
                          N, M, -1 ) )                                  
                  WRKBL = MAX( WRKBL, 2*M+2*M*                            &
                          csvd_ilaenv( 1, 'CSVD_CGEBRD', ' ', M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+( M-1 )*                        &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'P', M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+M*                              &
                          csvd_ilaenv( 1, 'CSVD_CUNGBR', 'Q', M, M, M, -1 ) )
                  MAXWRK = M*M + WRKBL                                  
                  MINWRK = 2*M + N                                      
                  MAXWRK = MAX( MINWRK, MAXWRK )                        
               END IF                                                   
            ELSE                                                        
!                                                                       
!              Path 10t(N greater than M, but not much larger)          
!                                                                       
               MAXWRK = 2*M + ( M+N )*csvd_ilaenv( 1, 'CSVD_CGEBRD', ' ',M,N,&
                        -1, -1 )                                        
               IF( WNTVS .OR. WNTVO )                                     &
                  MAXWRK = MAX( MAXWRK, 2*M+M*                            &
                           csvd_ilaenv( 1, 'CSVD_CUNGBR', 'P', M, N, M, -1 ) )
               IF( WNTVA )                                                &
                  MAXWRK = MAX( MAXWRK, 2*M+N*                            &
                           csvd_ilaenv( 1, 'CSVD_CUNGBR', 'P', N, N, M, -1 ) )
               IF( .NOT.WNTUN )                                           &
                  MAXWRK = MAX( MAXWRK, 2*M+( M-1 )*                      &
                           csvd_ilaenv( 1, 'CSVD_CUNGBR', 'Q', M, M, M, -1 ) )
               MINWRK = 2*M + N                                         
               MAXWRK = MAX( MINWRK, MAXWRK )                           
            END IF                                                      
         END IF                                                         
         WORK( 1 ) = MAXWRK                                             
      END IF                                                            
!                                                                       
      IF( LWORK.LT.MINWRK .AND. .NOT.LQUERY ) THEN                      
         INFO = -13                                                     
      END IF                                                            
      IF( INFO.NE.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_CGESVD', -INFO )
         RETURN                                                         
      ELSE IF( LQUERY ) THEN                                            
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( M.EQ.0 .OR. N.EQ.0 ) THEN                                     
         IF( LWORK.GE.1 )                                                 &
            WORK( 1 ) = ONE                                             
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Get machine constants                                             
!                                                                       
      EPS = csvd_slamch( 'P' )                                               
      SMLNUM = SQRT( csvd_slamch( 'S' ) ) / EPS                              
      BIGNUM = ONE / SMLNUM                                             
!                                                                       
!     Scale A if max element outside range [SMLNUM,BIGNUM]              
!                                                                       
      ANRM = csvd_clange( 'M', M, N, A, LDA, DUM )                           
      ISCL = 0                                                          
      IF( ANRM.GT.ZERO .AND. ANRM.LT.SMLNUM ) THEN                      
         ISCL = 1                                                       
         CALL CSVD_CLASCL( 'G', 0, 0, ANRM, SMLNUM, M, N, A, LDA, IERR )     
      ELSE IF( ANRM.GT.BIGNUM ) THEN                                    
         ISCL = 1                                                       
         CALL CSVD_CLASCL( 'G', 0, 0, ANRM, BIGNUM, M, N, A, LDA, IERR )     
      END IF                                                            
!                                                                       
      IF( M.GE.N ) THEN                                                 
!                                                                       
!        A has at least as many rows as columns. If A has sufficiently  
!        more rows than columns, first reduce using the QR              
!        decomposition (if sufficient workspace available)              
!                                                                       
         IF( M.GE.MNTHR ) THEN                                          
!                                                                       
            IF( WNTUN ) THEN                                            
!                                                                       
!              Path 1 (M much larger than N, JOBU='N')                  
!              No left singular vectors to be computed                  
!                                                                       
               ITAU = 1                                                 
               IWORK = ITAU + N                                         
!                                                                       
!              Compute A=Q*R                                            
!              (CWorkspace: need 2*N, prefer N+N*NB)                    
!              (RWorkspace: need 0)                                     
!                                                                       
               CALL CSVD_CGEQRF( M, N, A, LDA, WORK( ITAU ), WORK( IWORK ), & 
                            LWORK-IWORK+1, IERR )                       
!                                                                       
!              Zero out below R                                         
!                                                                       
               CALL CSVD_CLASET( 'L', N-1, N-1, CZERO, CZERO, A( 2, 1 ),    &
                            LDA )                                       
               IE = 1                                                   
               ITAUQ = 1                                                
               ITAUP = ITAUQ + N                                        
               IWORK = ITAUP + N                                        
!                                                                       
!              Bidiagonalize R in A                                     
!              (CWorkspace: need 3*N, prefer 2*N+2*N*NB)                
!              (RWorkspace: need N)                                     
!                                                                       
               CALL CSVD_CGEBRD( N, N, A, LDA, S, RWORK( IE ), WORK( ITAUQ ),&
                            WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,  &
                            IERR )                                      
               NCVT = 0                                                 
               IF( WNTVO .OR. WNTVAS ) THEN                             
!                                                                       
!                 If right singular vectors desired, generate P'.       
!                 (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)         
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CUNGBR( 'P', N, N, N, A, LDA, WORK( ITAUP ), &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
                  NCVT = N                                              
               END IF                                                   
               IRWORK = IE + N                                          
!                                                                       
!              Perform bidiagonal QR iteration, computing right         
!              singular vectors of A in A if desired                    
!              (CWorkspace: 0)                                          
!              (RWorkspace: need BDSPAC)                                
!                                                                       
               CALL CSVD_CBDSQR( 'U', N, NCVT, 0, 0, S, RWORK( IE ), A, LDA, &
                            CDUM, 1, CDUM, 1, RWORK( IRWORK ), INFO )   
!                                                                       
!              If right singular vectors desired in VT, copy them there 
!                                                                       
               IF( WNTVAS )                                               &
                  CALL CSVD_CLACPY( 'F', N, N, A, LDA, VT, LDVT )
!                                                                       
            ELSE IF( WNTUO .AND. WNTVN ) THEN                           
!                                                                       
!              Path 2 (M much larger than N, JOBU='O', JOBVT='N')       
!              N left singular vectors to be overwritten on A and       
!              no right singular vectors to be computed                 
!                                                                       
               IF( LWORK.GE.N*N+3*N ) THEN                              
!                                                                       
!                 Sufficient workspace for a fast algorithm             
!                                                                       
                  IR = 1                                                
                  IF( LWORK.GE.MAX( WRKBL, LDA*N )+LDA*N ) THEN         
!                                                                       
!                    WORK(IU) is LDA by N, WORK(IR) is LDA by N         
!                                                                       
                     LDWRKU = LDA                                       
                     LDWRKR = LDA                                       
                  ELSE IF( LWORK.GE.MAX( WRKBL, LDA*N )+N*N ) THEN      
!                                                                       
!                    WORK(IU) is LDA by N, WORK(IR) is N by N           
!                                                                       
                     LDWRKU = LDA                                       
                     LDWRKR = N                                         
                  ELSE                                                  
!                                                                       
!                    WORK(IU) is LDWRKU by N, WORK(IR) is N by N        
!                                                                       
                     LDWRKU = ( LWORK-N*N ) / N                         
                     LDWRKR = N                                         
                  END IF                                                
                  ITAU = IR + LDWRKR*N                                  
                  IWORK = ITAU + N                                      
!                                                                       
!                 Compute A=Q*R                                         
!                 (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)         
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CGEQRF( M, N, A, LDA, WORK( ITAU ),        &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
!                                                                       
!                 Copy R to WORK(IR) and zero out below it              
!                                                                       
                  CALL CSVD_CLACPY( 'U', N, N, A, LDA, WORK( IR ), LDWRKR )  
                  CALL CSVD_CLASET( 'L', N-1, N-1, CZERO, CZERO,           &
                               WORK( IR+1 ), LDWRKR )                   
!                                                                       
!                 Generate Q in A                                       
!                 (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)         
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CUNGQR( M, N, N, A, LDA, WORK( ITAU ),         &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
                  IE = 1                                                
                  ITAUQ = ITAU                                          
                  ITAUP = ITAUQ + N                                     
                  IWORK = ITAUP + N                                     
!                                                                       
!                 Bidiagonalize R in WORK(IR)                           
!                 (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)     
!                 (RWorkspace: need N)                                  
!                                                                       
                  CALL CSVD_CGEBRD( N, N, WORK( IR ), LDWRKR, S, RWORK( IE ),&
                               WORK( ITAUQ ), WORK( ITAUP ),              &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
!                                                                       
!                 Generate left vectors bidiagonalizing R               
!                 (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)       
!                 (RWorkspace: need 0)                                  
!                                                                       
                  CALL CSVD_CUNGBR( 'Q', N, N, N, WORK( IR ), LDWRKR,       &
                               WORK( ITAUQ ), WORK( IWORK ),              &
                               LWORK-IWORK+1, IERR )                    
                  IRWORK = IE + N                                       
!                                                                       
!                 Perform bidiagonal QR iteration, computing left       
!                 singular vectors of R in WORK(IR)                     
!                 (CWorkspace: need N*N)                                
!                 (RWorkspace: need BDSPAC)                             
!                                                                       
                  CALL CSVD_CBDSQR( 'U', N, 0, N, 0, S, RWORK( IE ), CDUM, 1, &
                               WORK( IR ), LDWRKR, CDUM, 1,               &
                               RWORK( IRWORK ), INFO )                  
                  IU = ITAUQ                                            
!                                                                       
!                 Multiply Q in A by left singular vectors of R in      
!                 WORK(IR), storing result in WORK(IU) and copying to A 
!                 (CWorkspace: need N*N+N, prefer N*N+M*N)              
!                 (RWorkspace: 0)                                       
!                                                                       
                  DO 10 I = 1, M, LDWRKU                                
                     CHUNK = MIN( M-I+1, LDWRKU )                       
                     CALL CSVD_CGEMM( 'N', 'N', CHUNK, N, N, CONE, A( I, 1 ), &
                                 LDA, WORK( IR ), LDWRKR, CZERO,          &
                                 WORK( IU ), LDWRKU )                   
                     CALL CSVD_CLACPY( 'F', CHUNK, N, WORK( IU ), LDWRKU,     &
                                  A( I, 1 ), LDA )                      
   10             CONTINUE                                              
!                                                                       
               ELSE                                                     
!                                                                       
!                 Insufficient workspace for a fast algorithm           
!                                                                       
                  IE = 1                                                
                  ITAUQ = 1                                             
                  ITAUP = ITAUQ + N                                     
                  IWORK = ITAUP + N                                     
!                                                                       
!                 Bidiagonalize A                                       
!                 (CWorkspace: need 2*N+M, prefer 2*N+(M+N)*NB)         
!                 (RWorkspace: N)                                       
!                                                                       
                  CALL CSVD_CGEBRD( M, N, A, LDA, S, RWORK( IE ),            & 
                               WORK( ITAUQ ), WORK( ITAUP ),                 &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
!                                                                       
!                 Generate left vectors bidiagonalizing A               
!                 (CWorkspace: need 3*N, prefer 2*N+N*NB)               
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CUNGBR( 'Q', M, N, N, A, LDA, WORK( ITAUQ ),     &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
                  IRWORK = IE + N                                       
!                                                                       
!                 Perform bidiagonal QR iteration, computing left       
!                 singular vectors of A in A                            
!                 (CWorkspace: need 0)                                  
!                 (RWorkspace: need BDSPAC)                             
!                                                                       
                  CALL CSVD_CBDSQR( 'U', N, 0, M, 0, S, RWORK( IE ), CDUM, 1, &
                               A, LDA, CDUM, 1, RWORK( IRWORK ), INFO ) 
!                                                                       
               END IF                                                   
!                                                                       
            ELSE IF( WNTUO .AND. WNTVAS ) THEN                          
!                                                                       
!              Path 3 (M much larger than N, JOBU='O', JOBVT='S' or 'A')
!              N left singular vectors to be overwritten on A and       
!              N right singular vectors to be computed in VT            
!                                                                       
               IF( LWORK.GE.N*N+3*N ) THEN                              
!                                                                       
!                 Sufficient workspace for a fast algorithm             
!                                                                       
                  IR = 1                                                
                  IF( LWORK.GE.MAX( WRKBL, LDA*N )+LDA*N ) THEN         
!                                                                       
!                    WORK(IU) is LDA by N and WORK(IR) is LDA by N      
!                                                                       
                     LDWRKU = LDA                                       
                     LDWRKR = LDA                                       
                  ELSE IF( LWORK.GE.MAX( WRKBL, LDA*N )+N*N ) THEN      
!                                                                       
!                    WORK(IU) is LDA by N and WORK(IR) is N by N        
!                                                                       
                     LDWRKU = LDA                                       
                     LDWRKR = N                                         
                  ELSE                                                  
!                                                                       
!                    WORK(IU) is LDWRKU by N and WORK(IR) is N by N     
!                                                                       
                     LDWRKU = ( LWORK-N*N ) / N                         
                     LDWRKR = N                                         
                  END IF                                                
                  ITAU = IR + LDWRKR*N                                  
                  IWORK = ITAU + N                                      
!                                                                       
!                 Compute A=Q*R                                         
!                 (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)         
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CGEQRF( M, N, A, LDA, WORK( ITAU ),              &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
!                                                                       
!                 Copy R to VT, zeroing out below it                    
!                                                                       
                  CALL CSVD_CLACPY( 'U', N, N, A, LDA, VT, LDVT )            
                  CALL CSVD_CLASET( 'L', N-1, N-1, CZERO, CZERO, VT( 2, 1 ), &
                               LDVT )                                   
!                                                                       
!                 Generate Q in A                                       
!                 (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)         
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CUNGQR( M, N, N, A, LDA, WORK( ITAU ),           &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
                  IE = 1                                                
                  ITAUQ = ITAU                                          
                  ITAUP = ITAUQ + N                                     
                  IWORK = ITAUP + N                                     
!                                                                       
!                 Bidiagonalize R in VT, copying result to WORK(IR)     
!                 (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)     
!                 (RWorkspace: need N)                                  
!                                                                       
                  CALL CSVD_CGEBRD( N, N, VT, LDVT, S, RWORK( IE ),          &
                               WORK( ITAUQ ), WORK( ITAUP ),              &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
                  CALL CSVD_CLACPY( 'L', N, N, VT, LDVT, WORK( IR ), LDWRKR )
!                                                                       
!                 Generate left vectors bidiagonalizing R in WORK(IR)   
!                 (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)       
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CUNGBR( 'Q', N, N, N, WORK( IR ), LDWRKR,        &
                               WORK( ITAUQ ), WORK( IWORK ),              &
                               LWORK-IWORK+1, IERR )                    
!                                                                       
!                 Generate right vectors bidiagonalizing R in VT        
!                 (CWorkspace: need N*N+3*N-1, prefer N*N+2*N+(N-1)*NB) 
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CUNGBR( 'P', N, N, N, VT, LDVT, WORK( ITAUP ),   &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
                  IRWORK = IE + N                                       
!                                                                       
!                 Perform bidiagonal QR iteration, computing left       
!                 singular vectors of R in WORK(IR) and computing right 
!                 singular vectors of R in VT                           
!                 (CWorkspace: need N*N)                                
!                 (RWorkspace: need BDSPAC)                             
!                                                                       
                  CALL CSVD_CBDSQR( 'U', N, N, N, 0, S, RWORK( IE ), VT,     &
                               LDVT, WORK( IR ), LDWRKR, CDUM, 1,         &
                               RWORK( IRWORK ), INFO )                  
                  IU = ITAUQ                                            
!                                                                       
!                 Multiply Q in A by left singular vectors of R in      
!                 WORK(IR), storing result in WORK(IU) and copying to A 
!                 (CWorkspace: need N*N+N, prefer N*N+M*N)              
!                 (RWorkspace: 0)                                       
!                                                                       
                  DO 20 I = 1, M, LDWRKU                                
                     CHUNK = MIN( M-I+1, LDWRKU )                       
                     CALL CSVD_CGEMM( 'N', 'N', CHUNK, N, N, CONE, A( I, 1 ), &
                                 LDA, WORK( IR ), LDWRKR, CZERO,          &
                                 WORK( IU ), LDWRKU )                   
                     CALL CSVD_CLACPY( 'F', CHUNK, N, WORK( IU ), LDWRKU,    &
                                  A( I, 1 ), LDA )                      
   20             CONTINUE                                              
!                                                                       
               ELSE                                                     
!                                                                       
!                 Insufficient workspace for a fast algorithm           
!                                                                       
                  ITAU = 1                                              
                  IWORK = ITAU + N                                      
!                                                                       
!                 Compute A=Q*R                                         
!                 (CWorkspace: need 2*N, prefer N+N*NB)                 
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CGEQRF( M, N, A, LDA, WORK( ITAU ),            &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
!                                                                       
!                 Copy R to VT, zeroing out below it                    
!                                                                       
                  CALL CSVD_CLACPY( 'U', N, N, A, LDA, VT, LDVT )            
                  CALL CSVD_CLASET( 'L', N-1, N-1, CZERO, CZERO, VT( 2, 1 ), &
                               LDVT )                                   
!                                                                       
!                 Generate Q in A                                       
!                 (CWorkspace: need 2*N, prefer N+N*NB)                 
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CUNGQR( M, N, N, A, LDA, WORK( ITAU ),           &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
                  IE = 1                                                
                  ITAUQ = ITAU                                          
                  ITAUP = ITAUQ + N                                     
                  IWORK = ITAUP + N                                     
!                                                                       
!                 Bidiagonalize R in VT                                 
!                 (CWorkspace: need 3*N, prefer 2*N+2*N*NB)             
!                 (RWorkspace: N)                                       
!                                                                       
                  CALL CSVD_CGEBRD( N, N, VT, LDVT, S, RWORK( IE ),          &
                               WORK( ITAUQ ), WORK( ITAUP ),              &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
!                                                                       
!                 Multiply Q in A by left vectors bidiagonalizing R     
!                 (CWorkspace: need 2*N+M, prefer 2*N+M*NB)             
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CUNMBR( 'Q', 'R', 'N', M, N, N, VT, LDVT,        &
                               WORK( ITAUQ ), A, LDA, WORK( IWORK ),      &
                               LWORK-IWORK+1, IERR )                    
!                                                                       
!                 Generate right vectors bidiagonalizing R in VT        
!                 (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)         
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CUNGBR( 'P', N, N, N, VT, LDVT, WORK( ITAUP ),   &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
                  IRWORK = IE + N                                       
!                                                                       
!                 Perform bidiagonal QR iteration, computing left       
!                 singular vectors of A in A and computing right        
!                 singular vectors of A in VT                           
!                 (CWorkspace: 0)                                       
!                 (RWorkspace: need BDSPAC)                             
!                                                                       
                  CALL CSVD_CBDSQR( 'U', N, N, M, 0, S, RWORK( IE ), VT,     &
                               LDVT, A, LDA, CDUM, 1, RWORK( IRWORK ),    &
                               INFO )                                   
!                                                                       
               END IF                                                   
!                                                                       
            ELSE IF( WNTUS ) THEN                                       
!                                                                       
               IF( WNTVN ) THEN                                         
!                                                                       
!                 Path 4 (M much larger than N, JOBU='S', JOBVT='N')    
!                 N left singular vectors to be computed in U and       
!                 no right singular vectors to be computed              
!                                                                       
                  IF( LWORK.GE.N*N+3*N ) THEN                           
!                                                                       
!                    Sufficient workspace for a fast algorithm          
!                                                                       
                     IR = 1                                             
                     IF( LWORK.GE.WRKBL+LDA*N ) THEN                    
!                                                                       
!                       WORK(IR) is LDA by N                            
!                                                                       
                        LDWRKR = LDA                                    
                     ELSE                                               
!                                                                       
!                       WORK(IR) is N by N                              
!                                                                       
                        LDWRKR = N                                      
                     END IF                                             
                     ITAU = IR + LDWRKR*N                               
                     IWORK = ITAU + N                                   
!                                                                       
!                    Compute A=Q*R                                      
!                    (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)      
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEQRF( M, N, A, LDA, WORK( ITAU ),          &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Copy R to WORK(IR), zeroing out below it           
!                                                                       
                     CALL CSVD_CLACPY( 'U', N, N, A, LDA, WORK( IR ),       &
                                  LDWRKR )                              
                     CALL CSVD_CLASET( 'L', N-1, N-1, CZERO, CZERO,         &
                                  WORK( IR+1 ), LDWRKR )                
!                                                                       
!                    Generate Q in A                                    
!                    (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)      
!                    (RWorkspace: 0)                                    
!                                                                     
                     CALL CSVD_CUNGQR( M, N, N, A, LDA, WORK( ITAU ),       &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + N                                  
                     IWORK = ITAUP + N                                  
!                                                                       
!                    Bidiagonalize R in WORK(IR)                        
!                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)  
!                    (RWorkspace: need N)                               
!                                                                       
                     CALL CSVD_CGEBRD( N, N, WORK( IR ), LDWRKR, S,         &
                                  RWORK( IE ), WORK( ITAUQ ),               &
                                  WORK( ITAUP ), WORK( IWORK ),             &
                                  LWORK-IWORK+1, IERR )                 
!                                                                       
!                    Generate left vectors bidiagonalizing R in WORK(IR)
!                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)    
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'Q', N, N, N, WORK( IR ), LDWRKR,    &
                                  WORK( ITAUQ ), WORK( IWORK ),             &
                                  LWORK-IWORK+1, IERR )                 
                     IRWORK = IE + N                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing left    
!                    singular vectors of R in WORK(IR)                  
!                    (CWorkspace: need N*N)                             
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', N, 0, N, 0, S, RWORK( IE ), CDUM, &
                                  1, WORK( IR ), LDWRKR, CDUM, 1,         &
                                  RWORK( IRWORK ), INFO )               
!                                                                       
!                    Multiply Q in A by left singular vectors of R in   
!                    WORK(IR), storing result in U                      
!                    (CWorkspace: need N*N)                             
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEMM( 'N', 'N', M, N, N, CONE, A, LDA,       &
                                 WORK( IR ), LDWRKR, CZERO, U, LDU )    
!                                                                       
                  ELSE                                                  
!                                                                       
!                    Insufficient workspace for a fast algorithm        
!                                                                       
                     ITAU = 1                                           
                     IWORK = ITAU + N                                   
!                                                                       
!                    Compute A=Q*R, copying result to U                 
!                    (CWorkspace: need 2*N, prefer N+N*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEQRF( M, N, A, LDA, WORK( ITAU ),           &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     CALL CSVD_CLACPY( 'L', M, N, A, LDA, U, LDU )           
!                                                                       
!                    Generate Q in U                                    
!                    (CWorkspace: need 2*N, prefer N+N*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGQR( M, N, N, U, LDU, WORK( ITAU ),        &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + N                                  
                     IWORK = ITAUP + N                                  
!                                                                       
!                    Zero out below R in A                              
!                                                                       
                     CALL CSVD_CLASET( 'L', N-1, N-1, CZERO, CZERO,          &
                                  A( 2, 1 ), LDA )                      
!                                                                       
!                    Bidiagonalize R in A                               
!                    (CWorkspace: need 3*N, prefer 2*N+2*N*NB)          
!                    (RWorkspace: need N)                               
!                                                                       
                     CALL CSVD_CGEBRD( N, N, A, LDA, S, RWORK( IE ),         &
                                  WORK( ITAUQ ), WORK( ITAUP ),           &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Multiply Q in U by left vectors bidiagonalizing R  
!                    (CWorkspace: need 2*N+M, prefer 2*N+M*NB)          
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNMBR( 'Q', 'R', 'N', M, N, N, A, LDA,       &
                                  WORK( ITAUQ ), U, LDU, WORK( IWORK ),   &
                                  LWORK-IWORK+1, IERR )                 
                     IRWORK = IE + N                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing left    
!                    singular vectors of A in U                         
!                    (CWorkspace: 0)                                    
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', N, 0, M, 0, S, RWORK( IE ), CDUM, &
                                  1, U, LDU, CDUM, 1, RWORK( IRWORK ),    &
                                  INFO )                                
!                                                                       
                  END IF                                                
!                                                                       
               ELSE IF( WNTVO ) THEN                                    
!                                                                       
!                 Path 5 (M much larger than N, JOBU='S', JOBVT='O')    
!                 N left singular vectors to be computed in U and       
!                 N right singular vectors to be overwritten on A       
!                                                                       
                  IF( LWORK.GE.2*N*N+3*N ) THEN                         
!                                                                       
!                    Sufficient workspace for a fast algorithm          
!                                                                       
                     IU = 1                                             
                     IF( LWORK.GE.WRKBL+2*LDA*N ) THEN                  
!                                                                       
!                       WORK(IU) is LDA by N and WORK(IR) is LDA by N   
!                                                                       
                        LDWRKU = LDA                                    
                        IR = IU + LDWRKU*N                              
                        LDWRKR = LDA                                    
                     ELSE IF( LWORK.GE.WRKBL+( LDA+N )*N ) THEN         
!                                                                       
!                       WORK(IU) is LDA by N and WORK(IR) is N by N     
!                                                                       
                        LDWRKU = LDA                                    
                        IR = IU + LDWRKU*N                              
                        LDWRKR = N                                      
                     ELSE                                               
!                                                                       
!                       WORK(IU) is N by N and WORK(IR) is N by N       
!                                                                       
                        LDWRKU = N                                      
                        IR = IU + LDWRKU*N                              
                        LDWRKR = N                                      
                     END IF                                             
                     ITAU = IR + LDWRKR*N                               
                     IWORK = ITAU + N                                   
!                                                                       
!                    Compute A=Q*R                                      
!                    (CWorkspace: need 2*N*N+2*N, prefer 2*N*N+N+N*NB)  
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEQRF( M, N, A, LDA, WORK( ITAU ),         &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Copy R to WORK(IU), zeroing out below it           
!                                                                      
                     CALL CSVD_CLACPY( 'U', N, N, A, LDA, WORK( IU ),      &
                                  LDWRKU )                              
                     CALL CSVD_CLASET( 'L', N-1, N-1, CZERO, CZERO,        & 
                                  WORK( IU+1 ), LDWRKU )                
!                                                                       
!                    Generate Q in A                                    
!                    (CWorkspace: need 2*N*N+2*N, prefer 2*N*N+N+N*NB)  
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGQR( M, N, N, A, LDA, WORK( ITAU ),      &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + N                                  
                     IWORK = ITAUP + N                                  
!                                                                       
!                    Bidiagonalize R in WORK(IU), copying result to     
!                    WORK(IR)                                           
!                    (CWorkspace: need   2*N*N+3*N,                     
!                                 prefer 2*N*N+2*N+2*N*NB)              
!                    (RWorkspace: need   N)                             
!                                                                       
                     CALL CSVD_CGEBRD( N, N, WORK( IU ), LDWRKU, S,          &
                                  RWORK( IE ), WORK( ITAUQ ),             &
                                  WORK( ITAUP ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
                     CALL CSVD_CLACPY( 'U', N, N, WORK( IU ), LDWRKU,        &
                                  WORK( IR ), LDWRKR )                  
!                                                                       
!                    Generate left bidiagonalizing vectors in WORK(IU)  
!                    (CWorkspace: need 2*N*N+3*N, prefer 2*N*N+2*N+N*NB)
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'Q', N, N, N, WORK( IU ), LDWRKU,     &
                                  WORK( ITAUQ ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
!                                                                       
!                    Generate right bidiagonalizing vectors in WORK(IR) 
!                    (CWorkspace: need   2*N*N+3*N-1,                   
!                                 prefer 2*N*N+2*N+(N-1)*NB)            
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'P', N, N, N, WORK( IR ), LDWRKR,     &
                                  WORK( ITAUP ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
                     IRWORK = IE + N                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing left    
!                    singular vectors of R in WORK(IU) and computing    
!                    right singular vectors of R in WORK(IR)            
!                    (CWorkspace: need 2*N*N)                           
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', N, N, N, 0, S, RWORK( IE ),      &
                                  WORK( IR ), LDWRKR, WORK( IU ),         &
                                  LDWRKU, CDUM, 1, RWORK( IRWORK ),       &
                                  INFO )                                
!                                                                       
!                    Multiply Q in A by left singular vectors of R in   
!                    WORK(IU), storing result in U                      
!                    (CWorkspace: need N*N)                             
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEMM( 'N', 'N', M, N, N, CONE, A, LDA,       &
                                 WORK( IU ), LDWRKU, CZERO, U, LDU )    
!                                                                       
!                    Copy right singular vectors of R to A              
!                    (CWorkspace: need N*N)                             
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CLACPY( 'F', N, N, WORK( IR ), LDWRKR, A,     &
                                  LDA )                                 
!                                                                       
                  ELSE                                                  
!                                                                       
!                    Insufficient workspace for a fast algorithm        
!                                                                       
                     ITAU = 1                                           
                     IWORK = ITAU + N                                   
!                                                                       
!                    Compute A=Q*R, copying result to U                 
!                    (CWorkspace: need 2*N, prefer N+N*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEQRF( M, N, A, LDA, WORK( ITAU ),           &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )       
                     CALL CSVD_CLACPY( 'L', M, N, A, LDA, U, LDU )           
!                                                                       
!                    Generate Q in U                                    
!                    (CWorkspace: need 2*N, prefer N+N*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGQR( M, N, N, U, LDU, WORK( ITAU ),        &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + N                                  
                     IWORK = ITAUP + N                                  
!                                                                       
!                    Zero out below R in A                              
!                                                                       
                     CALL CSVD_CLASET( 'L', N-1, N-1, CZERO, CZERO,          &
                                  A( 2, 1 ), LDA )                      
!                                                                       
!                    Bidiagonalize R in A                               
!                    (CWorkspace: need 3*N, prefer 2*N+2*N*NB)          
!                    (RWorkspace: need N)                               
!                                                                       
                     CALL CSVD_CGEBRD( N, N, A, LDA, S, RWORK( IE ),         &
                                  WORK( ITAUQ ), WORK( ITAUP ),           &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Multiply Q in U by left vectors bidiagonalizing R  
!                    (CWorkspace: need 2*N+M, prefer 2*N+M*NB)          
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNMBR( 'Q', 'R', 'N', M, N, N, A, LDA,       &
                                  WORK( ITAUQ ), U, LDU, WORK( IWORK ),   &
                                  LWORK-IWORK+1, IERR )                 
!                                                                       
!                    Generate right vectors bidiagonalizing R in A      
!                    (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)      
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'P', N, N, N, A, LDA, WORK( ITAUP ),  &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IRWORK = IE + N                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing left    
!                    singular vectors of A in U and computing right     
!                    singular vectors of A in A                         
!                    (CWorkspace: 0)                                    
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', N, N, M, 0, S, RWORK( IE ), A,   &
                                  LDA, U, LDU, CDUM, 1, RWORK( IRWORK ),  &
                                  INFO )                                
!                                                                       
                  END IF                                                
!                                                                       
               ELSE IF( WNTVAS ) THEN                                   
!                                                                       
!                 Path 6 (M much larger than N, JOBU='S', JOBVT='S'     
!                         or 'A')                                       
!                 N left singular vectors to be computed in U and       
!                 N right singular vectors to be computed in VT         
!                                                                       
                  IF( LWORK.GE.N*N+3*N ) THEN                           
!                                                                       
!                    Sufficient workspace for a fast algorithm          
!                                                                       
                     IU = 1                                             
                     IF( LWORK.GE.WRKBL+LDA*N ) THEN                    
!                                                                       
!                       WORK(IU) is LDA by N                            
!                                                                       
                        LDWRKU = LDA                                    
                     ELSE                                               
!                                                                       
!                       WORK(IU) is N by N                              
!                                                                       
                        LDWRKU = N                                      
                     END IF                                             
                     ITAU = IU + LDWRKU*N                               
                     IWORK = ITAU + N                                   
!                                                                       
!                    Compute A=Q*R                                      
!                    (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)      
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEQRF( M, N, A, LDA, WORK( ITAU ),           &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Copy R to WORK(IU), zeroing out below it           
!                                                                       
                     CALL CSVD_CLACPY( 'U', N, N, A, LDA, WORK( IU ),        &
                                  LDWRKU )                              
                     CALL CSVD_CLASET( 'L', N-1, N-1, CZERO, CZERO,          &
                                  WORK( IU+1 ), LDWRKU )                
!                                                                       
!                    Generate Q in A                                    
!                    (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)      
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGQR( M, N, N, A, LDA, WORK( ITAU ),        &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + N                                  
                     IWORK = ITAUP + N                                  
!                                                                       
!                    Bidiagonalize R in WORK(IU), copying result to VT  
!                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)  
!                    (RWorkspace: need N)                               
!                                                                       
                     CALL CSVD_CGEBRD( N, N, WORK( IU ), LDWRKU, S,            &
                                  RWORK( IE ), WORK( ITAUQ ),             &
                                  WORK( ITAUP ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
                     CALL CSVD_CLACPY( 'U', N, N, WORK( IU ), LDWRKU, VT,      &
                                  LDVT )                                
!                                                                       
!                    Generate left bidiagonalizing vectors in WORK(IU)  
!                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)    
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'Q', N, N, N, WORK( IU ), LDWRKU,       &
                                  WORK( ITAUQ ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
!                                                                       
!                    Generate right bidiagonalizing vectors in VT       
!                    (CWorkspace: need   N*N+3*N-1,                     
!                                 prefer N*N+2*N+(N-1)*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'P', N, N, N, VT, LDVT, WORK( ITAUP ),  &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IRWORK = IE + N                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing left    
!                    singular vectors of R in WORK(IU) and computing    
!                    right singular vectors of R in VT                  
!                    (CWorkspace: need N*N)                             
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', N, N, N, 0, S, RWORK( IE ), VT,    &
                                  LDVT, WORK( IU ), LDWRKU, CDUM, 1,      &
                                  RWORK( IRWORK ), INFO )               
!                                                                       
!                    Multiply Q in A by left singular vectors of R in   
!                    WORK(IU), storing result in U                      
!                    (CWorkspace: need N*N)                             
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEMM( 'N', 'N', M, N, N, CONE, A, LDA,         &
                                 WORK( IU ), LDWRKU, CZERO, U, LDU )    
!                                                                       
                  ELSE                                                  
!                                                                       
!                    Insufficient workspace for a fast algorithm        
!                                                                       
                     ITAU = 1                                           
                     IWORK = ITAU + N                                   
!                                                                       
!                    Compute A=Q*R, copying result to U                 
!                    (CWorkspace: need 2*N, prefer N+N*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEQRF( M, N, A, LDA, WORK( ITAU ),             &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     CALL CSVD_CLACPY( 'L', M, N, A, LDA, U, LDU )           
!                                                                       
!                    Generate Q in U                                    
!                    (CWorkspace: need 2*N, prefer N+N*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGQR( M, N, N, U, LDU, WORK( ITAU ),          &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Copy R to VT, zeroing out below it                 
!                                                                       
                     CALL CSVD_CLACPY( 'U', N, N, A, LDA, VT, LDVT )         
                     CALL CSVD_CLASET( 'L', N-1, N-1, CZERO, CZERO,            &
                                  VT( 2, 1 ), LDVT )                    
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + N                                  
                     IWORK = ITAUP + N                                  
!                                                                       
!                    Bidiagonalize R in VT                              
!                    (CWorkspace: need 3*N, prefer 2*N+2*N*NB)          
!                    (RWorkspace: need N)                               
!                                                                       
                     CALL CSVD_CGEBRD( N, N, VT, LDVT, S, RWORK( IE ),         &
                                  WORK( ITAUQ ), WORK( ITAUP ),           &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Multiply Q in U by left bidiagonalizing vectors    
!                    in VT                                              
!                    (CWorkspace: need 2*N+M, prefer 2*N+M*NB)          
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNMBR( 'Q', 'R', 'N', M, N, N, VT, LDVT,       &
                                  WORK( ITAUQ ), U, LDU, WORK( IWORK ),   &
                                  LWORK-IWORK+1, IERR )                 
!                                                                       
!                    Generate right bidiagonalizing vectors in VT       
!                    (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)      
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'P', N, N, N, VT, LDVT, WORK( ITAUP ),  &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IRWORK = IE + N                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing left    
!                    singular vectors of A in U and computing right     
!                    singular vectors of A in VT                        
!                    (CWorkspace: 0)                                    
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', N, N, M, 0, S, RWORK( IE ), VT,    &
                                  LDVT, U, LDU, CDUM, 1,                  &
                                  RWORK( IRWORK ), INFO )               
!                                                                       
                  END IF                                                
!                                                                       
               END IF                                                   
!                                                                       
            ELSE IF( WNTUA ) THEN                                       
!                                                                       
               IF( WNTVN ) THEN                                         
!                                                                       
!                 Path 7 (M much larger than N, JOBU='A', JOBVT='N')    
!                 M left singular vectors to be computed in U and       
!                 no right singular vectors to be computed              
!                                                                       
                  IF( LWORK.GE.N*N+MAX( N+M, 3*N ) ) THEN               
!                                                                       
!                    Sufficient workspace for a fast algorithm          
!                                                                       
                     IR = 1                                             
                     IF( LWORK.GE.WRKBL+LDA*N ) THEN                    
!                                                                       
!                       WORK(IR) is LDA by N                            
!                                                                       
                        LDWRKR = LDA                                    
                     ELSE                                               
!                                                                       
!                       WORK(IR) is N by N                              
!                                                                       
                        LDWRKR = N                                      
                     END IF                                             
                     ITAU = IR + LDWRKR*N                               
                     IWORK = ITAU + N                                   
!                                                                       
!                    Compute A=Q*R, copying result to U                 
!                    (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)      
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEQRF( M, N, A, LDA, WORK( ITAU ),             &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     CALL CSVD_CLACPY( 'L', M, N, A, LDA, U, LDU )           
!                                                                       
!                    Copy R to WORK(IR), zeroing out below it           
!                                                                       
                     CALL CSVD_CLACPY( 'U', N, N, A, LDA, WORK( IR ),          &
                                  LDWRKR )                              
                     CALL CSVD_CLASET( 'L', N-1, N-1, CZERO, CZERO,            &
                                  WORK( IR+1 ), LDWRKR )                
!                                                                       
!                    Generate Q in U                                    
!                    (CWorkspace: need N*N+N+M, prefer N*N+N+M*NB)      
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGQR( M, M, N, U, LDU, WORK( ITAU ),          &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + N                                  
                     IWORK = ITAUP + N                                  
!                                                                       
!                    Bidiagonalize R in WORK(IR)                        
!                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)  
!                    (RWorkspace: need N)                               
!                                                                       
                     CALL CSVD_CGEBRD( N, N, WORK( IR ), LDWRKR, S,            &
                                  RWORK( IE ), WORK( ITAUQ ),             &
                                  WORK( ITAUP ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
!                                                                       
!                    Generate left bidiagonalizing vectors in WORK(IR)  
!                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)    
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'Q', N, N, N, WORK( IR ), LDWRKR,       &
                                  WORK( ITAUQ ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
                     IRWORK = IE + N                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing left    
!                    singular vectors of R in WORK(IR)                  
!                    (CWorkspace: need N*N)                             
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', N, 0, N, 0, S, RWORK( IE ), CDUM,  &
                                  1, WORK( IR ), LDWRKR, CDUM, 1,         &
                                  RWORK( IRWORK ), INFO )               
!                                                                       
!                    Multiply Q in U by left singular vectors of R in   
!                    WORK(IR), storing result in A                      
!                    (CWorkspace: need N*N)                             
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEMM( 'N', 'N', M, N, N, CONE, U, LDU,         &
                                 WORK( IR ), LDWRKR, CZERO, A, LDA )    
!                                                                       
!                    Copy left singular vectors of A from A to U        
!                                                                       
                     CALL CSVD_CLACPY( 'F', M, N, A, LDA, U, LDU )           
!                                                                       
                  ELSE                                                  
!                                                                       
!                    Insufficient workspace for a fast algorithm        
!                                                                       
                     ITAU = 1                                           
                     IWORK = ITAU + N                                   
!                                                                       
!                    Compute A=Q*R, copying result to U                 
!                    (CWorkspace: need 2*N, prefer N+N*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEQRF( M, N, A, LDA, WORK( ITAU ),             &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     CALL CSVD_CLACPY( 'L', M, N, A, LDA, U, LDU )           
!                                                                       
!                    Generate Q in U                                    
!                    (CWorkspace: need N+M, prefer N+M*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGQR( M, M, N, U, LDU, WORK( ITAU ),          &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + N                                  
                     IWORK = ITAUP + N                                  
!                                                                       
!                    Zero out below R in A                              
!                                                                       
                     CALL CSVD_CLASET( 'L', N-1, N-1, CZERO, CZERO,            &
                                  A( 2, 1 ), LDA )                      
!                                                                       
!                    Bidiagonalize R in A                               
!                    (CWorkspace: need 3*N, prefer 2*N+2*N*NB)          
!                    (RWorkspace: need N)                               
!                                                                       
                     CALL CSVD_CGEBRD( N, N, A, LDA, S, RWORK( IE ),           &
                                  WORK( ITAUQ ), WORK( ITAUP ),           &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Multiply Q in U by left bidiagonalizing vectors    
!                    in A                                               
!                    (CWorkspace: need 2*N+M, prefer 2*N+M*NB)          
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNMBR( 'Q', 'R', 'N', M, N, N, A, LDA,         &
                                  WORK( ITAUQ ), U, LDU, WORK( IWORK ),   &
                                  LWORK-IWORK+1, IERR )                 
                     IRWORK = IE + N                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing left    
!                    singular vectors of A in U                         
!                    (CWorkspace: 0)                                    
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', N, 0, M, 0, S, RWORK( IE ), CDUM,  &
                                  1, U, LDU, CDUM, 1, RWORK( IRWORK ),    &
                                  INFO )                                
!                                                                       
                  END IF                                                
!                                                                       
               ELSE IF( WNTVO ) THEN                                    
!                                                                       
!                 Path 8 (M much larger than N, JOBU='A', JOBVT='O')    
!                 M left singular vectors to be computed in U and       
!                 N right singular vectors to be overwritten on A       
!                                                                       
                  IF( LWORK.GE.2*N*N+MAX( N+M, 3*N ) ) THEN             
!                                                                       
!                    Sufficient workspace for a fast algorithm          
!                                                                       
                     IU = 1                                             
                     IF( LWORK.GE.WRKBL+2*LDA*N ) THEN                  
!                                                                       
!                       WORK(IU) is LDA by N and WORK(IR) is LDA by N   
!                                                                       
                        LDWRKU = LDA                                    
                        IR = IU + LDWRKU*N                              
                        LDWRKR = LDA                                    
                     ELSE IF( LWORK.GE.WRKBL+( LDA+N )*N ) THEN         
!                                                                       
!                       WORK(IU) is LDA by N and WORK(IR) is N by N     
!                                                                       
                        LDWRKU = LDA                                    
                        IR = IU + LDWRKU*N                              
                        LDWRKR = N                                      
                     ELSE                                               
!                                                                       
!                       WORK(IU) is N by N and WORK(IR) is N by N       
!                                                                       
                        LDWRKU = N                                      
                        IR = IU + LDWRKU*N                              
                        LDWRKR = N                                      
                     END IF                                             
                     ITAU = IR + LDWRKR*N                               
                     IWORK = ITAU + N                                   
!                                                                       
!                    Compute A=Q*R, copying result to U                 
!                    (CWorkspace: need 2*N*N+2*N, prefer 2*N*N+N+N*NB)  
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEQRF( M, N, A, LDA, WORK( ITAU ),             &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     CALL CSVD_CLACPY( 'L', M, N, A, LDA, U, LDU )           
!                                                                       
!                    Generate Q in U                                    
!                    (CWorkspace: need 2*N*N+N+M, prefer 2*N*N+N+M*NB)  
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGQR( M, M, N, U, LDU, WORK( ITAU ),          &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Copy R to WORK(IU), zeroing out below it           
!                                                                       
                     CALL CSVD_CLACPY( 'U', N, N, A, LDA, WORK( IU ),          &
                                  LDWRKU )                              
                     CALL CSVD_CLASET( 'L', N-1, N-1, CZERO, CZERO,            &
                                  WORK( IU+1 ), LDWRKU )                
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + N                                  
                     IWORK = ITAUP + N                                  
!                                                                       
!                    Bidiagonalize R in WORK(IU), copying result to     
!                    WORK(IR)                                           
!                    (CWorkspace: need   2*N*N+3*N,                     
!                                 prefer 2*N*N+2*N+2*N*NB)              
!                    (RWorkspace: need   N)                             
!                                                                       
                     CALL CSVD_CGEBRD( N, N, WORK( IU ), LDWRKU, S,            &
                                  RWORK( IE ), WORK( ITAUQ ),             &
                                  WORK( ITAUP ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
                     CALL CSVD_CLACPY( 'U', N, N, WORK( IU ), LDWRKU,          &
                                  WORK( IR ), LDWRKR )                  
!                                                                       
!                    Generate left bidiagonalizing vectors in WORK(IU)  
!                    (CWorkspace: need 2*N*N+3*N, prefer 2*N*N+2*N+N*NB)
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'Q', N, N, N, WORK( IU ), LDWRKU,       &
                                  WORK( ITAUQ ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
!                                                                       
!                    Generate right bidiagonalizing vectors in WORK(IR) 
!                    (CWorkspace: need   2*N*N+3*N-1,                   
!                                 prefer 2*N*N+2*N+(N-1)*NB)            
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'P', N, N, N, WORK( IR ), LDWRKR,       &
                                  WORK( ITAUP ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
                     IRWORK = IE + N                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing left    
!                    singular vectors of R in WORK(IU) and computing    
!                    right singular vectors of R in WORK(IR)            
!                    (CWorkspace: need 2*N*N)                           
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', N, N, N, 0, S, RWORK( IE ),        &
                                  WORK( IR ), LDWRKR, WORK( IU ),         &
                                  LDWRKU, CDUM, 1, RWORK( IRWORK ),       &
                                  INFO )                                
!                                                                       
!                    Multiply Q in U by left singular vectors of R in   
!                    WORK(IU), storing result in A                      
!                    (CWorkspace: need N*N)                             
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEMM( 'N', 'N', M, N, N, CONE, U, LDU,         &
                                 WORK( IU ), LDWRKU, CZERO, A, LDA )    
!                                                                       
!                    Copy left singular vectors of A from A to U        
!                                                                       
                     CALL CSVD_CLACPY( 'F', M, N, A, LDA, U, LDU )           
!                                                                       
!                    Copy right singular vectors of R from WORK(IR) to A
!                                                                       
                     CALL CSVD_CLACPY( 'F', N, N, WORK( IR ), LDWRKR, A,       &
                                  LDA )                                 
!                                                                       
                  ELSE                                                  
!                                                                       
!                    Insufficient workspace for a fast algorithm        
!                                                                       
                     ITAU = 1                                           
                     IWORK = ITAU + N                                   
!                                                                       
!                    Compute A=Q*R, copying result to U                 
!                    (CWorkspace: need 2*N, prefer N+N*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEQRF( M, N, A, LDA, WORK( ITAU ),             &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     CALL CSVD_CLACPY( 'L', M, N, A, LDA, U, LDU )           
!                                                                       
!                    Generate Q in U                                    
!                    (CWorkspace: need N+M, prefer N+M*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGQR( M, M, N, U, LDU, WORK( ITAU ),          &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + N                                  
                     IWORK = ITAUP + N                                  
!                                                                       
!                    Zero out below R in A                              
!                                                                       
                     CALL CSVD_CLASET( 'L', N-1, N-1, CZERO, CZERO,            &
                                  A( 2, 1 ), LDA )                      
!                                                                       
!                    Bidiagonalize R in A                               
!                    (CWorkspace: need 3*N, prefer 2*N+2*N*NB)          
!                    (RWorkspace: need N)                               
!                                                                       
                     CALL CSVD_CGEBRD( N, N, A, LDA, S, RWORK( IE ),           &
                                  WORK( ITAUQ ), WORK( ITAUP ),           &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Multiply Q in U by left bidiagonalizing vectors    
!                    in A                                               
!                    (CWorkspace: need 2*N+M, prefer 2*N+M*NB)          
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNMBR( 'Q', 'R', 'N', M, N, N, A, LDA,         &
                                  WORK( ITAUQ ), U, LDU, WORK( IWORK ),   &
                                  LWORK-IWORK+1, IERR )                 
!                                                                       
!                    Generate right bidiagonalizing vectors in A        
!                    (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)      
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'P', N, N, N, A, LDA, WORK( ITAUP ),    &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IRWORK = IE + N                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing left    
!                    singular vectors of A in U and computing right     
!                    singular vectors of A in A                         
!                    (CWorkspace: 0)                                    
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', N, N, M, 0, S, RWORK( IE ), A,     &
                                  LDA, U, LDU, CDUM, 1, RWORK( IRWORK ),  &
                                  INFO )                                
!                                                                       
                  END IF                                                
!                                                                       
               ELSE IF( WNTVAS ) THEN                                   
!                                                                       
!                 Path 9 (M much larger than N, JOBU='A', JOBVT='S'     
!                         or 'A')                                       
!                 M left singular vectors to be computed in U and       
!                 N right singular vectors to be computed in VT         
!                                                                       
                  IF( LWORK.GE.N*N+MAX( N+M, 3*N ) ) THEN               
!                                                                       
!                    Sufficient workspace for a fast algorithm          
!                                                                       
                     IU = 1                                             
                     IF( LWORK.GE.WRKBL+LDA*N ) THEN                    
!                                                                       
!                       WORK(IU) is LDA by N                            
!                                                                       
                        LDWRKU = LDA                                    
                     ELSE                                               
!                                                                       
!                       WORK(IU) is N by N                              
!                                                                       
                        LDWRKU = N                                      
                     END IF                                             
                     ITAU = IU + LDWRKU*N                               
                     IWORK = ITAU + N                                   
!                                                                       
!                    Compute A=Q*R, copying result to U                 
!                    (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)      
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEQRF( M, N, A, LDA, WORK( ITAU ),             &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     CALL CSVD_CLACPY( 'L', M, N, A, LDA, U, LDU )           
!                                                                       
!                    Generate Q in U                                    
!                    (CWorkspace: need N*N+N+M, prefer N*N+N+M*NB)      
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGQR( M, M, N, U, LDU, WORK( ITAU ),          &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Copy R to WORK(IU), zeroing out below it           
!                                                                       
                     CALL CSVD_CLACPY( 'U', N, N, A, LDA, WORK( IU ),          &
                                  LDWRKU )                              
                     CALL CSVD_CLASET( 'L', N-1, N-1, CZERO, CZERO,            &
                                  WORK( IU+1 ), LDWRKU )                
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + N                                  
                     IWORK = ITAUP + N                                  
!                                                                       
!                    Bidiagonalize R in WORK(IU), copying result to VT  
!                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)  
!                    (RWorkspace: need N)                               
!                                                                       
                     CALL CSVD_CGEBRD( N, N, WORK( IU ), LDWRKU, S,            &
                                  RWORK( IE ), WORK( ITAUQ ),             &
                                  WORK( ITAUP ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
                     CALL CSVD_CLACPY( 'U', N, N, WORK( IU ), LDWRKU, VT,      &
                                  LDVT )                                
!                                                                       
!                    Generate left bidiagonalizing vectors in WORK(IU)  
!                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)    
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'Q', N, N, N, WORK( IU ), LDWRKU,       &
                                  WORK( ITAUQ ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
!                                                                       
!                    Generate right bidiagonalizing vectors in VT       
!                    (CWorkspace: need   N*N+3*N-1,                     
!                                 prefer N*N+2*N+(N-1)*NB)              
!                    (RWorkspace: need   0)                             
!                                                                       
                     CALL CSVD_CUNGBR( 'P', N, N, N, VT, LDVT, WORK( ITAUP ),  &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IRWORK = IE + N                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing left    
!                    singular vectors of R in WORK(IU) and computing    
!                    right singular vectors of R in VT                  
!                    (CWorkspace: need N*N)                             
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', N, N, N, 0, S, RWORK( IE ), VT,    &
                                  LDVT, WORK( IU ), LDWRKU, CDUM, 1,      &
                                  RWORK( IRWORK ), INFO )               
!                                                                       
!                    Multiply Q in U by left singular vectors of R in   
!                    WORK(IU), storing result in A                      
!                    (CWorkspace: need N*N)                             
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEMM( 'N', 'N', M, N, N, CONE, U, LDU,         &
                                 WORK( IU ), LDWRKU, CZERO, A, LDA )    
!                                                                       
!                    Copy left singular vectors of A from A to U        
!                                                                       
                     CALL CSVD_CLACPY( 'F', M, N, A, LDA, U, LDU )           
!                                                                       
                  ELSE                                                  
!                                                                       
!                    Insufficient workspace for a fast algorithm        
!                                                                       
                     ITAU = 1                                           
                     IWORK = ITAU + N                                   
!                                                                       
!                    Compute A=Q*R, copying result to U                 
!                    (CWorkspace: need 2*N, prefer N+N*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEQRF( M, N, A, LDA, WORK( ITAU ),             &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     CALL CSVD_CLACPY( 'L', M, N, A, LDA, U, LDU )           
!                                                                       
!                    Generate Q in U                                    
!                    (CWorkspace: need N+M, prefer N+M*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGQR( M, M, N, U, LDU, WORK( ITAU ),          &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Copy R from A to VT, zeroing out below it          
!                                                                       
                     CALL CSVD_CLACPY( 'U', N, N, A, LDA, VT, LDVT )         
                     CALL CSVD_CLASET( 'L', N-1, N-1, CZERO, CZERO,            &
                                  VT( 2, 1 ), LDVT )                    
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + N                                  
                     IWORK = ITAUP + N                                  
!                                                                       
!                    Bidiagonalize R in VT                              
!                    (CWorkspace: need 3*N, prefer 2*N+2*N*NB)          
!                    (RWorkspace: need N)                               
!                                                                       
                     CALL CSVD_CGEBRD( N, N, VT, LDVT, S, RWORK( IE ),         &
                                  WORK( ITAUQ ), WORK( ITAUP ),           &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Multiply Q in U by left bidiagonalizing vectors    
!                    in VT                                              
!                    (CWorkspace: need 2*N+M, prefer 2*N+M*NB)          
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNMBR( 'Q', 'R', 'N', M, N, N, VT, LDVT,       &
                                  WORK( ITAUQ ), U, LDU, WORK( IWORK ),   &
                                  LWORK-IWORK+1, IERR )                 
!                                                                       
!                    Generate right bidiagonalizing vectors in VT       
!                    (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)      
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'P', N, N, N, VT, LDVT, WORK( ITAUP ),  &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IRWORK = IE + N                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing left    
!                    singular vectors of A in U and computing right     
!                    singular vectors of A in VT                        
!                    (CWorkspace: 0)                                    
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', N, N, M, 0, S, RWORK( IE ), VT,    &
                                  LDVT, U, LDU, CDUM, 1,                  &
                                  RWORK( IRWORK ), INFO )               
!                                                                       
                  END IF                                                
!                                                                       
               END IF                                                   
!                                                                       
            END IF                                                      
!                                                                       
         ELSE                                                           
!                                                                       
!           M .LT. MNTHR                                                
!                                                                       
!           Path 10 (M at least N, but not much larger)                 
!           Reduce to bidiagonal form without QR decomposition          
!                                                                       
            IE = 1                                                      
            ITAUQ = 1                                                   
            ITAUP = ITAUQ + N                                           
            IWORK = ITAUP + N                                           
!                                                                       
!           Bidiagonalize A                                             
!           (CWorkspace: need 2*N+M, prefer 2*N+(M+N)*NB)               
!           (RWorkspace: need N)                                        
!                                                                       
            CALL CSVD_CGEBRD( M, N, A, LDA, S, RWORK( IE ), WORK( ITAUQ ),     &
                         WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,     &
                         IERR )                                         
            IF( WNTUAS ) THEN                                           
!                                                                       
!              If left singular vectors desired in U, copy result to U  
!              and generate left bidiagonalizing vectors in U           
!              (CWorkspace: need 2*N+NCU, prefer 2*N+NCU*NB)            
!              (RWorkspace: 0)                                          
!                                                                       
               CALL CSVD_CLACPY( 'L', M, N, A, LDA, U, LDU )                 
               IF( WNTUS )                                                &
                  NCU = N                                               
               IF( WNTUA )                                                &
                  NCU = M                                               
               CALL CSVD_CUNGBR( 'Q', M, NCU, N, U, LDU, WORK( ITAUQ ),        &
                            WORK( IWORK ), LWORK-IWORK+1, IERR )        
            END IF                                                      
            IF( WNTVAS ) THEN                                           
!                                                                       
!              If right singular vectors desired in VT, copy result to  
!              VT and generate right bidiagonalizing vectors in VT      
!              (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)            
!              (RWorkspace: 0)                                          
!                                                                       
               CALL CSVD_CLACPY( 'U', N, N, A, LDA, VT, LDVT )               
               CALL CSVD_CUNGBR( 'P', N, N, N, VT, LDVT, WORK( ITAUP ),        &
                            WORK( IWORK ), LWORK-IWORK+1, IERR )        
            END IF                                                      
            IF( WNTUO ) THEN                                            
!                                                                       
!              If left singular vectors desired in A, generate left     
!              bidiagonalizing vectors in A                             
!              (CWorkspace: need 3*N, prefer 2*N+N*NB)                  
!              (RWorkspace: 0)                                          
!                                                                       
               CALL CSVD_CUNGBR( 'Q', M, N, N, A, LDA, WORK( ITAUQ ),          &
                            WORK( IWORK ), LWORK-IWORK+1, IERR )        
            END IF                                                      
            IF( WNTVO ) THEN                                            
!                                                                       
!              If right singular vectors desired in A, generate right   
!              bidiagonalizing vectors in A                             
!              (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)            
!              (RWorkspace: 0)                                          
!                                                                       
               CALL CSVD_CUNGBR( 'P', N, N, N, A, LDA, WORK( ITAUP ),          &
                            WORK( IWORK ), LWORK-IWORK+1, IERR )        
            END IF                                                      
            IRWORK = IE + N                                             
            IF( WNTUAS .OR. WNTUO )                                       &
               NRU = M                                                  
            IF( WNTUN )                                                   &
               NRU = 0                                                  
            IF( WNTVAS .OR. WNTVO )                                       &
               NCVT = N                                                 
            IF( WNTVN )                                                   &
               NCVT = 0                                                 
            IF( ( .NOT.WNTUO ) .AND. ( .NOT.WNTVO ) ) THEN              
!                                                                       
!              Perform bidiagonal QR iteration, if desired, computing   
!              left singular vectors in U and computing right singular  
!              vectors in VT                                            
!              (CWorkspace: 0)                                          
!              (RWorkspace: need BDSPAC)                                
!                                                                       
               CALL CSVD_CBDSQR( 'U', N, NCVT, NRU, 0, S, RWORK( IE ), VT,     &
                            LDVT, U, LDU, CDUM, 1, RWORK( IRWORK ),       &
                            INFO )                                      
            ELSE IF( ( .NOT.WNTUO ) .AND. WNTVO ) THEN                  
!                                                                       
!              Perform bidiagonal QR iteration, if desired, computing   
!              left singular vectors in U and computing right singular  
!              vectors in A                                             
!              (CWorkspace: 0)                                          
!              (RWorkspace: need BDSPAC)                                
!                                                                       
               CALL CSVD_CBDSQR( 'U', N, NCVT, NRU, 0, S, RWORK( IE ), A,      &
                            LDA, U, LDU, CDUM, 1, RWORK( IRWORK ),        &
                            INFO )                                      
            ELSE                                                        
!                                                                       
!              Perform bidiagonal QR iteration, if desired, computing   
!              left singular vectors in A and computing right singular  
!              vectors in VT                                            
!              (CWorkspace: 0)                                          
!              (RWorkspace: need BDSPAC)                                
!                                                                       
               CALL CSVD_CBDSQR( 'U', N, NCVT, NRU, 0, S, RWORK( IE ), VT,     &
                            LDVT, A, LDA, CDUM, 1, RWORK( IRWORK ),       &
                            INFO )                                      
            END IF                                                      
!                                                                       
         END IF                                                         
!                                                                       
      ELSE                                                              
!                                                                       
!        A has more columns than rows. If A has sufficiently more       
!        columns than rows, first reduce using the LQ decomposition (if 
!        sufficient workspace available)                                
!                                                                       
         IF( N.GE.MNTHR ) THEN                                          
!                                                                       
            IF( WNTVN ) THEN                                            
!                                                                       
!              Path 1t(N much larger than M, JOBVT='N')                 
!              No right singular vectors to be computed                 
!                                                                       
               ITAU = 1                                                 
               IWORK = ITAU + M                                         
!                                                                       
!              Compute A=L*Q                                            
!              (CWorkspace: need 2*M, prefer M+M*NB)                    
!              (RWorkspace: 0)                                          
!                                                                       
               CALL CSVD_CGELQF( M, N, A, LDA, WORK( ITAU ), WORK( IWORK ),    &
                            LWORK-IWORK+1, IERR )                       
!                                                                       
!              Zero out above L                                         
!                                                                       
               CALL CSVD_CLASET( 'U', M-1, M-1, CZERO, CZERO, A( 1, 2 ),       &
                            LDA )                                       
               IE = 1                                                   
               ITAUQ = 1                                                
               ITAUP = ITAUQ + M                                        
               IWORK = ITAUP + M                                        
!                                                                       
!              Bidiagonalize L in A                                     
!              (CWorkspace: need 3*M, prefer 2*M+2*M*NB)                
!              (RWorkspace: need M)                                     
!                                                                       
               CALL CSVD_CGEBRD( M, M, A, LDA, S, RWORK( IE ), WORK( ITAUQ ),  &
                            WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,  &
                            IERR )                                      
               IF( WNTUO .OR. WNTUAS ) THEN                             
!                                                                       
!                 If left singular vectors desired, generate Q          
!                 (CWorkspace: need 3*M, prefer 2*M+M*NB)               
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CUNGBR( 'Q', M, M, M, A, LDA, WORK( ITAUQ ),       &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
               END IF                                                   
               IRWORK = IE + M                                          
               NRU = 0                                                  
               IF( WNTUO .OR. WNTUAS )                                    &
                  NRU = M                                               
!                                                                       
!              Perform bidiagonal QR iteration, computing left singular 
!              vectors of A in A if desired                             
!              (CWorkspace: 0)                                          
!              (RWorkspace: need BDSPAC)                                
!                                                                       
               CALL CSVD_CBDSQR( 'U', M, 0, NRU, 0, S, RWORK( IE ), CDUM, 1,   &
                            A, LDA, CDUM, 1, RWORK( IRWORK ), INFO )    
!                                                                       
!              If left singular vectors desired in U, copy them there   
!                                                                       
               IF( WNTUAS )                                               &
                  CALL CSVD_CLACPY( 'F', M, M, A, LDA, U, LDU )              
!                                                                       
            ELSE IF( WNTVO .AND. WNTUN ) THEN                           
!                                                                       
!              Path 2t(N much larger than M, JOBU='N', JOBVT='O')       
!              M right singular vectors to be overwritten on A and      
!              no left singular vectors to be computed                  
!                                                                       
               IF( LWORK.GE.M*M+3*M ) THEN                              
!                                                                       
!                 Sufficient workspace for a fast algorithm             
!                                                                       
                  IR = 1                                                
                  IF( LWORK.GE.MAX( WRKBL, LDA*N )+LDA*M ) THEN         
!                                                                       
!                    WORK(IU) is LDA by N and WORK(IR) is LDA by M      
!                                                                       
                     LDWRKU = LDA                                       
                     CHUNK = N                                          
                     LDWRKR = LDA                                       
                  ELSE IF( LWORK.GE.MAX( WRKBL, LDA*N )+M*M ) THEN      
!                                                                       
!                    WORK(IU) is LDA by N and WORK(IR) is M by M        
!                                                                       
                     LDWRKU = LDA                                       
                     CHUNK = N                                          
                     LDWRKR = M                                         
                  ELSE                                                  
!                                                                       
!                    WORK(IU) is M by CHUNK and WORK(IR) is M by M      
!                                                                       
                     LDWRKU = M                                         
                     CHUNK = ( LWORK-M*M ) / M                          
                     LDWRKR = M                                         
                  END IF                                                
                  ITAU = IR + LDWRKR*M                                  
                  IWORK = ITAU + M                                      
!                                                                       
!                 Compute A=L*Q                                         
!                 (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)         
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CGELQF( M, N, A, LDA, WORK( ITAU ),                &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
!                                                                       
!                 Copy L to WORK(IR) and zero out above it              
!                                                                       
                  CALL CSVD_CLACPY( 'L', M, M, A, LDA, WORK( IR ), LDWRKR )  
                  CALL CSVD_CLASET( 'U', M-1, M-1, CZERO, CZERO,               &
                               WORK( IR+LDWRKR ), LDWRKR )              
!                                                                       
!                 Generate Q in A                                       
!                 (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)         
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CUNGLQ( M, N, M, A, LDA, WORK( ITAU ),             &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
                  IE = 1                                                
                  ITAUQ = ITAU                                          
                  ITAUP = ITAUQ + M                                     
                  IWORK = ITAUP + M                                     
!                                                                       
!                 Bidiagonalize L in WORK(IR)                           
!                 (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)     
!                 (RWorkspace: need M)                                  
!                                                                       
                  CALL CSVD_CGEBRD( M, M, WORK( IR ), LDWRKR, S, RWORK( IE ),  &
                               WORK( ITAUQ ), WORK( ITAUP ),              &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
!                                                                       
!                 Generate right vectors bidiagonalizing L              
!                 (CWorkspace: need M*M+3*M-1, prefer M*M+2*M+(M-1)*NB) 
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CUNGBR( 'P', M, M, M, WORK( IR ), LDWRKR,          &
                               WORK( ITAUP ), WORK( IWORK ),              &
                               LWORK-IWORK+1, IERR )                    
                  IRWORK = IE + M                                       
!                                                                       
!                 Perform bidiagonal QR iteration, computing right      
!                 singular vectors of L in WORK(IR)                     
!                 (CWorkspace: need M*M)                                
!                 (RWorkspace: need BDSPAC)                             
!                                                                       
                  CALL CSVD_CBDSQR( 'U', M, M, 0, 0, S, RWORK( IE ),           &
                               WORK( IR ), LDWRKR, CDUM, 1, CDUM, 1,      &
                               RWORK( IRWORK ), INFO )                  
                  IU = ITAUQ                                            
!                                                                       
!                 Multiply right singular vectors of L in WORK(IR) by Q 
!                 in A, storing result in WORK(IU) and copying to A     
!                 (CWorkspace: need M*M+M, prefer M*M+M*N)              
!                 (RWorkspace: 0)                                       
!                                                                       
                  DO 30 I = 1, N, CHUNK                                 
                     BLK = MIN( N-I+1, CHUNK )                          
                     CALL CSVD_CGEMM( 'N', 'N', M, BLK, M, CONE, WORK( IR ),   &
                                 LDWRKR, A( 1, I ), LDA, CZERO,           &
                                 WORK( IU ), LDWRKU )                   
                     CALL CSVD_CLACPY( 'F', M, BLK, WORK( IU ), LDWRKU,        &
                                  A( 1, I ), LDA )                      
   30             CONTINUE                                              
!                                                                       
               ELSE                                                     
!                                                                       
!                 Insufficient workspace for a fast algorithm           
!                                                                       
                  IE = 1                                                
                  ITAUQ = 1                                             
                  ITAUP = ITAUQ + M                                     
                  IWORK = ITAUP + M                                     
!                                                                       
!                 Bidiagonalize A                                       
!                 (CWorkspace: need 2*M+N, prefer 2*M+(M+N)*NB)         
!                 (RWorkspace: need M)                                  
!                                                                       
                  CALL CSVD_CGEBRD( M, N, A, LDA, S, RWORK( IE ),              &
                               WORK( ITAUQ ), WORK( ITAUP ),              &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
!                                                                       
!                 Generate right vectors bidiagonalizing A              
!                 (CWorkspace: need 3*M, prefer 2*M+M*NB)               
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CUNGBR( 'P', M, N, M, A, LDA, WORK( ITAUP ),       &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
                  IRWORK = IE + M                                       
!                                                                       
!                 Perform bidiagonal QR iteration, computing right      
!                 singular vectors of A in A                            
!                 (CWorkspace: 0)                                       
!                 (RWorkspace: need BDSPAC)                             
!                                                                       
                  CALL CSVD_CBDSQR( 'L', M, N, 0, 0, S, RWORK( IE ), A, LDA,   &
                               CDUM, 1, CDUM, 1, RWORK( IRWORK ), INFO )
!                                                                       
               END IF                                                   
!                                                                       
            ELSE IF( WNTVO .AND. WNTUAS ) THEN                          
!                                                                       
!              Path 3t(N much larger than M, JOBU='S' or 'A', JOBVT='O')
!              M right singular vectors to be overwritten on A and      
!              M left singular vectors to be computed in U              
!                                                                       
               IF( LWORK.GE.M*M+3*M ) THEN                              
!                                                                       
!                 Sufficient workspace for a fast algorithm             
!                                                                       
                  IR = 1                                                
                  IF( LWORK.GE.MAX( WRKBL, LDA*N )+LDA*M ) THEN         
!                                                                       
!                    WORK(IU) is LDA by N and WORK(IR) is LDA by M      
!                                                                       
                     LDWRKU = LDA                                       
                     CHUNK = N                                          
                     LDWRKR = LDA                                       
                  ELSE IF( LWORK.GE.MAX( WRKBL, LDA*N )+M*M ) THEN      
!                                                                       
!                    WORK(IU) is LDA by N and WORK(IR) is M by M        
!                                                                       
                     LDWRKU = LDA                                       
                     CHUNK = N                                          
                     LDWRKR = M                                         
                  ELSE                                                  
!                                                                       
!                    WORK(IU) is M by CHUNK and WORK(IR) is M by M      
!                                                                       
                     LDWRKU = M                                         
                     CHUNK = ( LWORK-M*M ) / M                          
                     LDWRKR = M                                         
                  END IF                                                
                  ITAU = IR + LDWRKR*M                                  
                  IWORK = ITAU + M                                      
!                                                                       
!                 Compute A=L*Q                                         
!                 (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)         
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CGELQF( M, N, A, LDA, WORK( ITAU ),                &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
!                                                                       
!                 Copy L to U, zeroing about above it                   
!                                                                       
                  CALL CSVD_CLACPY( 'L', M, M, A, LDA, U, LDU )              
                  CALL CSVD_CLASET( 'U', M-1, M-1, CZERO, CZERO, U( 1, 2 ),    &
                               LDU )                                    
!                                                                       
!                 Generate Q in A                                       
!                 (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)         
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CUNGLQ( M, N, M, A, LDA, WORK( ITAU ),             &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
                  IE = 1                                                
                  ITAUQ = ITAU                                          
                  ITAUP = ITAUQ + M                                     
                  IWORK = ITAUP + M                                     
!                                                                       
!                 Bidiagonalize L in U, copying result to WORK(IR)      
!                 (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)     
!                 (RWorkspace: need M)                                  
!                                                                       
                  CALL CSVD_CGEBRD( M, M, U, LDU, S, RWORK( IE ),              &
                               WORK( ITAUQ ), WORK( ITAUP ),              &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
                  CALL CSVD_CLACPY( 'U', M, M, U, LDU, WORK( IR ), LDWRKR )  
!                                                                       
!                 Generate right vectors bidiagonalizing L in WORK(IR)  
!                 (CWorkspace: need M*M+3*M-1, prefer M*M+2*M+(M-1)*NB) 
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CUNGBR( 'P', M, M, M, WORK( IR ), LDWRKR,          &
                               WORK( ITAUP ), WORK( IWORK ),              &
                               LWORK-IWORK+1, IERR )                    
!                                                                       
!                 Generate left vectors bidiagonalizing L in U          
!                 (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)       
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CUNGBR( 'Q', M, M, M, U, LDU, WORK( ITAUQ ),       &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
                  IRWORK = IE + M                                       
!                                                                       
!                 Perform bidiagonal QR iteration, computing left       
!                 singular vectors of L in U, and computing right       
!                 singular vectors of L in WORK(IR)                     
!                 (CWorkspace: need M*M)                                
!                 (RWorkspace: need BDSPAC)                             
!                                                                       
                  CALL CSVD_CBDSQR( 'U', M, M, M, 0, S, RWORK( IE ),           &
                               WORK( IR ), LDWRKR, U, LDU, CDUM, 1,       &
                               RWORK( IRWORK ), INFO )                  
                  IU = ITAUQ                                            
!                                                                       
!                 Multiply right singular vectors of L in WORK(IR) by Q 
!                 in A, storing result in WORK(IU) and copying to A     
!                 (CWorkspace: need M*M+M, prefer M*M+M*N))             
!                 (RWorkspace: 0)                                       
!                                                                       
                  DO 40 I = 1, N, CHUNK                                 
                     BLK = MIN( N-I+1, CHUNK )                          
                     CALL CSVD_CGEMM( 'N', 'N', M, BLK, M, CONE, WORK( IR ),   &
                                 LDWRKR, A( 1, I ), LDA, CZERO,           &
                                 WORK( IU ), LDWRKU )                   
                     CALL CSVD_CLACPY( 'F', M, BLK, WORK( IU ), LDWRKU,        &
                                  A( 1, I ), LDA )                      
   40             CONTINUE                                              
!                                                                       
               ELSE                                                     
!                                                                       
!                 Insufficient workspace for a fast algorithm           
!                                                                       
                  ITAU = 1                                              
                  IWORK = ITAU + M                                      
!                                                                       
!                 Compute A=L*Q                                         
!                 (CWorkspace: need 2*M, prefer M+M*NB)                 
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CGELQF( M, N, A, LDA, WORK( ITAU ),                &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
!                                                                       
!                 Copy L to U, zeroing out above it                     
!                                                                       
                  CALL CSVD_CLACPY( 'L', M, M, A, LDA, U, LDU )              
                  CALL CSVD_CLASET( 'U', M-1, M-1, CZERO, CZERO, U( 1, 2 ),    &
                               LDU )                                    
!                                                                       
!                 Generate Q in A                                       
!                 (CWorkspace: need 2*M, prefer M+M*NB)                 
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CUNGLQ( M, N, M, A, LDA, WORK( ITAU ),             &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
                  IE = 1                                                
                  ITAUQ = ITAU                                          
                  ITAUP = ITAUQ + M                                     
                  IWORK = ITAUP + M                                     
!                                                                       
!                 Bidiagonalize L in U                                  
!                 (CWorkspace: need 3*M, prefer 2*M+2*M*NB)             
!                 (RWorkspace: need M)                                  
!                                                                       
                  CALL CSVD_CGEBRD( M, M, U, LDU, S, RWORK( IE ),              &
                               WORK( ITAUQ ), WORK( ITAUP ),              &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
!                                                                       
!                 Multiply right vectors bidiagonalizing L by Q in A    
!                 (CWorkspace: need 2*M+N, prefer 2*M+N*NB)             
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CUNMBR( 'P', 'L', 'C', M, N, M, U, LDU,            &
                               WORK( ITAUP ), A, LDA, WORK( IWORK ),      &
                               LWORK-IWORK+1, IERR )                    
!                                                                       
!                 Generate left vectors bidiagonalizing L in U          
!                 (CWorkspace: need 3*M, prefer 2*M+M*NB)               
!                 (RWorkspace: 0)                                       
!                                                                       
                  CALL CSVD_CUNGBR( 'Q', M, M, M, U, LDU, WORK( ITAUQ ),       &
                               WORK( IWORK ), LWORK-IWORK+1, IERR )     
                  IRWORK = IE + M                                       
!                                                                       
!                 Perform bidiagonal QR iteration, computing left       
!                 singular vectors of A in U and computing right        
!                 singular vectors of A in A                            
!                 (CWorkspace: 0)                                       
!                 (RWorkspace: need BDSPAC)                             
!                                                                       
                  CALL CSVD_CBDSQR( 'U', M, N, M, 0, S, RWORK( IE ), A, LDA,   &
                               U, LDU, CDUM, 1, RWORK( IRWORK ), INFO ) 
!                                                                       
               END IF                                                   
!                                                                       
            ELSE IF( WNTVS ) THEN                                       
!                                                                       
               IF( WNTUN ) THEN                                         
!                                                                       
!                 Path 4t(N much larger than M, JOBU='N', JOBVT='S')    
!                 M right singular vectors to be computed in VT and     
!                 no left singular vectors to be computed               
!                                                                       
                  IF( LWORK.GE.M*M+3*M ) THEN                           
!                                                                       
!                    Sufficient workspace for a fast algorithm          
!                                                                       
                     IR = 1                                             
                     IF( LWORK.GE.WRKBL+LDA*M ) THEN                    
!                                                                       
!                       WORK(IR) is LDA by M                            
!                                                                       
                        LDWRKR = LDA                                    
                     ELSE                                               
!                                                                       
!                       WORK(IR) is M by M                              
!                                                                       
                        LDWRKR = M                                      
                     END IF                                             
                     ITAU = IR + LDWRKR*M                               
                     IWORK = ITAU + M                                   
!                                                                       
!                    Compute A=L*Q                                      
!                    (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)      
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGELQF( M, N, A, LDA, WORK( ITAU ),             &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Copy L to WORK(IR), zeroing out above it           
!                                                                       
                     CALL CSVD_CLACPY( 'L', M, M, A, LDA, WORK( IR ),          &
                                  LDWRKR )                              
                     CALL CSVD_CLASET( 'U', M-1, M-1, CZERO, CZERO,            &
                                  WORK( IR+LDWRKR ), LDWRKR )           
!                                                                       
!                    Generate Q in A                                    
!                    (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)      
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGLQ( M, N, M, A, LDA, WORK( ITAU ),          &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + M                                  
                     IWORK = ITAUP + M                                  
!                                                                       
!                    Bidiagonalize L in WORK(IR)                        
!                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)  
!                    (RWorkspace: need M)                               
!                                                                       
                     CALL CSVD_CGEBRD( M, M, WORK( IR ), LDWRKR, S,            &
                                  RWORK( IE ), WORK( ITAUQ ),             &
                                  WORK( ITAUP ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
!                                                                       
!                    Generate right vectors bidiagonalizing L in        
!                    WORK(IR)                                           
!                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+(M-1)*NB)
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'P', M, M, M, WORK( IR ), LDWRKR,       &
                                  WORK( ITAUP ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
                     IRWORK = IE + M                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing right   
!                    singular vectors of L in WORK(IR)                  
!                    (CWorkspace: need M*M)                             
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', M, M, 0, 0, S, RWORK( IE ),        &
                                  WORK( IR ), LDWRKR, CDUM, 1, CDUM, 1,   &
                                  RWORK( IRWORK ), INFO )               
!                                                                       
!                    Multiply right singular vectors of L in WORK(IR) by
!                    Q in A, storing result in VT                       
!                    (CWorkspace: need M*M)                             
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEMM( 'N', 'N', M, N, M, CONE, WORK( IR ),     &
                                 LDWRKR, A, LDA, CZERO, VT, LDVT )      
!                                                                       
                  ELSE                                                  
!                                                                       
!                    Insufficient workspace for a fast algorithm        
!                                                                       
                     ITAU = 1                                           
                     IWORK = ITAU + M                                   
!                                                                       
!                    Compute A=L*Q                                      
!                    (CWorkspace: need 2*M, prefer M+M*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGELQF( M, N, A, LDA, WORK( ITAU ),             &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Copy result to VT                                  
!                                                                       
                     CALL CSVD_CLACPY( 'U', M, N, A, LDA, VT, LDVT )         
!                                                                       
!                    Generate Q in VT                                   
!                    (CWorkspace: need 2*M, prefer M+M*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGLQ( M, N, M, VT, LDVT, WORK( ITAU ),        &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + M                                  
                     IWORK = ITAUP + M                                  
!                                                                       
!                    Zero out above L in A                              
!                                                                       
                     CALL CSVD_CLASET( 'U', M-1, M-1, CZERO, CZERO,            &
                                  A( 1, 2 ), LDA )                      
!                                                                       
!                    Bidiagonalize L in A                               
!                    (CWorkspace: need 3*M, prefer 2*M+2*M*NB)          
!                    (RWorkspace: need M)                               
!                                                                       
                     CALL CSVD_CGEBRD( M, M, A, LDA, S, RWORK( IE ),           &
                                  WORK( ITAUQ ), WORK( ITAUP ),           &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Multiply right vectors bidiagonalizing L by Q in VT
!                    (CWorkspace: need 2*M+N, prefer 2*M+N*NB)          
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNMBR( 'P', 'L', 'C', M, N, M, A, LDA,         &
                                  WORK( ITAUP ), VT, LDVT,                &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IRWORK = IE + M                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing right   
!                    singular vectors of A in VT                        
!                    (CWorkspace: 0)                                    
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', M, N, 0, 0, S, RWORK( IE ), VT,    &
                                  LDVT, CDUM, 1, CDUM, 1,                 &
                                  RWORK( IRWORK ), INFO )               
!                                                                       
                  END IF                                                
!                                                                       
               ELSE IF( WNTUO ) THEN                                    
!                                                                       
!                 Path 5t(N much larger than M, JOBU='O', JOBVT='S')    
!                 M right singular vectors to be computed in VT and     
!                 M left singular vectors to be overwritten on A        
!                                                                       
                  IF( LWORK.GE.2*M*M+3*M ) THEN                         
!                                                                       
!                    Sufficient workspace for a fast algorithm          
!                                                                       
                     IU = 1                                             
                     IF( LWORK.GE.WRKBL+2*LDA*M ) THEN                  
!                                                                       
!                       WORK(IU) is LDA by M and WORK(IR) is LDA by M   
!                                                                       
                        LDWRKU = LDA                                    
                        IR = IU + LDWRKU*M                              
                        LDWRKR = LDA                                    
                     ELSE IF( LWORK.GE.WRKBL+( LDA+M )*M ) THEN         
!                                                                       
!                       WORK(IU) is LDA by M and WORK(IR) is M by M     
!                                                                       
                        LDWRKU = LDA                                    
                        IR = IU + LDWRKU*M                              
                        LDWRKR = M                                      
                     ELSE                                               
!                                                                       
!                       WORK(IU) is M by M and WORK(IR) is M by M       
!                                                                       
                        LDWRKU = M                                      
                        IR = IU + LDWRKU*M                              
                        LDWRKR = M                                      
                     END IF                                             
                     ITAU = IR + LDWRKR*M                               
                     IWORK = ITAU + M                                   
!                                                                       
!                    Compute A=L*Q                                      
!                    (CWorkspace: need 2*M*M+2*M, prefer 2*M*M+M+M*NB)  
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGELQF( M, N, A, LDA, WORK( ITAU ),             &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Copy L to WORK(IU), zeroing out below it           
!                                                                       
                     CALL CSVD_CLACPY( 'L', M, M, A, LDA, WORK( IU ),          &
                                  LDWRKU )                              
                     CALL CSVD_CLASET( 'U', M-1, M-1, CZERO, CZERO,            &
                                  WORK( IU+LDWRKU ), LDWRKU )           
!                                                                       
!                    Generate Q in A                                    
!                    (CWorkspace: need 2*M*M+2*M, prefer 2*M*M+M+M*NB)  
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGLQ( M, N, M, A, LDA, WORK( ITAU ),          &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + M                                  
                     IWORK = ITAUP + M                                  
!                                                                       
!                    Bidiagonalize L in WORK(IU), copying result to     
!                    WORK(IR)                                           
!                    (CWorkspace: need   2*M*M+3*M,                     
!                                 prefer 2*M*M+2*M+2*M*NB)              
!                    (RWorkspace: need   M)                             
!                                                                       
                     CALL CSVD_CGEBRD( M, M, WORK( IU ), LDWRKU, S,            &
                                  RWORK( IE ), WORK( ITAUQ ),             &
                                  WORK( ITAUP ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
                     CALL CSVD_CLACPY( 'L', M, M, WORK( IU ), LDWRKU,          &
                                  WORK( IR ), LDWRKR )                  
!                                                                       
!                    Generate right bidiagonalizing vectors in WORK(IU) 
!                    (CWorkspace: need   2*M*M+3*M-1,                   
!                                 prefer 2*M*M+2*M+(M-1)*NB)            
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'P', M, M, M, WORK( IU ), LDWRKU,       &
                                  WORK( ITAUP ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
!                                                                       
!                    Generate left bidiagonalizing vectors in WORK(IR)  
!                    (CWorkspace: need 2*M*M+3*M, prefer 2*M*M+2*M+M*NB)
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'Q', M, M, M, WORK( IR ), LDWRKR,       &
                                  WORK( ITAUQ ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
                     IRWORK = IE + M                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing left    
!                    singular vectors of L in WORK(IR) and computing    
!                    right singular vectors of L in WORK(IU)            
!                    (CWorkspace: need 2*M*M)                           
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', M, M, M, 0, S, RWORK( IE ),        &
                                  WORK( IU ), LDWRKU, WORK( IR ),         &
                                  LDWRKR, CDUM, 1, RWORK( IRWORK ),       &
                                  INFO )                                
!                                                                       
!                    Multiply right singular vectors of L in WORK(IU) by
!                    Q in A, storing result in VT                       
!                    (CWorkspace: need M*M)                             
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEMM( 'N', 'N', M, N, M, CONE, WORK( IU ),     &
                                 LDWRKU, A, LDA, CZERO, VT, LDVT )      
!                                                                       
!                    Copy left singular vectors of L to A               
!                    (CWorkspace: need M*M)                             
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CLACPY( 'F', M, M, WORK( IR ), LDWRKR, A,       &
                                  LDA )                                 
!                                                                       
                  ELSE                                                  
!                                                                       
!                    Insufficient workspace for a fast algorithm        
!                                                                       
                     ITAU = 1                                           
                     IWORK = ITAU + M                                   
!                                                                       
!                    Compute A=L*Q, copying result to VT                
!                    (CWorkspace: need 2*M, prefer M+M*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGELQF( M, N, A, LDA, WORK( ITAU ),             &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     CALL CSVD_CLACPY( 'U', M, N, A, LDA, VT, LDVT )         
!                                                                       
!                    Generate Q in VT                                   
!                    (CWorkspace: need 2*M, prefer M+M*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGLQ( M, N, M, VT, LDVT, WORK( ITAU ),        &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + M                                  
                     IWORK = ITAUP + M                                  
!                                                                       
!                    Zero out above L in A                              
!                                                                       
                     CALL CSVD_CLASET( 'U', M-1, M-1, CZERO, CZERO,            &
                                  A( 1, 2 ), LDA )                      
!                                                                       
!                    Bidiagonalize L in A                               
!                    (CWorkspace: need 3*M, prefer 2*M+2*M*NB)          
!                    (RWorkspace: need M)                               
!                                                                       
                     CALL CSVD_CGEBRD( M, M, A, LDA, S, RWORK( IE ),           &
                                  WORK( ITAUQ ), WORK( ITAUP ),           &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Multiply right vectors bidiagonalizing L by Q in VT
!                    (CWorkspace: need 2*M+N, prefer 2*M+N*NB)          
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNMBR( 'P', 'L', 'C', M, N, M, A, LDA,         &
                                  WORK( ITAUP ), VT, LDVT,                &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Generate left bidiagonalizing vectors of L in A    
!                    (CWorkspace: need 3*M, prefer 2*M+M*NB)            
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'Q', M, M, M, A, LDA, WORK( ITAUQ ),    &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IRWORK = IE + M                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing left    
!                    singular vectors of A in A and computing right     
!                    singular vectors of A in VT                        
!                    (CWorkspace: 0)                                    
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', M, N, M, 0, S, RWORK( IE ), VT,    &
                                  LDVT, A, LDA, CDUM, 1,                  &
                                  RWORK( IRWORK ), INFO )               
!                                                                       
                  END IF                                                
!                                                                       
               ELSE IF( WNTUAS ) THEN                                   
!                                                                       
!                 Path 6t(N much larger than M, JOBU='S' or 'A',        
!                         JOBVT='S')                                    
!                 M right singular vectors to be computed in VT and     
!                 M left singular vectors to be computed in U           
!                                                                       
                  IF( LWORK.GE.M*M+3*M ) THEN                           
!                                                                       
!                    Sufficient workspace for a fast algorithm          
!                                                                       
                     IU = 1                                             
                     IF( LWORK.GE.WRKBL+LDA*M ) THEN                    
!                                                                       
!                       WORK(IU) is LDA by N                            
!                                                                       
                        LDWRKU = LDA                                    
                     ELSE                                               
!                                                                       
!                       WORK(IU) is LDA by M                            
!                                                                       
                        LDWRKU = M                                      
                     END IF                                             
                     ITAU = IU + LDWRKU*M                               
                     IWORK = ITAU + M                                   
!                                                                       
!                    Compute A=L*Q                                      
!                    (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)      
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGELQF( M, N, A, LDA, WORK( ITAU ),             &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Copy L to WORK(IU), zeroing out above it           
!                                                                       
                     CALL CSVD_CLACPY( 'L', M, M, A, LDA, WORK( IU ),          &
                                  LDWRKU )                              
                     CALL CSVD_CLASET( 'U', M-1, M-1, CZERO, CZERO,            &
                                  WORK( IU+LDWRKU ), LDWRKU )           
!                                                                       
!                    Generate Q in A                                    
!                    (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)      
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGLQ( M, N, M, A, LDA, WORK( ITAU ),          &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + M                                  
                     IWORK = ITAUP + M                                  
!                                                                       
!                    Bidiagonalize L in WORK(IU), copying result to U   
!                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)  
!                    (RWorkspace: need M)                               
!                                                                       
                     CALL CSVD_CGEBRD( M, M, WORK( IU ), LDWRKU, S,            &
                                  RWORK( IE ), WORK( ITAUQ ),             &
                                  WORK( ITAUP ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
                     CALL CSVD_CLACPY( 'L', M, M, WORK( IU ), LDWRKU, U,       &
                                  LDU )                                 
!                                                                       
!                    Generate right bidiagonalizing vectors in WORK(IU) 
!                    (CWorkspace: need   M*M+3*M-1,                     
!                                 prefer M*M+2*M+(M-1)*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'P', M, M, M, WORK( IU ), LDWRKU,       &
                                  WORK( ITAUP ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
!                                                                       
!                    Generate left bidiagonalizing vectors in U         
!                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)    
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'Q', M, M, M, U, LDU, WORK( ITAUQ ),    &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IRWORK = IE + M                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing left    
!                    singular vectors of L in U and computing right     
!                    singular vectors of L in WORK(IU)                  
!                    (CWorkspace: need M*M)                             
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', M, M, M, 0, S, RWORK( IE ),        &
                                  WORK( IU ), LDWRKU, U, LDU, CDUM, 1,    &
                                  RWORK( IRWORK ), INFO )               
!                                                                       
!                    Multiply right singular vectors of L in WORK(IU) by
!                    Q in A, storing result in VT                       
!                    (CWorkspace: need M*M)                             
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEMM( 'N', 'N', M, N, M, CONE, WORK( IU ),     &
                                 LDWRKU, A, LDA, CZERO, VT, LDVT )      
!                                                                       
                  ELSE                                                  
!                                                                       
!                    Insufficient workspace for a fast algorithm        
!                                                                       
                     ITAU = 1                                           
                     IWORK = ITAU + M                                   
!                                                                       
!                    Compute A=L*Q, copying result to VT                
!                    (CWorkspace: need 2*M, prefer M+M*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGELQF( M, N, A, LDA, WORK( ITAU ),             &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     CALL CSVD_CLACPY( 'U', M, N, A, LDA, VT, LDVT )         
!                                                                       
!                    Generate Q in VT                                   
!                    (CWorkspace: need 2*M, prefer M+M*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGLQ( M, N, M, VT, LDVT, WORK( ITAU ),        &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Copy L to U, zeroing out above it                  
!                                                                       
                     CALL CSVD_CLACPY( 'L', M, M, A, LDA, U, LDU )           
                     CALL CSVD_CLASET( 'U', M-1, M-1, CZERO, CZERO,            &
                                  U( 1, 2 ), LDU )                      
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + M                                  
                     IWORK = ITAUP + M                                  
!                                                                       
!                    Bidiagonalize L in U                               
!                    (CWorkspace: need 3*M, prefer 2*M+2*M*NB)          
!                    (RWorkspace: need M)                               
!                                                                       
                     CALL CSVD_CGEBRD( M, M, U, LDU, S, RWORK( IE ),           &
                                  WORK( ITAUQ ), WORK( ITAUP ),           &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Multiply right bidiagonalizing vectors in U by Q   
!                    in VT                                              
!                    (CWorkspace: need 2*M+N, prefer 2*M+N*NB)          
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNMBR( 'P', 'L', 'C', M, N, M, U, LDU,         &
                                  WORK( ITAUP ), VT, LDVT,                &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Generate left bidiagonalizing vectors in U         
!                    (CWorkspace: need 3*M, prefer 2*M+M*NB)            
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'Q', M, M, M, U, LDU, WORK( ITAUQ ),    &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IRWORK = IE + M                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing left    
!                    singular vectors of A in U and computing right     
!                    singular vectors of A in VT                        
!                    (CWorkspace: 0)                                    
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', M, N, M, 0, S, RWORK( IE ), VT,    &
                                  LDVT, U, LDU, CDUM, 1,                  &
                                  RWORK( IRWORK ), INFO )               
!                                                                       
                  END IF                                                
!                                                                       
               END IF                                                   
!                                                                       
            ELSE IF( WNTVA ) THEN                                       
!                                                                       
               IF( WNTUN ) THEN                                         
!                                                                       
!                 Path 7t(N much larger than M, JOBU='N', JOBVT='A')    
!                 N right singular vectors to be computed in VT and     
!                 no left singular vectors to be computed               
!                                                                       
                  IF( LWORK.GE.M*M+MAX( N+M, 3*M ) ) THEN               
!                                                                       
!                    Sufficient workspace for a fast algorithm          
!                                                                       
                     IR = 1                                             
                     IF( LWORK.GE.WRKBL+LDA*M ) THEN                    
!                                                                       
!                       WORK(IR) is LDA by M                            
!                                                                       
                        LDWRKR = LDA                                    
                     ELSE                                               
!                                                                       
!                       WORK(IR) is M by M                              
!                                                                       
                        LDWRKR = M                                      
                     END IF                                             
                     ITAU = IR + LDWRKR*M                               
                     IWORK = ITAU + M                                   
!                                                                       
!                    Compute A=L*Q, copying result to VT                
!                    (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)      
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGELQF( M, N, A, LDA, WORK( ITAU ),             &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     CALL CSVD_CLACPY( 'U', M, N, A, LDA, VT, LDVT )         
!                                                                       
!                    Copy L to WORK(IR), zeroing out above it           
!                                                                       
                     CALL CSVD_CLACPY( 'L', M, M, A, LDA, WORK( IR ),          &
                                  LDWRKR )                              
                     CALL CSVD_CLASET( 'U', M-1, M-1, CZERO, CZERO,            &
                                  WORK( IR+LDWRKR ), LDWRKR )           
!                                                                       
!                    Generate Q in VT                                   
!                    (CWorkspace: need M*M+M+N, prefer M*M+M+N*NB)      
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGLQ( N, N, M, VT, LDVT, WORK( ITAU ),        &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + M                                  
                     IWORK = ITAUP + M                                  
!                                                                       
!                    Bidiagonalize L in WORK(IR)                        
!                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)  
!                    (RWorkspace: need M)                               
!                                                                       
                     CALL CSVD_CGEBRD( M, M, WORK( IR ), LDWRKR, S,            &
                                  RWORK( IE ), WORK( ITAUQ ),             &
                                  WORK( ITAUP ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
!                                                                       
!                    Generate right bidiagonalizing vectors in WORK(IR) 
!                    (CWorkspace: need   M*M+3*M-1,                     
!                                 prefer M*M+2*M+(M-1)*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'P', M, M, M, WORK( IR ), LDWRKR,       &
                                  WORK( ITAUP ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
                     IRWORK = IE + M                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing right   
!                    singular vectors of L in WORK(IR)                  
!                    (CWorkspace: need M*M)                             
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', M, M, 0, 0, S, RWORK( IE ),        &
                                  WORK( IR ), LDWRKR, CDUM, 1, CDUM, 1,   &
                                  RWORK( IRWORK ), INFO )               
!                                                                       
!                    Multiply right singular vectors of L in WORK(IR) by
!                    Q in VT, storing result in A                       
!                    (CWorkspace: need M*M)                             
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEMM( 'N', 'N', M, N, M, CONE, WORK( IR ),     &
                                 LDWRKR, VT, LDVT, CZERO, A, LDA )      
!                                                                       
!                    Copy right singular vectors of A from A to VT      
!                                                                       
                     CALL CSVD_CLACPY( 'F', M, N, A, LDA, VT, LDVT )         
!                                                                       
                  ELSE                                                  
!                                                                       
!                    Insufficient workspace for a fast algorithm        
!                                                                       
                     ITAU = 1                                           
                     IWORK = ITAU + M                                   
!                                                                       
!                    Compute A=L*Q, copying result to VT                
!                    (CWorkspace: need 2*M, prefer M+M*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGELQF( M, N, A, LDA, WORK( ITAU ),             &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     CALL CSVD_CLACPY( 'U', M, N, A, LDA, VT, LDVT )         
!                                                                       
!                    Generate Q in VT                                   
!                    (CWorkspace: need M+N, prefer M+N*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGLQ( N, N, M, VT, LDVT, WORK( ITAU ),        &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + M                                  
                     IWORK = ITAUP + M                                  
!                                                                       
!                    Zero out above L in A                              
!                                                                       
                     CALL CSVD_CLASET( 'U', M-1, M-1, CZERO, CZERO,            &
                                  A( 1, 2 ), LDA )                      
!                                                                       
!                    Bidiagonalize L in A                               
!                    (CWorkspace: need 3*M, prefer 2*M+2*M*NB)          
!                    (RWorkspace: need M)                               
!                                                                       
                     CALL CSVD_CGEBRD( M, M, A, LDA, S, RWORK( IE ),           &
                                  WORK( ITAUQ ), WORK( ITAUP ),           &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Multiply right bidiagonalizing vectors in A by Q   
!                    in VT                                              
!                    (CWorkspace: need 2*M+N, prefer 2*M+N*NB)          
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNMBR( 'P', 'L', 'C', M, N, M, A, LDA,         &
                                  WORK( ITAUP ), VT, LDVT,                &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IRWORK = IE + M                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing right   
!                    singular vectors of A in VT                        
!                    (CWorkspace: 0)                                    
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', M, N, 0, 0, S, RWORK( IE ), VT,    &
                                  LDVT, CDUM, 1, CDUM, 1,                 &
                                  RWORK( IRWORK ), INFO )               
!                                                                       
                  END IF                                                
!                                                                       
               ELSE IF( WNTUO ) THEN                                    
!                                                                       
!                 Path 8t(N much larger than M, JOBU='O', JOBVT='A')    
!                 N right singular vectors to be computed in VT and     
!                 M left singular vectors to be overwritten on A        
!                                                                       
                  IF( LWORK.GE.2*M*M+MAX( N+M, 3*M ) ) THEN             
!                                                                       
!                    Sufficient workspace for a fast algorithm          
!                                                                       
                     IU = 1                                             
                     IF( LWORK.GE.WRKBL+2*LDA*M ) THEN                  
!                                                                       
!                       WORK(IU) is LDA by M and WORK(IR) is LDA by M   
!                                                                       
                        LDWRKU = LDA                                    
                        IR = IU + LDWRKU*M                              
                        LDWRKR = LDA                                    
                     ELSE IF( LWORK.GE.WRKBL+( LDA+M )*M ) THEN         
!                                                                       
!                       WORK(IU) is LDA by M and WORK(IR) is M by M     
!                                                                       
                        LDWRKU = LDA                                    
                        IR = IU + LDWRKU*M                              
                        LDWRKR = M                                      
                     ELSE                                               
!                                                                       
!                       WORK(IU) is M by M and WORK(IR) is M by M       
!                                                                       
                        LDWRKU = M                                      
                        IR = IU + LDWRKU*M                              
                        LDWRKR = M                                      
                     END IF                                             
                     ITAU = IR + LDWRKR*M                               
                     IWORK = ITAU + M                                   
!                                                                       
!                    Compute A=L*Q, copying result to VT                
!                    (CWorkspace: need 2*M*M+2*M, prefer 2*M*M+M+M*NB)  
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGELQF( M, N, A, LDA, WORK( ITAU ),             &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     CALL CSVD_CLACPY( 'U', M, N, A, LDA, VT, LDVT )         
!                                                                       
!                    Generate Q in VT                                   
!                    (CWorkspace: need 2*M*M+M+N, prefer 2*M*M+M+N*NB)  
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGLQ( N, N, M, VT, LDVT, WORK( ITAU ),        &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Copy L to WORK(IU), zeroing out above it           
!                                                                       
                     CALL CSVD_CLACPY( 'L', M, M, A, LDA, WORK( IU ),          &
                                  LDWRKU )                              
                     CALL CSVD_CLASET( 'U', M-1, M-1, CZERO, CZERO,            &
                                  WORK( IU+LDWRKU ), LDWRKU )           
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + M                                  
                     IWORK = ITAUP + M                                  
!                                                                       
!                    Bidiagonalize L in WORK(IU), copying result to     
!                    WORK(IR)                                           
!                    (CWorkspace: need   2*M*M+3*M,                     
!                                 prefer 2*M*M+2*M+2*M*NB)              
!                    (RWorkspace: need   M)                             
!                                                                       
                     CALL CSVD_CGEBRD( M, M, WORK( IU ), LDWRKU, S,            &
                                  RWORK( IE ), WORK( ITAUQ ),             &
                                  WORK( ITAUP ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
                     CALL CSVD_CLACPY( 'L', M, M, WORK( IU ), LDWRKU,          &
                                  WORK( IR ), LDWRKR )                  
!                                                                       
!                    Generate right bidiagonalizing vectors in WORK(IU) 
!                    (CWorkspace: need   2*M*M+3*M-1,                   
!                                 prefer 2*M*M+2*M+(M-1)*NB)            
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'P', M, M, M, WORK( IU ), LDWRKU,       &
                                  WORK( ITAUP ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
!                                                                       
!                    Generate left bidiagonalizing vectors in WORK(IR)  
!                    (CWorkspace: need 2*M*M+3*M, prefer 2*M*M+2*M+M*NB)
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'Q', M, M, M, WORK( IR ), LDWRKR,       &
                                  WORK( ITAUQ ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
                     IRWORK = IE + M                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing left    
!                    singular vectors of L in WORK(IR) and computing    
!                    right singular vectors of L in WORK(IU)            
!                    (CWorkspace: need 2*M*M)                           
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', M, M, M, 0, S, RWORK( IE ),        &
                                  WORK( IU ), LDWRKU, WORK( IR ),         &
                                  LDWRKR, CDUM, 1, RWORK( IRWORK ),       &
                                  INFO )                                
!                                                                       
!                    Multiply right singular vectors of L in WORK(IU) by
!                    Q in VT, storing result in A                       
!                    (CWorkspace: need M*M)                             
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEMM( 'N', 'N', M, N, M, CONE, WORK( IU ),     &
                                 LDWRKU, VT, LDVT, CZERO, A, LDA )      
!                                                                       
!                    Copy right singular vectors of A from A to VT      
!                                                                       
                     CALL CSVD_CLACPY( 'F', M, N, A, LDA, VT, LDVT )         
!                                                                       
!                    Copy left singular vectors of A from WORK(IR) to A 
!                                                                       
                     CALL CSVD_CLACPY( 'F', M, M, WORK( IR ), LDWRKR, A,       &
                                  LDA )                                 
!                                                                       
                  ELSE                                                  
!                                                                       
!                    Insufficient workspace for a fast algorithm        
!                                                                       
                     ITAU = 1                                           
                     IWORK = ITAU + M                                   
!                                                                       
!                    Compute A=L*Q, copying result to VT                
!                    (CWorkspace: need 2*M, prefer M+M*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGELQF( M, N, A, LDA, WORK( ITAU ),             &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     CALL CSVD_CLACPY( 'U', M, N, A, LDA, VT, LDVT )         
!                                                                       
!                    Generate Q in VT                                   
!                    (CWorkspace: need M+N, prefer M+N*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGLQ( N, N, M, VT, LDVT, WORK( ITAU ),        &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + M                                  
                     IWORK = ITAUP + M                                  
!                                                                       
!                    Zero out above L in A                              
!                                                                       
                     CALL CSVD_CLASET( 'U', M-1, M-1, CZERO, CZERO,            &
                                  A( 1, 2 ), LDA )                      
!                                                                       
!                    Bidiagonalize L in A                               
!                    (CWorkspace: need 3*M, prefer 2*M+2*M*NB)          
!                    (RWorkspace: need M)                               
!                                                                       
                     CALL CSVD_CGEBRD( M, M, A, LDA, S, RWORK( IE ),           &
                                  WORK( ITAUQ ), WORK( ITAUP ),           &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Multiply right bidiagonalizing vectors in A by Q   
!                    in VT                                              
!                    (CWorkspace: need 2*M+N, prefer 2*M+N*NB)          
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNMBR( 'P', 'L', 'C', M, N, M, A, LDA,         &
                                  WORK( ITAUP ), VT, LDVT,                &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Generate left bidiagonalizing vectors in A         
!                    (CWorkspace: need 3*M, prefer 2*M+M*NB)            
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'Q', M, M, M, A, LDA, WORK( ITAUQ ),    &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IRWORK = IE + M                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing left    
!                    singular vectors of A in A and computing right     
!                    singular vectors of A in VT                        
!                    (CWorkspace: 0)                                    
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', M, N, M, 0, S, RWORK( IE ), VT,    &
                                  LDVT, A, LDA, CDUM, 1,                  &
                                  RWORK( IRWORK ), INFO )               
!                                                                       
                  END IF                                                
!                                                                       
               ELSE IF( WNTUAS ) THEN                                   
!                                                                       
!                 Path 9t(N much larger than M, JOBU='S' or 'A',        
!                         JOBVT='A')                                    
!                 N right singular vectors to be computed in VT and     
!                 M left singular vectors to be computed in U           
!                                                                       
                  IF( LWORK.GE.M*M+MAX( N+M, 3*M ) ) THEN               
!                                                                       
!                    Sufficient workspace for a fast algorithm          
!                                                                       
                     IU = 1                                             
                     IF( LWORK.GE.WRKBL+LDA*M ) THEN                    
!                                                                       
!                       WORK(IU) is LDA by M                            
!                                                                       
                        LDWRKU = LDA                                    
                     ELSE                                               
!                                                                       
!                       WORK(IU) is M by M                              
!                                                                       
                        LDWRKU = M                                      
                     END IF                                             
                     ITAU = IU + LDWRKU*M                               
                     IWORK = ITAU + M                                   
!                                                                       
!                    Compute A=L*Q, copying result to VT                
!                    (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)      
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGELQF( M, N, A, LDA, WORK( ITAU ),             &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     CALL CSVD_CLACPY( 'U', M, N, A, LDA, VT, LDVT )         
!                                                                       
!                    Generate Q in VT                                   
!                    (CWorkspace: need M*M+M+N, prefer M*M+M+N*NB)      
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGLQ( N, N, M, VT, LDVT, WORK( ITAU ),        &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Copy L to WORK(IU), zeroing out above it           
!                                                                       
                     CALL CSVD_CLACPY( 'L', M, M, A, LDA, WORK( IU ),          &
                                  LDWRKU )                              
                     CALL CSVD_CLASET( 'U', M-1, M-1, CZERO, CZERO,            &
                                  WORK( IU+LDWRKU ), LDWRKU )           
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + M                                  
                     IWORK = ITAUP + M                                  
!                                                                       
!                    Bidiagonalize L in WORK(IU), copying result to U   
!                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)  
!                    (RWorkspace: need M)                               
!                                                                       
                     CALL CSVD_CGEBRD( M, M, WORK( IU ), LDWRKU, S,            &
                                  RWORK( IE ), WORK( ITAUQ ),             &
                                  WORK( ITAUP ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
                     CALL CSVD_CLACPY( 'L', M, M, WORK( IU ), LDWRKU, U,       &
                                  LDU )                                 
!                                                                       
!                    Generate right bidiagonalizing vectors in WORK(IU) 
!                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+(M-1)*NB)
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'P', M, M, M, WORK( IU ), LDWRKU,       &
                                  WORK( ITAUP ), WORK( IWORK ),           &
                                  LWORK-IWORK+1, IERR )                 
!                                                                       
!                    Generate left bidiagonalizing vectors in U         
!                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)    
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'Q', M, M, M, U, LDU, WORK( ITAUQ ),    &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IRWORK = IE + M                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing left    
!                    singular vectors of L in U and computing right     
!                    singular vectors of L in WORK(IU)                  
!                    (CWorkspace: need M*M)                             
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', M, M, M, 0, S, RWORK( IE ),        &
                                  WORK( IU ), LDWRKU, U, LDU, CDUM, 1,    &
                                  RWORK( IRWORK ), INFO )               
!                                                                       
!                    Multiply right singular vectors of L in WORK(IU) by
!                    Q in VT, storing result in A                       
!                    (CWorkspace: need M*M)                             
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGEMM( 'N', 'N', M, N, M, CONE, WORK( IU ),     &
                                 LDWRKU, VT, LDVT, CZERO, A, LDA )      
!                                                                       
!                    Copy right singular vectors of A from A to VT      
!                                                                       
                     CALL CSVD_CLACPY( 'F', M, N, A, LDA, VT, LDVT )         
!                                                                       
                  ELSE                                                  
!                                                                       
!                    Insufficient workspace for a fast algorithm        
!                                                                       
                     ITAU = 1                                           
                     IWORK = ITAU + M                                   
!                                                                       
!                    Compute A=L*Q, copying result to VT                
!                    (CWorkspace: need 2*M, prefer M+M*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CGELQF( M, N, A, LDA, WORK( ITAU ),             &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     CALL CSVD_CLACPY( 'U', M, N, A, LDA, VT, LDVT )         
!                                                                       
!                    Generate Q in VT                                   
!                    (CWorkspace: need M+N, prefer M+N*NB)              
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGLQ( N, N, M, VT, LDVT, WORK( ITAU ),        &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Copy L to U, zeroing out above it                  
!                                                                       
                     CALL CSVD_CLACPY( 'L', M, M, A, LDA, U, LDU )           
                     CALL CSVD_CLASET( 'U', M-1, M-1, CZERO, CZERO,            &
                                  U( 1, 2 ), LDU )                      
                     IE = 1                                             
                     ITAUQ = ITAU                                       
                     ITAUP = ITAUQ + M                                  
                     IWORK = ITAUP + M                                  
!                                                                       
!                    Bidiagonalize L in U                               
!                    (CWorkspace: need 3*M, prefer 2*M+2*M*NB)          
!                    (RWorkspace: need M)                               
!                                                                       
                     CALL CSVD_CGEBRD( M, M, U, LDU, S, RWORK( IE ),           &
                                  WORK( ITAUQ ), WORK( ITAUP ),           &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Multiply right bidiagonalizing vectors in U by Q   
!                    in VT                                              
!                    (CWorkspace: need 2*M+N, prefer 2*M+N*NB)          
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNMBR( 'P', 'L', 'C', M, N, M, U, LDU,         &
                                  WORK( ITAUP ), VT, LDVT,                &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
!                                                                       
!                    Generate left bidiagonalizing vectors in U         
!                    (CWorkspace: need 3*M, prefer 2*M+M*NB)            
!                    (RWorkspace: 0)                                    
!                                                                       
                     CALL CSVD_CUNGBR( 'Q', M, M, M, U, LDU, WORK( ITAUQ ),    &
                                  WORK( IWORK ), LWORK-IWORK+1, IERR )  
                     IRWORK = IE + M                                    
!                                                                       
!                    Perform bidiagonal QR iteration, computing left    
!                    singular vectors of A in U and computing right     
!                    singular vectors of A in VT                        
!                    (CWorkspace: 0)                                    
!                    (RWorkspace: need BDSPAC)                          
!                                                                       
                     CALL CSVD_CBDSQR( 'U', M, N, M, 0, S, RWORK( IE ), VT,    &
                                  LDVT, U, LDU, CDUM, 1,                  &
                                  RWORK( IRWORK ), INFO )               
!                                                                       
                  END IF                                                
!                                                                       
               END IF                                                   
!                                                                       
            END IF                                                      
!                                                                       
         ELSE                                                           
!                                                                       
!           N .LT. MNTHR                                                
!                                                                       
!           Path 10t(N greater than M, but not much larger)             
!           Reduce to bidiagonal form without LQ decomposition          
!                                                                       
            IE = 1                                                      
            ITAUQ = 1                                                   
            ITAUP = ITAUQ + M                                           
            IWORK = ITAUP + M                                           
!                                                                       
!           Bidiagonalize A                                             
!           (CWorkspace: need 2*M+N, prefer 2*M+(M+N)*NB)               
!           (RWorkspace: M)                                             
!                                                                       
            CALL CSVD_CGEBRD( M, N, A, LDA, S, RWORK( IE ), WORK( ITAUQ ),     &
                         WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,     &
                         IERR )                                         
            IF( WNTUAS ) THEN                                           
!                                                                       
!              If left singular vectors desired in U, copy result to U  
!              and generate left bidiagonalizing vectors in U           
!              (CWorkspace: need 3*M-1, prefer 2*M+(M-1)*NB)            
!              (RWorkspace: 0)                                          
!                                                                       
               CALL CSVD_CLACPY( 'L', M, M, A, LDA, U, LDU )                 
               CALL CSVD_CUNGBR( 'Q', M, M, N, U, LDU, WORK( ITAUQ ),          &
                            WORK( IWORK ), LWORK-IWORK+1, IERR )        
            END IF                                                      
            IF( WNTVAS ) THEN                                           
!                                                                       
!              If right singular vectors desired in VT, copy result to  
!              VT and generate right bidiagonalizing vectors in VT      
!              (CWorkspace: need 2*M+NRVT, prefer 2*M+NRVT*NB)          
!              (RWorkspace: 0)                                          
!                                                                       
               CALL CSVD_CLACPY( 'U', M, N, A, LDA, VT, LDVT )               
               IF( WNTVA )                                                &
                  NRVT = N                                              
               IF( WNTVS )                                                &
                  NRVT = M                                              
               CALL CSVD_CUNGBR( 'P', NRVT, N, M, VT, LDVT, WORK( ITAUP ),     &
                            WORK( IWORK ), LWORK-IWORK+1, IERR )        
            END IF                                                      
            IF( WNTUO ) THEN                                            
!                                                                       
!              If left singular vectors desired in A, generate left     
!              bidiagonalizing vectors in A                             
!              (CWorkspace: need 3*M-1, prefer 2*M+(M-1)*NB)            
!              (RWorkspace: 0)                                          
!                                                                       
               CALL CSVD_CUNGBR( 'Q', M, M, N, A, LDA, WORK( ITAUQ ),          &
                            WORK( IWORK ), LWORK-IWORK+1, IERR )        
            END IF                                                      
            IF( WNTVO ) THEN                                            
!                                                                       
!              If right singular vectors desired in A, generate right   
!              bidiagonalizing vectors in A                             
!              (CWorkspace: need 3*M, prefer 2*M+M*NB)                  
!              (RWorkspace: 0)                                          
!                                                                       
               CALL CSVD_CUNGBR( 'P', M, N, M, A, LDA, WORK( ITAUP ),          &
                            WORK( IWORK ), LWORK-IWORK+1, IERR )        
            END IF                                                      
            IRWORK = IE + M                                             
            IF( WNTUAS .OR. WNTUO )                                       &
               NRU = M                                                  
            IF( WNTUN )                                                   &
               NRU = 0                                                  
            IF( WNTVAS .OR. WNTVO )                                       &
               NCVT = N                                                 
            IF( WNTVN )                                                   &
               NCVT = 0                                                 
            IF( ( .NOT.WNTUO ) .AND. ( .NOT.WNTVO ) ) THEN              
!                                                                       
!              Perform bidiagonal QR iteration, if desired, computing   
!              left singular vectors in U and computing right singular  
!              vectors in VT                                            
!              (CWorkspace: 0)                                          
!              (RWorkspace: need BDSPAC)                                
!                                                                       
               CALL CSVD_CBDSQR( 'L', M, NCVT, NRU, 0, S, RWORK( IE ), VT,     &
                            LDVT, U, LDU, CDUM, 1, RWORK( IRWORK ),       &
                            INFO )                                      
            ELSE IF( ( .NOT.WNTUO ) .AND. WNTVO ) THEN                  
!                                                                       
!              Perform bidiagonal QR iteration, if desired, computing   
!              left singular vectors in U and computing right singular  
!              vectors in A                                             
!              (CWorkspace: 0)                                          
!              (RWorkspace: need BDSPAC)                                
!                                                                       
               CALL CSVD_CBDSQR( 'L', M, NCVT, NRU, 0, S, RWORK( IE ), A,      &
                            LDA, U, LDU, CDUM, 1, RWORK( IRWORK ),        &
                            INFO )                                      
            ELSE                                                        
!                                                                       
!              Perform bidiagonal QR iteration, if desired, computing   
!              left singular vectors in A and computing right singular  
!              vectors in VT                                            
!              (CWorkspace: 0)                                          
!              (RWorkspace: need BDSPAC)                                
!                                                                       
               CALL CSVD_CBDSQR( 'L', M, NCVT, NRU, 0, S, RWORK( IE ), VT,     &
                            LDVT, A, LDA, CDUM, 1, RWORK( IRWORK ),       &
                            INFO )                                      
            END IF                                                      
!                                                                       
         END IF                                                         
!                                                                       
      END IF                                                            
!                                                                       
!     Undo scaling if necessary                                         
!                                                                       
      IF( ISCL.EQ.1 ) THEN                                              
         IF( ANRM.GT.BIGNUM )                                             &
            CALL CSVD_SLASCL( 'G', 0, 0, BIGNUM, ANRM, MINMN, 1, S, MINMN,     &
                         IERR )                                         
         IF( INFO.NE.0 .AND. ANRM.GT.BIGNUM )                             &
            CALL CSVD_SLASCL( 'G', 0, 0, BIGNUM, ANRM, MINMN-1, 1,             &
                         RWORK( IE ), MINMN, IERR )                     
         IF( ANRM.LT.SMLNUM )                                             &
            CALL CSVD_SLASCL( 'G', 0, 0, SMLNUM, ANRM, MINMN, 1, S, MINMN,     &
                         IERR )                                         
         IF( INFO.NE.0 .AND. ANRM.LT.SMLNUM )                             &
            CALL CSVD_SLASCL( 'G', 0, 0, SMLNUM, ANRM, MINMN-1, 1,             &
                         RWORK( IE ), MINMN, IERR )                     
      END IF                                                            
!                                                                       
!     Return optimal workspace in WORK(1)                               
!                                                                       
      WORK( 1 ) = MAXWRK                                                
!                                                                       
      RETURN                                                            
      END SUBROUTINE CSVD_CGE 
!                                                                       
!     End of CSVD_CGE 


      SUBROUTINE CSVD_SVBKSB(U,W,V,M,N,MP,NP,B,X)

!     Solves  A X = B 
!
!  U        COMPLEX array, dimension (MP,NP)
!          (the left singular vectors, stored columnwise)
!  W       complex array, dimension (NP)                    
!          The singular values of matrix A, sorted largest to smallest
!
!  V        COMPLEX array, dimension (MP,NP)
!          (the right singular vectors, stored columnwise)                  
!                                                                          
!  M       (input) INTEGER                                              
!          The number of rows of the input matrix A.          
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the input matrix A.      
!                                                                    
!  MP      (input) INTEGER                                              
!          The max number of rows of the input matrix A.          
!                                                                       
!  NP      (input) INTEGER                                              
!          The max number of columns of the input matrix A.
! 
!  B       COMPLEX array, dimension (MP) Input right hand side
!
!  X       COMPLEX array, dimension (NP) output solution
!           
      implicit none
      integer  :: M,N,MP,NP

      Complex  U(MP,NP),W(NP),V(NP,NP),B(MP),X(NP),TMP(N)

      Complex  :: S
      integer  :: i, j, jj

      DO 12 J=1,N
        S=0.
        IF(W(J).NE.0.)THEN
          DO 11 I=1,M
            S=S+CONJG(U(I,J))*B(I)   ! complex conjg 
11        CONTINUE
          S=S/W(J)
        ENDIF
        TMP(J)=S
12    CONTINUE
      DO 14 J=1,N
        S=0.
        DO 13 JJ=1,N
          S=S+V(J,JJ)*TMP(JJ)
13      CONTINUE
        X(J)=S
14    CONTINUE
      RETURN
      END SUBROUTINE CSVD_SVBKSB


      SUBROUTINE CSVD_CBDSQR( UPLO, N, NCVT, NRU, NCC, D, E, VT, LDVT, U,  &   
                         LDU, C, LDC, RWORK, INFO )                    
!                                                                       
!  -- LAPACK routine (version 3.0) --                                   
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     October 31, 1999                                                  
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          UPLO                                           
      INTEGER            INFO, LDC, LDU, LDVT, N, NCC, NCVT, NRU        
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               D( * ), E( * ), RWORK( * )                     
      COMPLEX            C( LDC, * ), U( LDU, * ), VT( LDVT, * )        
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CBDSQR computes the singular value decomposition (SVD) of a real     
!  N-by-N (upper or lower) bidiagonal matrix B:  B = Q * S * P' (P'     
!  denotes the transpose of P), where S is a diagonal matrix with       
!  non-negative diagonal elements (the singular values of B), and Q     
!  and P are orthogonal matrices.                                       
!                                                                       
!  The routine computes S, and optionally computes U * Q, P' * VT,      
!  or Q' * C, for given complex input matrices U, VT, and C.            
!                                                                       
!  See "Computing  Small Singular Values of Bidiagonal Matrices With    
!  Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,       
!  LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,    
!  no. 5, pp. 873-912, Sept 1990) and                                   
!  "Accurate singular values and differential qd algorithms," by        
!  B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics   
!  Department, University of California at Berkeley, July 1992          
!  for a detailed description of the algorithm.                         
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  UPLO    (input) CHARACTER*1                                          
!          = 'U':  B is upper bidiagonal;                               
!          = 'L':  B is lower bidiagonal.                               
!                                                                       
!  N       (input) INTEGER                                              
!          The order of the matrix B.  N &gt;= 0.                       
!                                                                       
!  NCVT    (input) INTEGER                                              
!          The number of columns of the matrix VT. NCVT &gt;= 0.        
!                                                                       
!  NRU     (input) INTEGER                                              
!          The number of rows of the matrix U. NRU &gt;= 0.             
!                                                                       
!  NCC     (input) INTEGER                                              
!          The number of columns of the matrix C. NCC &gt;= 0.          
!                                                                       
!  D       (input/output) REAL array, dimension (N)                     
!          On entry, the n diagonal elements of the bidiagonal matrix B.
!          On exit, if INFO=0, the singular values of B in decreasing   
!          order.                                                       
!                                                                       
!  E       (input/output) REAL array, dimension (N)                     
!          On entry, the elements of E contain the                      
!          offdiagonal elements of of the bidiagonal matrix whose SVD   
!          is desired. On normal exit (INFO = 0), E is destroyed.       
!          If the algorithm does not converge (INFO &gt; 0), D and E    
!          will contain the diagonal and superdiagonal elements of a    
!          bidiagonal matrix orthogonally equivalent to the one given   
!          as input. E(N) is used for workspace.                        
!                                                                       
!  VT      (input/output) COMPLEX array, dimension (LDVT, NCVT)         
!          On entry, an N-by-NCVT matrix VT.                            
!          On exit, VT is overwritten by P' * VT.                       
!          VT is not referenced if NCVT = 0.                            
!                                                                       
!  LDVT    (input) INTEGER                                              
!          The leading dimension of the array VT.                       
!          LDVT &gt;= max(1,N) if NCVT &gt; 0; LDVT &gt;= 1 if NCVT = 0.
!                                                                       
!  U       (input/output) COMPLEX array, dimension (LDU, N)             
!          On entry, an NRU-by-N matrix U.                              
!          On exit, U is overwritten by U * Q.                          
!          U is not referenced if NRU = 0.                              
!                                                                       
!  LDU     (input) INTEGER                                              
!          The leading dimension of the array U.  LDU &gt;= max(1,NRU). 
!                                                                       
!  C       (input/output) COMPLEX array, dimension (LDC, NCC)           
!          On entry, an N-by-NCC matrix C.                              
!          On exit, C is overwritten by Q' * C.                         
!          C is not referenced if NCC = 0.                              
!                                                                       
!  LDC     (input) INTEGER                                              
!          The leading dimension of the array C.                        
!          LDC &gt;= max(1,N) if NCC &gt; 0; LDC &gt;=1 if NCC = 0.     
!                                                                       
!  RWORK   (workspace) REAL array, dimension (4*N)                      
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0:  successful exit                                        
!          &lt; 0:  If INFO = -i, the i-th argument had an illegal value
!          &gt; 0:  the algorithm did not converge; D and E contain the 
!                elements of a bidiagonal matrix which is orthogonally  
!                similar to the input matrix B;  if INFO = i, i         
!                elements of E have not converged to zero.              
!                                                                       
!  Internal Parameters                                                  
!  ===================                                                  
!                                                                       
!  TOLMUL  REAL, default = max(10,min(100,EPS**(-1/8)))                 
!          TOLMUL controls the convergence criterion of the QR loop.    
!          If it is positive, TOLMUL*EPS is the desired relative        
!             precision in the computed singular values.                
!          If it is negative, abs(TOLMUL*EPS*sigma_max) is the          
!             desired absolute accuracy in the computed singular        
!             values (corresponds to relative accuracy                  
!             abs(TOLMUL*EPS) in the largest singular value.            
!          abs(TOLMUL) should be between 1 and 1/EPS, and preferably    
!             between 10 (for fast convergence) and .1/EPS              
!             (for there to be some accuracy in the results).           
!          Default is to lose at either one eighth or 2 of the          
!             available decimal digits in each computed singular value  
!             (whichever is smaller).                                   
!                                                                       
!  MAXITR  INTEGER, default = 6                                         
!          MAXITR controls the maximum number of passes of the          
!          algorithm through its inner loop. The algorithms stops       
!          (and so fails to converge) if the number of passes           
!          through the inner loop exceeds MAXITR*N**2.                  
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO                                           
      PARAMETER          ( ZERO = 0.0E0 )                               
      REAL               ONE                                            
      PARAMETER          ( ONE = 1.0E0 )                                
      REAL               NEGONE                                         
      PARAMETER          ( NEGONE = -1.0E0 )                            
      REAL               HNDRTH                                         
      PARAMETER          ( HNDRTH = 0.01E0 )                            
      REAL               TEN                                            
      PARAMETER          ( TEN = 10.0E0 )                               
      REAL               HNDRD                                          
      PARAMETER          ( HNDRD = 100.0E0 )                            
      REAL               MEIGTH                                         
      PARAMETER          ( MEIGTH = -0.125E0 )                          
      INTEGER            MAXITR                                         
      PARAMETER          ( MAXITR = 6 )                                 
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            LOWER, ROTATE                                  
      INTEGER            I, IDIR, ISUB, ITER, J, LL, LLL, M, MAXIT, NM1,  &
                         NM12, NM13, OLDLL, OLDM                        
      REAL               ABSE, ABSS, COSL, COSR, CS, EPS, F, G, H, MU,    &
                         OLDCS, OLDSN, R, SHIFT, SIGMN, SIGMX, SINL,      &
                         SINR, SLL, SMAX, SMIN, SMINL, SMINLO, SMINOA,    &
                         SN, THRESH, TOL, TOLMUL, UNFL                  
!     ..                                                                
!     .. External Functions ..                                          
!      LOGICAL            csvd_lsame                                          
!      REAL               csvd_slamch                                         
!      EXTERNAL           csvd_lsame, csvd_slamch 
!     ..                                                                
!     .. External Subroutines ..                                        
!      EXTERNAL        CSVD_CLASR, CSVD_CSROT, CSVD_csscal, CSVD_cswap,  &
!                      CSVD_SLARTG, CSVD_SLAS2,                          &
!                      CSVD_SLASQ1, CSVD_SLASV2, CSVD_XERBLA
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, MIN, REAL, SIGN, SQRT                
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0                                                          
      LOWER = csvd_lsame( UPLO, 'L' )                                        
      IF( .NOT.csvd_lsame( UPLO, 'U' ) .AND. .NOT.LOWER ) THEN               
         INFO = -1                                                      
      ELSE IF( N.LT.0 ) THEN                                            
         INFO = -2                                                      
      ELSE IF( NCVT.LT.0 ) THEN                                         
         INFO = -3                                                      
      ELSE IF( NRU.LT.0 ) THEN                                          
         INFO = -4                                                      
      ELSE IF( NCC.LT.0 ) THEN                                          
         INFO = -5                                                      
      ELSE IF( ( NCVT.EQ.0 .AND. LDVT.LT.1 ) .OR.                         &
               ( NCVT.GT.0 .AND. LDVT.LT.MAX( 1, N ) ) ) THEN           
         INFO = -9                                                      
      ELSE IF( LDU.LT.MAX( 1, NRU ) ) THEN                              
         INFO = -11                                                     
      ELSE IF( ( NCC.EQ.0 .AND. LDC.LT.1 ) .OR.                           &
               ( NCC.GT.0 .AND. LDC.LT.MAX( 1, N ) ) ) THEN             
         INFO = -13                                                     
      END IF                                                            
      IF( INFO.NE.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_CBDSQR', -INFO )
         RETURN                                                         
      END IF                                                            
      IF( N.EQ.0 )                                                        &
         RETURN                                                         
      IF( N.EQ.1 )                                                        &
         GO TO 160                                                      
!                                                                       
!     ROTATE is true if any singular vectors desired, false otherwise   
!                                                                       
      ROTATE = ( NCVT.GT.0 ) .OR. ( NRU.GT.0 ) .OR. ( NCC.GT.0 )        
!                                                                       
!     If no singular vectors desired, use qd algorithm                  
!                                                                       
      IF( .NOT.ROTATE ) THEN                                            
         CALL CSVD_SLASQ1( N, D, E, RWORK, INFO )                            
         RETURN                                                         
      END IF                                                            
!                                                                       
      NM1 = N - 1                                                       
      NM12 = NM1 + NM1                                                  
      NM13 = NM12 + NM1                                                 
      IDIR = 0                                                          
!                                                                       
!     Get machine constants                                             
!                                                                       
      EPS = csvd_slamch( 'Epsilon' )                                         
      UNFL = csvd_slamch( 'Safe minimum' )                                   
!                                                                       
!     If matrix lower bidiagonal, rotate to be upper bidiagonal         
!     by applying Givens rotations on the left                          
!                                                                       
      IF( LOWER ) THEN                                                  
         DO 10 I = 1, N - 1                                             
            CALL CSVD_SLARTG( D( I ), E( I ), CS, SN, R )                    
            D( I ) = R                                                  
            E( I ) = SN*D( I+1 )                                        
            D( I+1 ) = CS*D( I+1 )                                      
            RWORK( I ) = CS                                             
            RWORK( NM1+I ) = SN                                         
   10    CONTINUE                                                       
!                                                                       
!        Update singular vectors if desired                             
!                                                                       
         IF( NRU.GT.0 )                                                   &
            CALL CSVD_CLASR( 'R', 'V', 'F', NRU, N, RWORK( 1 ), RWORK( N ),    &
                        U, LDU )                                        
         IF( NCC.GT.0 )                                                   &
            CALL CSVD_CLASR( 'L', 'V', 'F', N, NCC, RWORK( 1 ), RWORK( N ),    &
                        C, LDC )                                        
      END IF                                                            
!                                                                       
!     Compute singular values to relative accuracy TOL                  
!     (By setting TOL to be negative, algorithm will compute            
!     singular values to absolute accuracy ABS(TOL)*norm(input matrix)) 
!                                                                       
      TOLMUL = MAX( TEN, MIN( HNDRD, EPS**MEIGTH ) )                    
      TOL = TOLMUL*EPS                                                  
!                                                                       
!     Compute approximate maximum, minimum singular values              
!                                                                       
      SMAX = ZERO                                                       
      DO 20 I = 1, N                                                    
         SMAX = MAX( SMAX, ABS( D( I ) ) )                              
   20 CONTINUE                                                          
      DO 30 I = 1, N - 1                                                
         SMAX = MAX( SMAX, ABS( E( I ) ) )                              
   30 CONTINUE                                                          
      SMINL = ZERO                                                      
      IF( TOL.GE.ZERO ) THEN                                            
!                                                                       
!        Relative accuracy desired                                      
!                                                                       
         SMINOA = ABS( D( 1 ) )                                         
         IF( SMINOA.EQ.ZERO )                                             &
            GO TO 50                                                    
         MU = SMINOA                                                    
         DO 40 I = 2, N                                                 
            MU = ABS( D( I ) )*( MU / ( MU+ABS( E( I-1 ) ) ) )          
            SMINOA = MIN( SMINOA, MU )                                  
            IF( SMINOA.EQ.ZERO )                                          &
               GO TO 50                                                 
   40    CONTINUE                                                       
   50    CONTINUE                                                       
         SMINOA = SMINOA / SQRT( REAL( N ) )                            
         THRESH = MAX( TOL*SMINOA, MAXITR*N*N*UNFL )                    
      ELSE                                                              
!                                                                       
!        Absolute accuracy desired                                      
!                                                                       
         THRESH = MAX( ABS( TOL )*SMAX, MAXITR*N*N*UNFL )               
      END IF                                                            
!                                                                       
!     Prepare for main iteration loop for the singular values           
!     (MAXIT is the maximum number of passes through the inner          
!     loop permitted before nonconvergence signalled.)                  
!                                                                       
      MAXIT = MAXITR*N*N                                                
      ITER = 0                                                          
      OLDLL = -1                                                        
      OLDM = -1                                                         
!                                                                       
!     M points to last element of unconverged part of matrix            
!                                                                       
      M = N                                                             
!                                                                       
!     Begin main iteration loop                                         
!                                                                       
   60 CONTINUE                                                          
!                                                                       
!     Check for convergence or exceeding iteration count                
!                                                                       
      IF( M.LE.1 )                                                        &
         GO TO 160                                                      
      IF( ITER.GT.MAXIT )                                                 &
         GO TO 200                                                      
!                                                                       
!     Find diagonal block of matrix to work on                          
!                                                                       
      IF( TOL.LT.ZERO .AND. ABS( D( M ) ).LE.THRESH )                     &
         D( M ) = ZERO                                                  
      SMAX = ABS( D( M ) )                                              
      SMIN = SMAX                                                       
      DO 70 LLL = 1, M - 1                                              
         LL = M - LLL                                                   
         ABSS = ABS( D( LL ) )                                          
         ABSE = ABS( E( LL ) )                                          
         IF( TOL.LT.ZERO .AND. ABSS.LE.THRESH )                           &
            D( LL ) = ZERO                                              
         IF( ABSE.LE.THRESH )                                             &
            GO TO 80                                                    
         SMIN = MIN( SMIN, ABSS )                                       
         SMAX = MAX( SMAX, ABSS, ABSE )                                 
   70 CONTINUE                                                          
      LL = 0                                                            
      GO TO 90                                                          
   80 CONTINUE                                                          
      E( LL ) = ZERO                                                    
!                                                                       
!     Matrix splits since E(LL) = 0                                     
!                                                                       
      IF( LL.EQ.M-1 ) THEN                                              
!                                                                       
!        Convergence of bottom singular value, return to top of loop    
!                                                                       
         M = M - 1                                                      
         GO TO 60                                                       
      END IF                                                            
   90 CONTINUE                                                          
      LL = LL + 1                                                       
!                                                                       
!     E(LL) through E(M-1) are nonzero, E(LL-1) is zero                 
!                                                                       
      IF( LL.EQ.M-1 ) THEN                                              
!                                                                       
!        2 by 2 block, handle separately                                
!                                                                       
         CALL CSVD_SLASV2( D( M-1 ), E( M-1 ), D( M ), SIGMN, SIGMX, SINR,     &
                      COSR, SINL, COSL )                                
         D( M-1 ) = SIGMX                                               
         E( M-1 ) = ZERO                                                
         D( M ) = SIGMN                                                 
!                                                                       
!        Compute singular vectors, if desired                           
!                                                                       
         IF( NCVT.GT.0 )                                                  &
            CALL CSVD_CSROT( NCVT, VT( M-1, 1 ), LDVT, VT( M, 1 ), LDVT,       &
                        COSR, SINR )                                    
         IF( NRU.GT.0 )                                                   &
            CALL CSVD_CSROT( NRU, U( 1, M-1 ), 1, U( 1, M ), 1, COSL, SINL ) 
         IF( NCC.GT.0 )                                                   &
            CALL CSVD_CSROT( NCC, C( M-1, 1 ), LDC, C( M, 1 ), LDC, COSL,      &
                        SINL )                                          
         M = M - 2                                                      
         GO TO 60                                                       
      END IF                                                            
!                                                                       
!     If working on new submatrix, choose shift direction               
!     (from larger end diagonal element towards smaller)                
!                                                                       
      IF( LL.GT.OLDM .OR. M.LT.OLDLL ) THEN                             
         IF( ABS( D( LL ) ).GE.ABS( D( M ) ) ) THEN                     
!                                                                       
!           Chase bulge from top (big end) to bottom (small end)        
!                                                                       
            IDIR = 1                                                    
         ELSE                                                           
!                                                                       
!           Chase bulge from bottom (big end) to top (small end)        
!                                                                       
            IDIR = 2                                                    
         END IF                                                         
      END IF                                                            
!                                                                       
!     Apply convergence tests                                           
!                                                                       
      IF( IDIR.EQ.1 ) THEN                                              
!                                                                       
!        Run convergence test in forward direction                      
!        First apply standard test to bottom of matrix                  
!                                                                       
         IF( ABS( E( M-1 ) ).LE.ABS( TOL )*ABS( D( M ) ) .OR.             &
             ( TOL.LT.ZERO .AND. ABS( E( M-1 ) ).LE.THRESH ) ) THEN     
            E( M-1 ) = ZERO                                             
            GO TO 60                                                    
         END IF                                                         
!                                                                       
         IF( TOL.GE.ZERO ) THEN                                         
!                                                                       
!           If relative accuracy desired,                               
!           apply convergence criterion forward                         
!                                                                       
            MU = ABS( D( LL ) )                                         
            SMINL = MU                                                  
            DO 100 LLL = LL, M - 1                                      
               IF( ABS( E( LLL ) ).LE.TOL*MU ) THEN                     
                  E( LLL ) = ZERO                                       
                  GO TO 60                                              
               END IF                                                   
               SMINLO = SMINL                                           
               MU = ABS( D( LLL+1 ) )*( MU / ( MU+ABS( E( LLL ) ) ) )   
               SMINL = MIN( SMINL, MU )                                 
  100       CONTINUE                                                    
         END IF                                                         
!                                                                       
      ELSE                                                              
!                                                                       
!        Run convergence test in backward direction                     
!        First apply standard test to top of matrix                     
!                                                                       
         IF( ABS( E( LL ) ).LE.ABS( TOL )*ABS( D( LL ) ) .OR.             &
             ( TOL.LT.ZERO .AND. ABS( E( LL ) ).LE.THRESH ) ) THEN      
            E( LL ) = ZERO                                              
            GO TO 60                                                    
         END IF                                                         
!                                                                       
         IF( TOL.GE.ZERO ) THEN                                         
!                                                                       
!           If relative accuracy desired,                               
!           apply convergence criterion backward                        
!                                                                       
            MU = ABS( D( M ) )                                          
            SMINL = MU                                                  
            DO 110 LLL = M - 1, LL, -1                                  
               IF( ABS( E( LLL ) ).LE.TOL*MU ) THEN                     
                  E( LLL ) = ZERO                                       
                  GO TO 60                                              
               END IF                                                   
               SMINLO = SMINL                                           
               MU = ABS( D( LLL ) )*( MU / ( MU+ABS( E( LLL ) ) ) )     
               SMINL = MIN( SMINL, MU )                                 
  110       CONTINUE                                                    
         END IF                                                         
      END IF                                                            
      OLDLL = LL                                                        
      OLDM = M                                                          
!                                                                       
!     Compute shift.  First, test if shifting would ruin relative       
!     accuracy, and if so set the shift to zero.                        
!                                                                       
      IF( TOL.GE.ZERO .AND. N*TOL*( SMINL / SMAX ).LE.                    &
          MAX( EPS, HNDRTH*TOL ) ) THEN                                 
!                                                                       
!        Use a zero shift to avoid loss of relative accuracy            
!                                                                       
         SHIFT = ZERO                                                   
      ELSE                                                              
!                                                                       
!        Compute the shift from 2-by-2 block at end of matrix           
!                                                                       
         IF( IDIR.EQ.1 ) THEN                                           
            SLL = ABS( D( LL ) )                                        
            CALL CSVD_SLAS2( D( M-1 ), E( M-1 ), D( M ), SHIFT, R )          
         ELSE                                                           
            SLL = ABS( D( M ) )                                         
            CALL CSVD_SLAS2( D( LL ), E( LL ), D( LL+1 ), SHIFT, R )         
         END IF                                                         
!                                                                       
!        Test if shift negligible, and if so set to zero                
!                                                                       
         IF( SLL.GT.ZERO ) THEN                                         
            IF( ( SHIFT / SLL )**2.LT.EPS )                               &
               SHIFT = ZERO                                             
         END IF                                                         
      END IF                                                            
!                                                                       
!     Increment iteration count                                         
!                                                                       
      ITER = ITER + M - LL                                              
!                                                                       
!     If SHIFT = 0, do simplified QR iteration                          
!                                                                       
      IF( SHIFT.EQ.ZERO ) THEN                                          
         IF( IDIR.EQ.1 ) THEN                                           
!                                                                       
!           Chase bulge from top to bottom                              
!           Save cosines and sines for later singular vector updates    
!                                                                       
            CS = ONE                                                    
            OLDCS = ONE                                                 
            DO 120 I = LL, M - 1                                        
               CALL CSVD_SLARTG( D( I )*CS, E( I ), CS, SN, R )              
               IF( I.GT.LL )                                              &
                  E( I-1 ) = OLDSN*R                                    
               CALL CSVD_SLARTG( OLDCS*R, D( I+1 )*SN, OLDCS, OLDSN, D( I ) )
               RWORK( I-LL+1 ) = CS                                     
               RWORK( I-LL+1+NM1 ) = SN                                 
               RWORK( I-LL+1+NM12 ) = OLDCS                             
               RWORK( I-LL+1+NM13 ) = OLDSN                             
  120       CONTINUE                                                    
            H = D( M )*CS                                               
            D( M ) = H*OLDCS                                            
            E( M-1 ) = H*OLDSN                                          
!                                                                       
!           Update singular vectors                                     
!                                                                       
            IF( NCVT.GT.0 )                                               &
               CALL CSVD_CLASR( 'L', 'V', 'F', M-LL+1, NCVT, RWORK( 1 ),       &
                           RWORK( N ), VT( LL, 1 ), LDVT )              
            IF( NRU.GT.0 )                                                &
               CALL CSVD_CLASR( 'R', 'V', 'F', NRU, M-LL+1, RWORK( NM12+1 ),   &
                           RWORK( NM13+1 ), U( 1, LL ), LDU )           
            IF( NCC.GT.0 )                                                &
               CALL CSVD_CLASR( 'L', 'V', 'F', M-LL+1, NCC, RWORK( NM12+1 ),   &
                           RWORK( NM13+1 ), C( LL, 1 ), LDC )           
!                                                                       
!           Test convergence                                            
!                                                                       
            IF( ABS( E( M-1 ) ).LE.THRESH )                               &
               E( M-1 ) = ZERO                                          
!                                                                       
         ELSE                                                           
!                                                                       
!           Chase bulge from bottom to top                              
!           Save cosines and sines for later singular vector updates    
!                                                                       
            CS = ONE                                                    
            OLDCS = ONE                                                 
            DO 130 I = M, LL + 1, -1                                    
               CALL CSVD_SLARTG( D( I )*CS, E( I-1 ), CS, SN, R )            
               IF( I.LT.M )                                               &
                  E( I ) = OLDSN*R                                      
               CALL CSVD_SLARTG( OLDCS*R, D( I-1 )*SN, OLDCS, OLDSN, D( I ) )
               RWORK( I-LL ) = CS                                       
               RWORK( I-LL+NM1 ) = -SN                                  
               RWORK( I-LL+NM12 ) = OLDCS                               
               RWORK( I-LL+NM13 ) = -OLDSN                              
  130       CONTINUE                                                    
            H = D( LL )*CS                                              
            D( LL ) = H*OLDCS                                           
            E( LL ) = H*OLDSN                                           
!                                                                       
!           Update singular vectors                                     
!                                                                       
            IF( NCVT.GT.0 )                                               &
               CALL CSVD_CLASR( 'L', 'V', 'B', M-LL+1, NCVT, RWORK( NM12+1 ),  &
                           RWORK( NM13+1 ), VT( LL, 1 ), LDVT )         
            IF( NRU.GT.0 )                                                &
               CALL CSVD_CLASR( 'R', 'V', 'B', NRU, M-LL+1, RWORK( 1 ),        &
                           RWORK( N ), U( 1, LL ), LDU )                
            IF( NCC.GT.0 )                                                &
               CALL CSVD_CLASR( 'L', 'V', 'B', M-LL+1, NCC, RWORK( 1 ),        &
                           RWORK( N ), C( LL, 1 ), LDC )                
!                                                                       
!           Test convergence                                            
!                                                                       
            IF( ABS( E( LL ) ).LE.THRESH )                                &
               E( LL ) = ZERO                                           
         END IF                                                         
      ELSE                                                              
!                                                                       
!        Use nonzero shift                                              
!                                                                       
         IF( IDIR.EQ.1 ) THEN                                           
!                                                                       
!           Chase bulge from top to bottom                              
!           Save cosines and sines for later singular vector updates    
!                                                                       
            F = ( ABS( D( LL ) )-SHIFT )*                                 &
                ( SIGN( ONE, D( LL ) )+SHIFT / D( LL ) )                
            G = E( LL )                                                 
            DO 140 I = LL, M - 1                                        
               CALL CSVD_SLARTG( F, G, COSR, SINR, R )                       
               IF( I.GT.LL )                                              &
                  E( I-1 ) = R                                          
               F = COSR*D( I ) + SINR*E( I )                            
               E( I ) = COSR*E( I ) - SINR*D( I )                       
               G = SINR*D( I+1 )                                        
               D( I+1 ) = COSR*D( I+1 )                                 
               CALL CSVD_SLARTG( F, G, COSL, SINL, R )                       
               D( I ) = R                                               
               F = COSL*E( I ) + SINL*D( I+1 )                          
               D( I+1 ) = COSL*D( I+1 ) - SINL*E( I )                   
               IF( I.LT.M-1 ) THEN                                      
                  G = SINL*E( I+1 )                                     
                  E( I+1 ) = COSL*E( I+1 )                              
               END IF                                                   
               RWORK( I-LL+1 ) = COSR                                   
               RWORK( I-LL+1+NM1 ) = SINR                               
               RWORK( I-LL+1+NM12 ) = COSL                              
               RWORK( I-LL+1+NM13 ) = SINL                              
  140       CONTINUE                                                    
            E( M-1 ) = F                                                
!                                                                       
!           Update singular vectors                                     
!                                                                       
            IF( NCVT.GT.0 )                                               &
               CALL CSVD_CLASR( 'L', 'V', 'F', M-LL+1, NCVT, RWORK( 1 ),       &
                           RWORK( N ), VT( LL, 1 ), LDVT )              
            IF( NRU.GT.0 )                                                &
               CALL CSVD_CLASR( 'R', 'V', 'F', NRU, M-LL+1, RWORK( NM12+1 ),   &
                           RWORK( NM13+1 ), U( 1, LL ), LDU )           
            IF( NCC.GT.0 )                                                &
               CALL CSVD_CLASR( 'L', 'V', 'F', M-LL+1, NCC, RWORK( NM12+1 ),   &
                           RWORK( NM13+1 ), C( LL, 1 ), LDC )           
!                                                                       
!           Test convergence                                            
!                                                                       
            IF( ABS( E( M-1 ) ).LE.THRESH )                               &
               E( M-1 ) = ZERO                                          
!                                                                       
         ELSE                                                           
!                                                                       
!           Chase bulge from bottom to top                              
!           Save cosines and sines for later singular vector updates    
!                                                                       
            F = ( ABS( D( M ) )-SHIFT )*( SIGN( ONE, D( M ) )+SHIFT /     &
                D( M ) )                                                
            G = E( M-1 )                                                
            DO 150 I = M, LL + 1, -1                                    
               CALL CSVD_SLARTG( F, G, COSR, SINR, R )                       
               IF( I.LT.M )                                               &
                  E( I ) = R                                            
               F = COSR*D( I ) + SINR*E( I-1 )                          
               E( I-1 ) = COSR*E( I-1 ) - SINR*D( I )                   
               G = SINR*D( I-1 )                                        
               D( I-1 ) = COSR*D( I-1 )                                 
               CALL CSVD_SLARTG( F, G, COSL, SINL, R )                       
               D( I ) = R                                               
               F = COSL*E( I-1 ) + SINL*D( I-1 )                        
               D( I-1 ) = COSL*D( I-1 ) - SINL*E( I-1 )                 
               IF( I.GT.LL+1 ) THEN                                     
                  G = SINL*E( I-2 )                                     
                  E( I-2 ) = COSL*E( I-2 )                              
               END IF                                                   
               RWORK( I-LL ) = COSR                                     
               RWORK( I-LL+NM1 ) = -SINR                                
               RWORK( I-LL+NM12 ) = COSL                                
               RWORK( I-LL+NM13 ) = -SINL                               
  150       CONTINUE                                                    
            E( LL ) = F                                                 
!                                                                       
!           Test convergence                                            
!                                                                       
            IF( ABS( E( LL ) ).LE.THRESH )                                &
               E( LL ) = ZERO                                           
!                                                                       
!           Update singular vectors if desired                          
!                                                                       
            IF( NCVT.GT.0 )                                               &
               CALL CSVD_CLASR( 'L', 'V', 'B', M-LL+1, NCVT, RWORK( NM12+1 ),  &
                           RWORK( NM13+1 ), VT( LL, 1 ), LDVT )         
            IF( NRU.GT.0 )                                                &
               CALL CSVD_CLASR( 'R', 'V', 'B', NRU, M-LL+1, RWORK( 1 ),        &
                           RWORK( N ), U( 1, LL ), LDU )                
            IF( NCC.GT.0 )                                                &
               CALL CSVD_CLASR( 'L', 'V', 'B', M-LL+1, NCC, RWORK( 1 ),        &
                           RWORK( N ), C( LL, 1 ), LDC )                
         END IF                                                         
      END IF                                                            
!                                                                       
!     QR iteration finished, go back and check convergence              
!                                                                       
      GO TO 60                                                          
!                                                                       
!     All singular values converged, so make them positive              
!                                                                       
  160 CONTINUE                                                          
      DO 170 I = 1, N                                                   
         IF( D( I ).LT.ZERO ) THEN                                      
            D( I ) = -D( I )                                            
!                                                                       
!           Change sign of singular vectors, if desired                 
!                                                                       
            IF( NCVT.GT.0 )                                               &
               CALL CSVD_csscal( NCVT, NEGONE, VT( I, 1 ), LDVT )            
         END IF                                                         
  170 CONTINUE                                                          
!                                                                       
!     Sort the singular values into decreasing order (insertion sort on 
!     singular values, but only one transposition per singular vector)  
!                                                                       
      DO 190 I = 1, N - 1                                               
!                                                                       
!        Scan for smallest D(I)                                         
!                                                                       
         ISUB = 1                                                       
         SMIN = D( 1 )                                                  
         DO 180 J = 2, N + 1 - I                                        
            IF( D( J ).LE.SMIN ) THEN                                   
               ISUB = J                                                 
               SMIN = D( J )                                            
            END IF                                                      
  180    CONTINUE                                                       
         IF( ISUB.NE.N+1-I ) THEN                                       
!                                                                       
!           Swap singular values and vectors                            
!                                                                       
            D( ISUB ) = D( N+1-I )                                      
            D( N+1-I ) = SMIN                                           
            IF( NCVT.GT.0 )                                               & 
               CALL CSVD_cswap( NCVT, VT( ISUB, 1 ), LDVT, VT( N+1-I, 1 ),  &
                           LDVT )                                       
            IF( NRU.GT.0 )                                                & 
               CALL CSVD_cswap( NRU, U( 1, ISUB ), 1, U( 1, N+1-I ), 1 )     
            IF( NCC.GT.0 )                                                & 
               CALL CSVD_cswap( NCC, C( ISUB, 1 ), LDC, C( N+1-I, 1 ), LDC ) 
         END IF                                                         
  190 CONTINUE                                                          
      GO TO 220                                                         
!                                                                       
!     Maximum number of iterations exceeded, failure to converge        
!                                                                       
  200 CONTINUE                                                          
      INFO = 0                                                          
      DO 210 I = 1, N - 1                                               
         IF( E( I ).NE.ZERO )                                             &
            INFO = INFO + 1                                             
  210 CONTINUE                                                          
  220 CONTINUE                                                          
      RETURN                                                            
!                                                                       
!     End of CSVD_CBDSQR                                                     
!                                                                       
      END SUBROUTINE CSVD_CBDSQR 
                                                             
      SUBROUTINE CSVD_CGEBD2( M, N, A, LDA, D, E, TAUQ, TAUP, WORK, INFO )   
!                                                                       
!  -- LAPACK routine (version 3.0) --                                   
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     September 30, 1994                                                
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, LDA, M, N                                
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               D( * ), E( * )                                 
      COMPLEX            A( LDA, * ), TAUP( * ), TAUQ( * ), WORK( * )   
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CGEBD2 reduces a complex general m by n matrix A to upper or lower   
!  real bidiagonal form B by a unitary transformation: Q' * A * P = B.  
!                                                                       
!  If m &gt;= n, B is upper bidiagonal; if m &lt; n, B is lower bidiagon
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows in the matrix A.  M &gt;= 0.              
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns in the matrix A.  N &gt;= 0.           
!                                                                       
!  A       (input/output) COMPLEX array, dimension (LDA,N)              
!          On entry, the m by n general matrix to be reduced.           
!          On exit,                                                     
!          if m &gt;= n, the diagonal and the first superdiagonal are   
!            overwritten with the upper bidiagonal matrix B; the        
!            elements below the diagonal, with the array TAUQ, represent
!            the unitary matrix Q as a product of elementary            
!            reflectors, and the elements above the first superdiagonal,
!            with the array TAUP, represent the unitary matrix P as     
!            a product of elementary reflectors;                        
!          if m &lt; n, the diagonal and the first subdiagonal are      
!            overwritten with the lower bidiagonal matrix B; the        
!            elements below the first subdiagonal, with the array TAUQ, 
!            represent the unitary matrix Q as a product of             
!            elementary reflectors, and the elements above the diagonal,
!            with the array TAUP, represent the unitary matrix P as     
!            a product of elementary reflectors.                        
!          See Further Details.                                         
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA &gt;= max(1,M).   
!                                                                       
!  D       (output) REAL array, dimension (min(M,N))                    
!          The diagonal elements of the bidiagonal matrix B:            
!          D(i) = A(i,i).                                               
!                                                                       
!  E       (output) REAL array, dimension (min(M,N)-1)                  
!          The off-diagonal elements of the bidiagonal matrix B:        
!          if m &gt;= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;           
!          if m &lt; n, E(i) = A(i+1,i) for i = 1,2,...,m-1.            
!                                                                       
!  TAUQ    (output) COMPLEX array dimension (min(M,N))                  
!          The scalar factors of the elementary reflectors which        
!          represent the unitary matrix Q. See Further Details.         
!                                                                       
!  TAUP    (output) COMPLEX array, dimension (min(M,N))                 
!          The scalar factors of the elementary reflectors which        
!          represent the unitary matrix P. See Further Details.         
!                                                                       
!  WORK    (workspace) COMPLEX array, dimension (max(M,N))              
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0: successful exit                                         
!          &lt; 0: if INFO = -i, the i-th argument had an illegal value.
!                                                                       
!  Further Details                                                      
!  ===============                                                      
!                                                                       
!  The matrices Q and P are represented as products of elementary       
!  reflectors:                                                          
!                                                                       
!  If m &gt;= n,                                                        
!                                                                       
!     Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)         
!                                                                       
!  Each H(i) and G(i) has the form:                                     
!                                                                       
!     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'            
!                                                                       
!  where tauq and taup are complex scalars, and v and u are complex     
!  vectors; v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in   
!  A(i+1:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in
!  A(i,i+2:n); tauq is stored in TAUQ(i) and taup in TAUP(i).           
!                                                                       
!  If m &lt; n,                                                         
!                                                                       
!     Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)         
!                                                                       
!  Each H(i) and G(i) has the form:                                     
!                                                                       
!     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'            
!                                                                       
!  where tauq and taup are complex scalars, v and u are complex vectors;
!  v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
!  u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
!  tauq is stored in TAUQ(i) and taup in TAUP(i).                       
!                                                                       
!  The contents of A on exit are illustrated by the following examples: 
!                                                                       
!  m = 6 and n = 5 (m &gt; n):          m = 5 and n = 6 (m &lt; n):     
!                                                                       
!    (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )      
!    (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )      
!    (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )      
!    (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )      
!    (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )      
!    (  v1  v2  v3  v4  v5 )                                            
!                                                                       
!  where d and e denote diagonal and off-diagonal elements of B, vi     
!  denotes an element of the vector defining H(i), and ui an element of 
!  the vector defining G(i).                                            
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      COMPLEX            ZERO, ONE 
 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I                                              
      COMPLEX            ALPHA                                          
!     ..                                                                
!     .. External Subroutines ..                                        
!     EXTERNAL           CSVD_CLACGV, CSVD_CLARF, CSVD_CLARFG, CSVD_XERBLA
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          CONJG, MAX, MIN                                
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters                                         
!                                                                       

      ZERO = CMPLX( 0.0E+0, 0.0E+0 )
      ONE  = CMPLX( 1.0E+0, 0.0E+0 ) 

      INFO = 0                                                          
      IF( M.LT.0 ) THEN                                                 
         INFO = -1                                                      
      ELSE IF( N.LT.0 ) THEN                                            
         INFO = -2                                                      
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN                                
         INFO = -4                                                      
      END IF                                                            
      IF( INFO.LT.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_CGEBD2', -INFO )
         RETURN                                                         
      END IF                                                            
!                                                                       
      IF( M.GE.N ) THEN                                                 
!                                                                       
!        Reduce to upper bidiagonal form                                
!                                                                       
         DO 10 I = 1, N                                                 
!                                                                       
!           Generate elementary reflector H(i) to annihilate A(i+1:m,i) 
!                                                                       
            ALPHA = A( I, I )                                           
            CALL CSVD_CLARFG( M-I+1, ALPHA, A( MIN( I+1, M ), I ), 1,          &
                         TAUQ( I ) )                                    
            D( I ) = ALPHA                                              
            A( I, I ) = ONE                                             
!                                                                       
!           Apply H(i)' to A(i:m,i+1:n) from the left                   
!                                                                       
            CALL CSVD_CLARF( 'Left', M-I+1, N-I, A( I, I ), 1,                 &
                        CONJG( TAUQ( I ) ), A( I, I+1 ), LDA, WORK )    
            A( I, I ) = D( I )                                          
!                                                                       
            IF( I.LT.N ) THEN                                           
!                                                                       
!              Generate elementary reflector G(i) to annihilate         
!              A(i,i+2:n)                                               
!                                                                       
               CALL CSVD_CLACGV( N-I, A( I, I+1 ), LDA )                     
               ALPHA = A( I, I+1 )                                      
               CALL CSVD_CLARFG( N-I, ALPHA, A( I, MIN( I+2, N ) ),            &
                            LDA, TAUP( I ) )                            
               E( I ) = ALPHA                                           
               A( I, I+1 ) = ONE                                        
!                                                                       
!              Apply G(i) to A(i+1:m,i+1:n) from the right              
!                                                                       
               CALL CSVD_CLARF( 'Right', M-I, N-I, A( I, I+1 ), LDA,           &
                           TAUP( I ), A( I+1, I+1 ), LDA, WORK )        
               CALL CSVD_CLACGV( N-I, A( I, I+1 ), LDA )                     
               A( I, I+1 ) = E( I )                                     
            ELSE                                                        
               TAUP( I ) = ZERO                                         
            END IF                                                      
   10    CONTINUE                                                       
      ELSE                                                              
!                                                                       
!        Reduce to lower bidiagonal form                                
!                                                                       
         DO 20 I = 1, M                                                 
!                                                                       
!           Generate elementary reflector G(i) to annihilate A(i,i+1:n) 
!                                                                       
            CALL CSVD_CLACGV( N-I+1, A( I, I ), LDA )                        
            ALPHA = A( I, I )                                           
            CALL CSVD_CLARFG( N-I+1, ALPHA, A( I, MIN( I+1, N ) ), LDA,        &
                         TAUP( I ) )                                    
            D( I ) = ALPHA                                              
            A( I, I ) = ONE                                             
!                                                                       
!           Apply G(i) to A(i+1:m,i:n) from the right                   
!                                                                       
            CALL CSVD_CLARF( 'Right', M-I, N-I+1, A( I, I ), LDA, TAUP( I ),   &
                        A( MIN( I+1, M ), I ), LDA, WORK )              
            CALL CSVD_CLACGV( N-I+1, A( I, I ), LDA )                        
            A( I, I ) = D( I )                                          
!                                                                       
            IF( I.LT.M ) THEN                                           
!                                                                       
!              Generate elementary reflector H(i) to annihilate         
!              A(i+2:m,i)                                               
!                                                                       
               ALPHA = A( I+1, I )                                      
               CALL CSVD_CLARFG( M-I, ALPHA, A( MIN( I+2, M ), I ), 1,         &
                            TAUQ( I ) )                                 
               E( I ) = ALPHA                                           
               A( I+1, I ) = ONE                                        
!                                                                       
!              Apply H(i)' to A(i+1:m,i+1:n) from the left              
!                                                                       
               CALL CSVD_CLARF( 'Left', M-I, N-I, A( I+1, I ), 1,              &
                           CONJG( TAUQ( I ) ), A( I+1, I+1 ), LDA,        &
                           WORK )                                       
               A( I+1, I ) = E( I )                                     
            ELSE                                                        
               TAUQ( I ) = ZERO                                         
            END IF                                                      
   20    CONTINUE                                                       
      END IF                                                            
      RETURN                                                            
!                                                                       
!     End of CSVD_CGEBD2                                                     
!                                                                       
      END SUBROUTINE CSVD_CGEBD2

                                                              
      SUBROUTINE CSVD_CGEBRD( M, N, A, LDA, D, E, TAUQ, TAUP, WORK, LWORK,&
                         INFO )                                         
!                                                                       
!  -- LAPACK routine (version 3.0) --                                   
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     June 30, 1999                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, LDA, LWORK, M, N                         
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               D( * ), E( * )                                 
      COMPLEX            A( LDA, * ), TAUP( * ), TAUQ( * ),               &
                         WORK( * )                                      
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CGEBRD reduces a general complex M-by-N matrix A to upper or lower   
!  bidiagonal form B by a unitary transformation: Q**H * A * P = B.     
!                                                                       
!  If m &gt;= n, B is upper bidiagonal; if m &lt; n, B is lower bidiagon
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows in the matrix A.  M &gt;= 0.              
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns in the matrix A.  N &gt;= 0.           
!                                                                       
!  A       (input/output) COMPLEX array, dimension (LDA,N)              
!          On entry, the M-by-N general matrix to be reduced.           
!          On exit,                                                     
!          if m &gt;= n, the diagonal and the first superdiagonal are   
!            overwritten with the upper bidiagonal matrix B; the        
!            elements below the diagonal, with the array TAUQ, represent
!            the unitary matrix Q as a product of elementary            
!            reflectors, and the elements above the first superdiagonal,
!            with the array TAUP, represent the unitary matrix P as     
!            a product of elementary reflectors;                        
!          if m &lt; n, the diagonal and the first subdiagonal are      
!            overwritten with the lower bidiagonal matrix B; the        
!            elements below the first subdiagonal, with the array TAUQ, 
!            represent the unitary matrix Q as a product of             
!            elementary reflectors, and the elements above the diagonal,
!            with the array TAUP, represent the unitary matrix P as     
!            a product of elementary reflectors.                        
!          See Further Details.                                         
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA &gt;= max(1,M).   
!                                                                       
!  D       (output) REAL array, dimension (min(M,N))                    
!          The diagonal elements of the bidiagonal matrix B:            
!          D(i) = A(i,i).                                               
!                                                                       
!  E       (output) REAL array, dimension (min(M,N)-1)                  
!          The off-diagonal elements of the bidiagonal matrix B:        
!          if m &gt;= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;           
!          if m &lt; n, E(i) = A(i+1,i) for i = 1,2,...,m-1.            
!                                                                       
!  TAUQ    (output) COMPLEX array dimension (min(M,N))                  
!          The scalar factors of the elementary reflectors which        
!          represent the unitary matrix Q. See Further Details.         
!                                                                       
!  TAUP    (output) COMPLEX array, dimension (min(M,N))                 
!          The scalar factors of the elementary reflectors which        
!          represent the unitary matrix P. See Further Details.         
!                                                                       
!  WORK    (workspace/output) COMPLEX array, dimension (LWORK)          
!          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.     
!                                                                       
!  LWORK   (input) INTEGER                                              
!          The length of the array WORK.  LWORK &gt;= max(1,M,N).       
!          For optimum performance LWORK &gt;= (M+N)*NB, where NB       
!          is the optimal blocksize.                                    
!                                                                       
!          If LWORK = -1, then a workspace query is assumed; the routine
!          only calculates the optimal size of the WORK array, returns  
!          this value as the first entry of the WORK array, and no error
!          message related to LWORK is issued by CSVD_XERBLA.                
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0:  successful exit.                                       
!          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
!                                                                       
!  Further Details                                                      
!  ===============                                                      
!                                                                       
!  The matrices Q and P are represented as products of elementary       
!  reflectors:                                                          
!                                                                       
!  If m &gt;= n,                                                        
!                                                                       
!     Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)         
!                                                                       
!  Each H(i) and G(i) has the form:                                     
!                                                                       
!     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'            
!                                                                       
!  where tauq and taup are complex scalars, and v and u are complex     
!  vectors; v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in   
!  A(i+1:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in
!  A(i,i+2:n); tauq is stored in TAUQ(i) and taup in TAUP(i).           
!                                                                       
!  If m &lt; n,                                                         
!                                                                       
!     Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)         
!                                                                       
!  Each H(i) and G(i) has the form:                                     
!                                                                       
!     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'            
!                                                                       
!  where tauq and taup are complex scalars, and v and u are complex     
!  vectors; v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in   
!  A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in
!  A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).           
!                                                                       
!  The contents of A on exit are illustrated by the following examples: 
!                                                                       
!  m = 6 and n = 5 (m &gt; n):          m = 5 and n = 6 (m &lt; n):     
!                                                                       
!    (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )      
!    (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )      
!    (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )      
!    (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )      
!    (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )      
!    (  v1  v2  v3  v4  v5 )                                            
!                                                                       
!  where d and e denote diagonal and off-diagonal elements of B, vi     
!  denotes an element of the vector defining H(i), and ui an element of 
!  the vector defining G(i).                                            
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      COMPLEX            ONE                                            

!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            LQUERY                                         
      INTEGER            I, IINFO, J, LDWRKX, LDWRKY, LWKOPT, MINMN, NB,  &
                         NBMIN, NX                                      
      REAL               WS                                             
!     ..                                                                
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_CGEBD2, CSVD_CGEMM, CSVD_CLABRD, CSVD_XERBLA
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN, REAL                                 
!     ..                                                                
!     .. External Functions ..                                          
!      INTEGER            csvd_ilaenv                                         
!      EXTERNAL           csvd_ilaenv                                         
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters                                         
!                                                                       
      ONE = CMPLX( 1.0E+0, 0.0E+0 ) 

      INFO = 0                                                          
      NB = MAX( 1, csvd_ilaenv( 1, 'CSVD_CGEBRD', ' ', M, N, -1, -1 ) )
      LWKOPT = ( M+N )*NB                                               
      WORK( 1 ) = REAL( LWKOPT )                                        
      LQUERY = ( LWORK.EQ.-1 )                                          
      IF( M.LT.0 ) THEN                                                 
         INFO = -1                                                      
      ELSE IF( N.LT.0 ) THEN                                            
         INFO = -2                                                      
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN                                
         INFO = -4                                                      
      ELSE IF( LWORK.LT.MAX( 1, M, N ) .AND. .NOT.LQUERY ) THEN         
         INFO = -10                                                     
      END IF                                                            
      IF( INFO.LT.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_CGEBRD', -INFO )
         RETURN                                                         
      ELSE IF( LQUERY ) THEN                                            
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible                                          
!                                                                       
      MINMN = MIN( M, N )                                               
      IF( MINMN.EQ.0 ) THEN                                             
         WORK( 1 ) = 1                                                  
         RETURN                                                         
      END IF                                                            
!                                                                       
      WS = MAX( M, N )                                                  
      LDWRKX = M                                                        
      LDWRKY = N                                                        
!                                                                       
      IF( NB.GT.1 .AND. NB.LT.MINMN ) THEN                              
!                                                                       
!        Set the crossover point NX.                                    
!                                                                       
         NX = MAX( NB, csvd_ilaenv( 3, 'CSVD_CGEBRD', ' ', M, N, -1, -1 ) )
!                                                                       
!        Determine when to switch from blocked to unblocked code.       
!                                                                       
         IF( NX.LT.MINMN ) THEN                                         
            WS = ( M+N )*NB                                             
            IF( LWORK.LT.WS ) THEN                                      
!                                                                       
!              Not enough work space for the optimal NB, consider using 
!              a smaller block size.                                    
!                                                                       
               NBMIN = csvd_ilaenv( 2, 'CSVD_CGEBRD', ' ', M, N, -1, -1 )
               IF( LWORK.GE.( M+N )*NBMIN ) THEN                        
                  NB = LWORK / ( M+N )                                  
               ELSE                                                     
                  NB = 1                                                
                  NX = MINMN                                            
               END IF                                                   
            END IF                                                      
         END IF                                                         
      ELSE                                                              
         NX = MINMN                                                     
      END IF                                                            
!                                                                       
      DO 30 I = 1, MINMN - NX, NB                                       
!                                                                       
!        Reduce rows and columns i:i+ib-1 to bidiagonal form and return 
!        the matrices X and Y which are needed to update the unreduced  
!        part of the matrix                                             
!                                                                       
         CALL CSVD_CLABRD( M-I+1, N-I+1, NB, A( I, I ), LDA, D( I ), E( I ),   &
                      TAUQ( I ), TAUP( I ), WORK, LDWRKX,                 &
                      WORK( LDWRKX*NB+1 ), LDWRKY )                     
!                                                                       
!        Update the trailing submatrix A(i+ib:m,i+ib:n), using          
!        an update of the form  A := A - V*Y' - X*U'                    
!                                                                       
         CALL CSVD_CGEMM( 'No transpose', 'Conjugate transpose', M-I-NB+1,     &
                     N-I-NB+1, NB, -ONE, A( I+NB, I ), LDA,               &
                     WORK( LDWRKX*NB+NB+1 ), LDWRKY, ONE,                 &
                     A( I+NB, I+NB ), LDA )                             
         CALL CSVD_CGEMM( 'No transpose', 'No transpose', M-I-NB+1, N-I-NB+1,  &
                     NB, -ONE, WORK( NB+1 ), LDWRKX, A( I, I+NB ), LDA,   &
                     ONE, A( I+NB, I+NB ), LDA )                        
!                                                                       
!        Copy diagonal and off-diagonal elements of B back into A       
!                                                                       
         IF( M.GE.N ) THEN                                              
            DO 10 J = I, I + NB - 1                                     
               A( J, J ) = D( J )                                       
               A( J, J+1 ) = E( J )                                     
   10       CONTINUE                                                    
         ELSE                                                           
            DO 20 J = I, I + NB - 1                                     
               A( J, J ) = D( J )                                       
               A( J+1, J ) = E( J )                                     
   20       CONTINUE                                                    
         END IF                                                         
   30 CONTINUE                                                          
!                                                                       
!     Use unblocked code to reduce the remainder of the matrix          
!                                                                       
      CALL CSVD_CGEBD2( M-I+1, N-I+1, A( I, I ), LDA, D( I ), E( I ),          &
                   TAUQ( I ), TAUP( I ), WORK, IINFO )                  
      WORK( 1 ) = WS                                                    
      RETURN                                                            
!                                                                       
!     End of CSVD_CGEBRD                                                     
!                                                                       
      END SUBROUTINE CSVD_CGEBRD
                                                              
      SUBROUTINE CSVD_CGELQ2( M, N, A, LDA, TAU, WORK, INFO )                
!                                                                       
!  -- LAPACK routine (version 3.0) --                                   
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     September 30, 1994                                                
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, LDA, M, N                                
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * ), TAU( * ), WORK( * )               
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CGELQ2 computes an LQ factorization of a complex m by n matrix A:    
!  A = L * Q.                                                           
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix A.  M &gt;= 0.              
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix A.  N &gt;= 0.           
!                                                                       
!  A       (input/output) COMPLEX array, dimension (LDA,N)              
!          On entry, the m by n matrix A.                               
!          On exit, the elements on and below the diagonal of the array 
!          contain the m by min(m,n) lower trapezoidal matrix L (L is   
!          lower triangular if m &lt;= n); the elements above the diagon
!          with the array TAU, represent the unitary matrix Q as a      
!          product of elementary reflectors (see Further Details).      
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA &gt;= max(1,M).   
!                                                                       
!  TAU     (output) COMPLEX array, dimension (min(M,N))                 
!          The scalar factors of the elementary reflectors (see Further 
!          Details).                                                    
!                                                                       
!  WORK    (workspace) COMPLEX array, dimension (M)                     
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0: successful exit                                         
!          &lt; 0: if INFO = -i, the i-th argument had an illegal value 
!                                                                       
!  Further Details                                                      
!  ===============                                                      
!                                                                       
!  The matrix Q is represented as a product of elementary reflectors    
!                                                                       
!     Q = H(k)' . . . H(2)' H(1)', where k = min(m,n).                  
!                                                                       
!  Each H(i) has the form                                               
!                                                                       
!     H(i) = I - tau * v * v'                                           
!                                                                       
!  where tau is a complex scalar, and v is a complex vector with        
!  v(1:i-1) = 0 and v(i) = 1; conjg(v(i+1:n)) is stored on exit in      
!  A(i,i+1:n), and tau in TAU(i).                                       
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      COMPLEX            ONE                                            

!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, K                                           
      COMPLEX            ALPHA                                          
!     ..                                                                
!     .. External Subroutines ..                                        
!     EXTERNAL           CSVD_CLACGV, CSVD_CLARF, CSVD_CLARFG, CSVD_XERBLA
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN                                       
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      ONE = CMPLX( 1.0E+0, 0.0E+0 ) 

      INFO = 0                                                          
      IF( M.LT.0 ) THEN                                                 
         INFO = -1                                                      
      ELSE IF( N.LT.0 ) THEN                                            
         INFO = -2                                                      
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN                                
         INFO = -4                                                      
      END IF                                                            
      IF( INFO.NE.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_CGELQ2', -INFO )
         RETURN                                                         
      END IF                                                            
!                                                                       
      K = MIN( M, N )                                                   
!                                                                       
      DO 10 I = 1, K                                                    
!                                                                       
!        Generate elementary reflector H(i) to annihilate A(i,i+1:n)    
!                                                                       
         CALL CSVD_CLACGV( N-I+1, A( I, I ), LDA )                           
         ALPHA = A( I, I )                                              
         CALL CSVD_CLARFG( N-I+1, ALPHA, A( I, MIN( I+1, N ) ), LDA,           &
                      TAU( I ) )                                        
         IF( I.LT.M ) THEN                                              
!                                                                       
!           Apply H(i) to A(i+1:m,i:n) from the right                   
!                                                                       
            A( I, I ) = ONE                                             
            CALL CSVD_CLARF( 'Right', M-I, N-I+1, A( I, I ), LDA, TAU( I ),    &
                        A( I+1, I ), LDA, WORK )                        
         END IF                                                         
         A( I, I ) = ALPHA                                              
         CALL CSVD_CLACGV( N-I+1, A( I, I ), LDA )                           
   10 CONTINUE                                                          
      RETURN                                                            
!                                                                       
!     End of CSVD_CGELQ2                                                     
!                                                                       
      END SUBROUTINE CSVD_CGELQ2

      SUBROUTINE CSVD_CGELQF( M, N, A, LDA, TAU, WORK, LWORK, INFO )         
!                                                                       
!  -- LAPACK routine (version 3.0) --                                   
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     June 30, 1999                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, LDA, LWORK, M, N                         
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * ), TAU( * ), WORK( * )               
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CGELQF computes an LQ factorization of a complex M-by-N matrix A:    
!  A = L * Q.                                                           
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix A.  M &gt;= 0.              
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix A.  N &gt;= 0.           
!                                                                       
!  A       (input/output) COMPLEX array, dimension (LDA,N)              
!          On entry, the M-by-N matrix A.                               
!          On exit, the elements on and below the diagonal of the array 
!          contain the m-by-min(m,n) lower trapezoidal matrix L (L is   
!          lower triangular if m &lt;= n); the elements above the diagon
!          with the array TAU, represent the unitary matrix Q as a      
!          product of elementary reflectors (see Further Details).      
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA &gt;= max(1,M).   
!                                                                       
!  TAU     (output) COMPLEX array, dimension (min(M,N))                 
!          The scalar factors of the elementary reflectors (see Further 
!          Details).                                                    
!                                                                       
!  WORK    (workspace/output) COMPLEX array, dimension (LWORK)          
!          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.     
!                                                                       
!  LWORK   (input) INTEGER                                              
!          The dimension of the array WORK.  LWORK &gt;= max(1,M).      
!          For optimum performance LWORK &gt;= M*NB, where NB is the    
!          optimal blocksize.                                           
!                                                                       
!          If LWORK = -1, then a workspace query is assumed; the routine
!          only calculates the optimal size of the WORK array, returns  
!          this value as the first entry of the WORK array, and no error
!          message related to LWORK is issued by CSVD_XERBLA.                
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0:  successful exit                                        
!          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
!                                                                       
!  Further Details                                                      
!  ===============                                                      
!                                                                       
!  The matrix Q is represented as a product of elementary reflectors    
!                                                                       
!     Q = H(k)' . . . H(2)' H(1)', where k = min(m,n).                  
!                                                                       
!  Each H(i) has the form                                               
!                                                                       
!     H(i) = I - tau * v * v'                                           
!                                                                       
!  where tau is a complex scalar, and v is a complex vector with        
!  v(1:i-1) = 0 and v(i) = 1; conjg(v(i+1:n)) is stored on exit in      
!  A(i,i+1:n), and tau in TAU(i).                                       
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      LOGICAL            LQUERY                                         
      INTEGER            I, IB, IINFO, IWS, K, LDWORK, LWKOPT, NB,        &
                         NBMIN, NX                                      
!     ..                                                                
!     .. External Subroutines ..                                        
!     EXTERNAL           CSVD_CGELQ2, CSVD_CLARFB, CSVD_CLARFT, CSVD_XERBLA
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN                                       
!     ..                                                                
!     .. External Functions ..                                          
!      INTEGER            csvd_ilaenv                                         
!      EXTERNAL           csvd_ilaenv                                         
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      INFO = 0                                                          
      NB = csvd_ilaenv( 1, 'CSVD_CGELQF', ' ', M, N, -1, -1 )
      LWKOPT = M*NB                                                     
      WORK( 1 ) = LWKOPT                                                
      LQUERY = ( LWORK.EQ.-1 )                                          
      IF( M.LT.0 ) THEN                                                 
         INFO = -1                                                      
      ELSE IF( N.LT.0 ) THEN                                            
         INFO = -2                                                      
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN                                
         INFO = -4                                                      
      ELSE IF( LWORK.LT.MAX( 1, M ) .AND. .NOT.LQUERY ) THEN            
         INFO = -7                                                      
      END IF                                                            
      IF( INFO.NE.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_CGELQF', -INFO )
         RETURN                                                         
      ELSE IF( LQUERY ) THEN                                            
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible                                          
!                                                                       
      K = MIN( M, N )                                                   
      IF( K.EQ.0 ) THEN                                                 
         WORK( 1 ) = 1                                                  
         RETURN                                                         
      END IF                                                            
!                                                                       
      NBMIN = 2                                                         
      NX = 0                                                            
      IWS = M                                                           
      IF( NB.GT.1 .AND. NB.LT.K ) THEN                                  
!                                                                       
!        Determine when to cross over from blocked to unblocked code.   
!                                                                       
         NX = MAX( 0, csvd_ilaenv( 3, 'CSVD_CGELQF', ' ', M, N, -1, -1 ) )
         IF( NX.LT.K ) THEN                                             
!                                                                       
!           Determine if workspace is large enough for blocked code.    
!                                                                       
            LDWORK = M                                                  
            IWS = LDWORK*NB                                             
            IF( LWORK.LT.IWS ) THEN                                     
!                                                                       
!              Not enough workspace to use optimal NB:  reduce NB and   
!              determine the minimum value of NB.                       
!                                                                       
               NB = LWORK / LDWORK                                      
               NBMIN = MAX( 2, csvd_ilaenv( 2, 'CSVD_CGELQF', ' ', M, N, -1,  &
                       -1 ) )                                           
            END IF                                                      
         END IF                                                         
      END IF                                                            
!                                                                       
      IF( NB.GE.NBMIN .AND. NB.LT.K .AND. NX.LT.K ) THEN                
!                                                                       
!        Use blocked code initially                                     
!                                                                       
         DO 10 I = 1, K - NX, NB                                        
            IB = MIN( K-I+1, NB )                                       
!                                                                       
!           Compute the LQ factorization of the current block           
!           A(i:i+ib-1,i:n)                                             
!                                                                       
            CALL CSVD_CGELQ2( IB, N-I+1, A( I, I ), LDA, TAU( I ), WORK,       &
                         IINFO )                                        
            IF( I+IB.LE.M ) THEN                                        
!                                                                       
!              Form the triangular factor of the block reflector        
!              H = H(i) H(i+1) . . . H(i+ib-1)                          
!                                                                       
               CALL CSVD_CLARFT( 'Forward', 'Rowwise', N-I+1, IB, A( I, I ),   &
                            LDA, TAU( I ), WORK, LDWORK )               
!                                                                       
!              Apply H to A(i+ib:m,i:n) from the right                  
!                                                                       
               CALL CSVD_CLARFB( 'Right', 'No transpose', 'Forward',           &
                            'Rowwise', M-I-IB+1, N-I+1, IB, A( I, I ),    &
                            LDA, WORK, LDWORK, A( I+IB, I ), LDA,         &
                            WORK( IB+1 ), LDWORK )                      
            END IF                                                      
   10    CONTINUE                                                       
      ELSE                                                              
         I = 1                                                          
      END IF                                                            
!                                                                       
!     Use unblocked code to factor the last or only block.              
!                                                                       
      IF( I.LE.K )                                                        &
         CALL CSVD_CGELQ2( M-I+1, N-I+1, A( I, I ), LDA, TAU( I ), WORK,       &
                      IINFO )                                           
!                                                                       
      WORK( 1 ) = IWS                                                   
      RETURN                                                            
!                                                                       
!     End of CSVD_CGELQF                                                     
!                                                                       
      END SUBROUTINE CSVD_CGELQF

      SUBROUTINE CSVD_CGEQR2( M, N, A, LDA, TAU, WORK, INFO )                
!                                                                       
!  -- LAPACK routine (version 3.0) --                                   
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     September 30, 1994                                                
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, LDA, M, N                                
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * ), TAU( * ), WORK( * )               
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CGEQR2 computes a QR factorization of a complex m by n matrix A:     
!  A = Q * R.                                                           
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix A.  M &gt;= 0.              
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix A.  N &gt;= 0.           
!                                                                       
!  A       (input/output) COMPLEX array, dimension (LDA,N)              
!          On entry, the m by n matrix A.                               
!          On exit, the elements on and above the diagonal of the array 
!          contain the min(m,n) by n upper trapezoidal matrix R (R is   
!          upper triangular if m &gt;= n); the elements below the diagon
!          with the array TAU, represent the unitary matrix Q as a      
!          product of elementary reflectors (see Further Details).      
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA &gt;= max(1,M).   
!                                                                       
!  TAU     (output) COMPLEX array, dimension (min(M,N))                 
!          The scalar factors of the elementary reflectors (see Further 
!          Details).                                                    
!                                                                       
!  WORK    (workspace) COMPLEX array, dimension (N)                     
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0: successful exit                                         
!          &lt; 0: if INFO = -i, the i-th argument had an illegal value 
!                                                                       
!  Further Details                                                      
!  ===============                                                      
!                                                                       
!  The matrix Q is represented as a product of elementary reflectors    
!                                                                       
!     Q = H(1) H(2) . . . H(k), where k = min(m,n).                     
!                                                                       
!  Each H(i) has the form                                               
!                                                                       
!     H(i) = I - tau * v * v'                                           
!                                                                       
!  where tau is a complex scalar, and v is a complex vector with        
!  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i), 
!  and tau in TAU(i).                                                   
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      COMPLEX            ONE                                            
!      PARAMETER          ( ONE = CMPLX( 1.0E+0, 0.0E+0 ) )
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, K                                           
      COMPLEX            ALPHA                                          
!     ..                                                                
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_CLARF, CSVD_CLARFG, CSVD_XERBLA
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          CONJG, MAX, MIN                                
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      ONE = CMPLX( 1.0E+0, 0.0E+0 )

      INFO = 0                                                          
      IF( M.LT.0 ) THEN                                                 
         INFO = -1                                                      
      ELSE IF( N.LT.0 ) THEN                                            
         INFO = -2                                                      
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN                                
         INFO = -4                                                      
      END IF                                                            
      IF( INFO.NE.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_CGEQR2', -INFO )
         RETURN                                                         
      END IF                                                            
!                                                                       
      K = MIN( M, N )                                                   
!                                                                       
      DO 10 I = 1, K                                                    
!                                                                       
!        Generate elementary reflector H(i) to annihilate A(i+1:m,i)    
!                                                                       
         CALL CSVD_CLARFG( M-I+1, A( I, I ), A( MIN( I+1, M ), I ), 1,         &
                      TAU( I ) )                                        
         IF( I.LT.N ) THEN                                              
!                                                                       
!           Apply H(i)' to A(i:m,i+1:n) from the left                   
!                                                                       
            ALPHA = A( I, I )                                           
            A( I, I ) = ONE                                             
            CALL CSVD_CLARF( 'Left', M-I+1, N-I, A( I, I ), 1,                 &
                        CONJG( TAU( I ) ), A( I, I+1 ), LDA, WORK )     
            A( I, I ) = ALPHA                                           
         END IF                                                         
   10 CONTINUE                                                          
      RETURN                                                            
!                                                                       
!     End of CSVD_CGEQR2                                                     
!                                                                       
      END SUBROUTINE CSVD_CGEQR2 

      SUBROUTINE CSVD_CGEQRF( M, N, A, LDA, TAU, WORK, LWORK, INFO )         
!                                                                       
!  -- LAPACK routine (version 3.0) --                                   
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     June 30, 1999                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, LDA, LWORK, M, N                         
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * ), TAU( * ), WORK( * )               
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CGEQRF computes a QR factorization of a complex M-by-N matrix A:     
!  A = Q * R.                                                           
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix A.  M &gt;= 0.              
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix A.  N &gt;= 0.           
!                                                                       
!  A       (input/output) COMPLEX array, dimension (LDA,N)              
!          On entry, the M-by-N matrix A.                               
!          On exit, the elements on and above the diagonal of the array 
!          contain the min(M,N)-by-N upper trapezoidal matrix R (R is   
!          upper triangular if m &gt;= n); the elements below the diagon
!          with the array TAU, represent the unitary matrix Q as a      
!          product of min(m,n) elementary reflectors (see Further       
!          Details).                                                    
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA &gt;= max(1,M).   
!                                                                       
!  TAU     (output) COMPLEX array, dimension (min(M,N))                 
!          The scalar factors of the elementary reflectors (see Further 
!          Details).                                                    
!                                                                       
!  WORK    (workspace/output) COMPLEX array, dimension (LWORK)          
!          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.     
!                                                                       
!  LWORK   (input) INTEGER                                              
!          The dimension of the array WORK.  LWORK &gt;= max(1,N).      
!          For optimum performance LWORK &gt;= N*NB, where NB is        
!          the optimal blocksize.                                       
!                                                                       
!          If LWORK = -1, then a workspace query is assumed; the routine
!          only calculates the optimal size of the WORK array, returns  
!          this value as the first entry of the WORK array, and no error
!          message related to LWORK is issued by CSVD_XERBLA.                
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0:  successful exit                                        
!          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
!                                                                       
!  Further Details                                                      
!  ===============                                                      
!                                                                       
!  The matrix Q is represented as a product of elementary reflectors    
!                                                                       
!     Q = H(1) H(2) . . . H(k), where k = min(m,n).                     
!                                                                       
!  Each H(i) has the form                                               
!                                                                       
!     H(i) = I - tau * v * v'                                           
!                                                                       
!  where tau is a complex scalar, and v is a complex vector with        
!  v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i), 
!  and tau in TAU(i).                                                   
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      LOGICAL            LQUERY                                         
      INTEGER            I, IB, IINFO, IWS, K, LDWORK, LWKOPT, NB,        &
                         NBMIN, NX                                      
!     ..                                                                
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_CGEQR2, CSVD_CLARFB, CSVD_CLARFT, CSVD_XERBLA
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN                                       
!     ..                                                                
!     .. External Functions ..                                          
!      INTEGER            csvd_ilaenv                                         
!      EXTERNAL           csvd_ilaenv                                         
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      INFO = 0                                                          
      NB = csvd_ilaenv( 1, 'CSVD_CGEQRF', ' ', M, N, -1, -1 )
      LWKOPT = N*NB                                                     
      WORK( 1 ) = LWKOPT                                                
      LQUERY = ( LWORK.EQ.-1 )                                          
      IF( M.LT.0 ) THEN                                                 
         INFO = -1                                                      
      ELSE IF( N.LT.0 ) THEN                                            
         INFO = -2                                                      
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN                                
         INFO = -4                                                      
      ELSE IF( LWORK.LT.MAX( 1, N ) .AND. .NOT.LQUERY ) THEN            
         INFO = -7                                                      
      END IF                                                            
      IF( INFO.NE.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_CGEQRF', -INFO )
         RETURN                                                         
      ELSE IF( LQUERY ) THEN                                            
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible                                          
!                                                                       
      K = MIN( M, N )                                                   
      IF( K.EQ.0 ) THEN                                                 
         WORK( 1 ) = 1                                                  
         RETURN                                                         
      END IF                                                            
!                                                                       
      NBMIN = 2                                                         
      NX = 0                                                            
      IWS = N                                                           
      IF( NB.GT.1 .AND. NB.LT.K ) THEN                                  
!                                                                       
!        Determine when to cross over from blocked to unblocked code.   
!                                                                       
         NX = MAX( 0, csvd_ilaenv( 3, 'CSVD_CGEQRF', ' ', M, N, -1, -1 ) )
         IF( NX.LT.K ) THEN                                             
!                                                                       
!           Determine if workspace is large enough for blocked code.    
!                                                                       
            LDWORK = N                                                  
            IWS = LDWORK*NB                                             
            IF( LWORK.LT.IWS ) THEN                                     
!                                                                       
!              Not enough workspace to use optimal NB:  reduce NB and   
!              determine the minimum value of NB.                       
!                                                                       
               NB = LWORK / LDWORK                                      
               NBMIN = MAX( 2, csvd_ilaenv( 2, 'CSVD_CGEQRF', ' ', M, N, -1,  &
                       -1 ) )                                           
            END IF                                                      
         END IF                                                         
      END IF                                                            
!                                                                       
      IF( NB.GE.NBMIN .AND. NB.LT.K .AND. NX.LT.K ) THEN                
!                                                                       
!        Use blocked code initially                                     
!                                                                       
         DO 10 I = 1, K - NX, NB                                        
            IB = MIN( K-I+1, NB )                                       
!                                                                       
!           Compute the QR factorization of the current block           
!           A(i:m,i:i+ib-1)                                             
!                                                                       
            CALL CSVD_CGEQR2( M-I+1, IB, A( I, I ), LDA, TAU( I ), WORK,       &
                         IINFO )                                        
            IF( I+IB.LE.N ) THEN                                        
!                                                                       
!              Form the triangular factor of the block reflector        
!              H = H(i) H(i+1) . . . H(i+ib-1)                          
!                                                                       
               CALL CSVD_CLARFT( 'Forward', 'Columnwise', M-I+1, IB,           &
                            A( I, I ), LDA, TAU( I ), WORK, LDWORK )    
!                                                                       
!              Apply H' to A(i:m,i+ib:n) from the left                  
!                                                                       
               CALL CSVD_CLARFB( 'Left', 'Conjugate transpose', 'Forward',     &
                            'Columnwise', M-I+1, N-I-IB+1, IB,            &
                            A( I, I ), LDA, WORK, LDWORK, A( I, I+IB ),   &
                            LDA, WORK( IB+1 ), LDWORK )                 
            END IF                                                      
   10    CONTINUE                                                       
      ELSE                                                              
         I = 1                                                          
      END IF                                                            
!                                                                       
!     Use unblocked code to factor the last or only block.              
!                                                                       
      IF( I.LE.K )                                                        &
         CALL CSVD_CGEQR2( M-I+1, N-I+1, A( I, I ), LDA, TAU( I ), WORK,       &
                      IINFO )                                           
!                                                                       
      WORK( 1 ) = IWS                                                   
      RETURN                                                            
!                                                                       
!     End of CSVD_CGEQRF                                                     
!                                                                       
      END SUBROUTINE CSVD_CGEQRF
!
      SUBROUTINE CSVD_CLABRD( M, N, NB, A, LDA, D, E, TAUQ, TAUP, X, LDX, Y, &
                         LDY )
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     September 30, 1994                                                
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            LDA, LDX, LDY, M, N, NB                        
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               D( * ), E( * )                                 
      COMPLEX            A( LDA, * ), TAUP( * ), TAUQ( * ), X( LDX, * ),  &
                         Y( LDY, * )                                    
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CLABRD reduces the first NB rows and columns of a complex general    
!  m by n matrix A to upper or lower real bidiagonal form by a unitary  
!  transformation Q' * A * P, and returns the matrices X and Y which    
!  are needed to apply the transformation to the unreduced part of A.   
!                                                                       
!  If m &gt;= n, A is reduced to upper bidiagonal form; if m &lt; n, to 
!  bidiagonal form.                                                     
!                                                                       
!  This is an auxiliary routine called by CSVD_CGEBRD                        
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows in the matrix A.                          
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns in the matrix A.                       
!                                                                       
!  NB      (input) INTEGER                                              
!          The number of leading rows and columns of A to be reduced.   
!                                                                       
!  A       (input/output) COMPLEX array, dimension (LDA,N)              
!          On entry, the m by n general matrix to be reduced.           
!          On exit, the first NB rows and columns of the matrix are     
!          overwritten; the rest of the array is unchanged.             
!          If m &gt;= n, elements on and below the diagonal in the first
!            columns, with the array TAUQ, represent the unitary        
!            matrix Q as a product of elementary reflectors; and        
!            elements above the diagonal in the first NB rows, with the 
!            array TAUP, represent the unitary matrix P as a product    
!            of elementary reflectors.                                  
!          If m &lt; n, elements below the diagonal in the first NB     
!            columns, with the array TAUQ, represent the unitary        
!            matrix Q as a product of elementary reflectors, and        
!            elements on and above the diagonal in the first NB rows,   
!            with the array TAUP, represent the unitary matrix P as     
!            a product of elementary reflectors.                        
!          See Further Details.                                         
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA &gt;= max(1,M).   
!                                                                       
!  D       (output) REAL array, dimension (NB)                          
!          The diagonal elements of the first NB rows and columns of    
!          the reduced matrix.  D(i) = A(i,i).                          
!                                                                       
!  E       (output) REAL array, dimension (NB)                          
!          The off-diagonal elements of the first NB rows and columns of
!          the reduced matrix.                                          
!                                                                       
!  TAUQ    (output) COMPLEX array dimension (NB)                        
!          The scalar factors of the elementary reflectors which        
!          represent the unitary matrix Q. See Further Details.         
!                                                                       
!  TAUP    (output) COMPLEX array, dimension (NB)                       
!          The scalar factors of the elementary reflectors which        
!          represent the unitary matrix P. See Further Details.         
!                                                                       
!  X       (output) COMPLEX array, dimension (LDX,NB)                   
!          The m-by-nb matrix X required to update the unreduced part   
!          of A.                                                        
!                                                                       
!  LDX     (input) INTEGER                                              
!          The leading dimension of the array X. LDX &gt;= max(1,M).    
!                                                                       
!  Y       (output) COMPLEX array, dimension (LDY,NB)                   
!          The n-by-nb matrix Y required to update the unreduced part   
!          of A.                                                        
!                                                                       
!  LDY     (output) INTEGER                                             
!          The leading dimension of the array Y. LDY &gt;= max(1,N).    
!                                                                       
!  Further Details                                                      
!  ===============                                                      
!                                                                       
!  The matrices Q and P are represented as products of elementary       
!  reflectors:                                                          
!                                                                       
!     Q = H(1) H(2) . . . H(nb)  and  P = G(1) G(2) . . . G(nb)         
!                                                                       
!  Each H(i) and G(i) has the form:                                     
!                                                                       
!     H(i) = I - tauq * v * v'  and G(i) = I - taup * u * u'            
!                                                                       
!  where tauq and taup are complex scalars, and v and u are complex     
!  vectors.                                                             
!                                                                       
!  If m &gt;= n, v(1:i-1) = 0, v(i) = 1, and v(i:m) is stored on exit in
!  A(i:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+1:n) is stored on exit in  
!  A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).           
!                                                                       
!  If m &lt; n, v(1:i) = 0, v(i+1) = 1, and v(i+1:m) is stored on exit i
!  A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i:n) is stored on exit in  
!  A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).           
!                                                                       
!  The elements of the vectors v and u together form the m-by-nb matrix 
!  V and the nb-by-n matrix U' which are needed, with X and Y, to apply 
!  the transformation to the unreduced part of the matrix, using a block
!  update of the form:  A := A - V*Y' - X*U'.                           
!                                                                       
!  The contents of A on exit are illustrated by the following examples  
!  with nb = 2:                                                         
!                                                                       
!  m = 6 and n = 5 (m &gt; n):          m = 5 and n = 6 (m &lt; n):     
!                                                                       
!    (  1   1   u1  u1  u1 )           (  1   u1  u1  u1  u1  u1 )      
!    (  v1  1   1   u2  u2 )           (  1   1   u2  u2  u2  u2 )      
!    (  v1  v2  a   a   a  )           (  v1  1   a   a   a   a  )      
!    (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )      
!    (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )      
!    (  v1  v2  a   a   a  )                                            
!                                                                       
!  where a denotes an element of the original matrix which is unchanged,
!  vi denotes an element of the vector defining H(i), and ui an element 
!  of the vector defining G(i).                                         
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      COMPLEX            ZERO, ONE                                      
!      PARAMETER          ( ZERO = CMPLX( 0.0E+0, 0.0E+0 ),            &
!                         ONE = CMPLX( 1.0E+0, 0.0E+0 ) )
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I                                              
      COMPLEX            ALPHA                                          
!     ..                                                                
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_CGEMV, CSVD_CLACGV, CSVD_CLARFG, CSVD_cscal
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MIN                                            
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Quick return if possible                                          
!                                                                       

      ZERO = CMPLX( 0.0E+0, 0.0E+0 )
      ONE = CMPLX( 1.0E+0, 0.0E+0 )

      IF( M.LE.0 .OR. N.LE.0 )                                            &
         RETURN                                                         
!                                                                       
      IF( M.GE.N ) THEN                                                 
!                                                                       
!        Reduce to upper bidiagonal form                                
!                                                                       
         DO 10 I = 1, NB                                                
!                                                                       
!           Update A(i:m,i)                                             
!                                                                       
            CALL CSVD_CLACGV( I-1, Y( I, 1 ), LDY )                          
            CALL CSVD_CGEMV( 'No transpose', M-I+1, I-1, -ONE, A( I, 1 ),      &
                        LDA, Y( I, 1 ), LDY, ONE, A( I, I ), 1 )        
            CALL CSVD_CLACGV( I-1, Y( I, 1 ), LDY )                          
            CALL CSVD_CGEMV( 'No transpose', M-I+1, I-1, -ONE, X( I, 1 ),      &
                        LDX, A( 1, I ), 1, ONE, A( I, I ), 1 )          
!                                                                       
!           Generate reflection Q(i) to annihilate A(i+1:m,i)           
!                                                                       
            ALPHA = A( I, I )                                           
            CALL CSVD_CLARFG( M-I+1, ALPHA, A( MIN( I+1, M ), I ), 1,          &
                         TAUQ( I ) )                                    
            D( I ) = ALPHA                                              
            IF( I.LT.N ) THEN                                           
               A( I, I ) = ONE                                          
!                                                                       
!              Compute Y(i+1:n,i)                                       
!                                                                       
               CALL CSVD_CGEMV( 'Conjugate transpose', M-I+1, N-I, ONE,        &
                           A( I, I+1 ), LDA, A( I, I ), 1, ZERO,          &
                           Y( I+1, I ), 1 )                             
               CALL CSVD_CGEMV( 'Conjugate transpose', M-I+1, I-1, ONE,        &
                           A( I, 1 ), LDA, A( I, I ), 1, ZERO,            &
                           Y( 1, I ), 1 )                               
               CALL CSVD_CGEMV( 'No transpose', N-I, I-1, -ONE, Y( I+1, 1 ),   &
                           LDY, Y( 1, I ), 1, ONE, Y( I+1, I ), 1 )     
               CALL CSVD_CGEMV( 'Conjugate transpose', M-I+1, I-1, ONE,        &
                           X( I, 1 ), LDX, A( I, I ), 1, ZERO,            &
                           Y( 1, I ), 1 )                               
               CALL CSVD_CGEMV( 'Conjugate transpose', I-1, N-I, -ONE,         &
                           A( 1, I+1 ), LDA, Y( 1, I ), 1, ONE,           &
                           Y( I+1, I ), 1 )                             
               CALL CSVD_cscal( N-I, TAUQ( I ), Y( I+1, I ), 1 )             
!                                                                       
!              Update A(i,i+1:n)                                        
!                                                                       
               CALL CSVD_CLACGV( N-I, A( I, I+1 ), LDA )                     
               CALL CSVD_CLACGV( I, A( I, 1 ), LDA )                         
               CALL CSVD_CGEMV( 'No transpose', N-I, I, -ONE, Y( I+1, 1 ),     &
                           LDY, A( I, 1 ), LDA, ONE, A( I, I+1 ), LDA ) 
               CALL CSVD_CLACGV( I, A( I, 1 ), LDA )                         
               CALL CSVD_CLACGV( I-1, X( I, 1 ), LDX )                       
               CALL CSVD_CGEMV( 'Conjugate transpose', I-1, N-I, -ONE,         &
                           A( 1, I+1 ), LDA, X( I, 1 ), LDX, ONE,         &
                           A( I, I+1 ), LDA )                           
               CALL CSVD_CLACGV( I-1, X( I, 1 ), LDX )                       
!                                                                       
!              Generate reflection P(i) to annihilate A(i,i+2:n)        
!                                                                       
               ALPHA = A( I, I+1 )                                      
               CALL CSVD_CLARFG( N-I, ALPHA, A( I, MIN( I+2, N ) ),            &
                            LDA, TAUP( I ) )                            
               E( I ) = ALPHA                                           
               A( I, I+1 ) = ONE                                        
!                                                                       
!              Compute X(i+1:m,i)                                       
!                                                                       
               CALL CSVD_CGEMV( 'No transpose', M-I, N-I, ONE, A( I+1, I+1 ),  &
                           LDA, A( I, I+1 ), LDA, ZERO, X( I+1, I ), 1 )
               CALL CSVD_CGEMV( 'Conjugate transpose', N-I, I, ONE,            &
                           Y( I+1, 1 ), LDY, A( I, I+1 ), LDA, ZERO,      &
                           X( 1, I ), 1 )                               
               CALL CSVD_CGEMV( 'No transpose', M-I, I, -ONE, A( I+1, 1 ),     &
                           LDA, X( 1, I ), 1, ONE, X( I+1, I ), 1 )     
               CALL CSVD_CGEMV( 'No transpose', I-1, N-I, ONE, A( 1, I+1 ),    &
                           LDA, A( I, I+1 ), LDA, ZERO, X( 1, I ), 1 )  
               CALL CSVD_CGEMV( 'No transpose', M-I, I-1, -ONE, X( I+1, 1 ),   &
                           LDX, X( 1, I ), 1, ONE, X( I+1, I ), 1 )     
               CALL CSVD_cscal( M-I, TAUP( I ), X( I+1, I ), 1 )             
               CALL CSVD_CLACGV( N-I, A( I, I+1 ), LDA )                     
            END IF                                                      
   10    CONTINUE                                                       
      ELSE                                                              
!                                                                       
!        Reduce to lower bidiagonal form                                
!                                                                       
         DO 20 I = 1, NB                                                
!                                                                       
!           Update A(i,i:n)                                             
!                                                                       
            CALL CSVD_CLACGV( N-I+1, A( I, I ), LDA )                        
            CALL CSVD_CLACGV( I-1, A( I, 1 ), LDA )                          
            CALL CSVD_CGEMV( 'No transpose', N-I+1, I-1, -ONE, Y( I, 1 ),      &
                        LDY, A( I, 1 ), LDA, ONE, A( I, I ), LDA )      
            CALL CSVD_CLACGV( I-1, A( I, 1 ), LDA )                          
            CALL CSVD_CLACGV( I-1, X( I, 1 ), LDX )                          
            CALL CSVD_CGEMV( 'Conjugate transpose', I-1, N-I+1, -ONE,          &
                        A( 1, I ), LDA, X( I, 1 ), LDX, ONE, A( I, I ),   &
                        LDA )                                           
            CALL CSVD_CLACGV( I-1, X( I, 1 ), LDX )                          
!                                                                       
!           Generate reflection P(i) to annihilate A(i,i+1:n)           
!                                                                       
            ALPHA = A( I, I )                                           
            CALL CSVD_CLARFG( N-I+1, ALPHA, A( I, MIN( I+1, N ) ), LDA,        &
                         TAUP( I ) )                                    
            D( I ) = ALPHA                                              
            IF( I.LT.M ) THEN                                           
               A( I, I ) = ONE                                          
!                                                                       
!              Compute X(i+1:m,i)                                       
!                                                                       
               CALL CSVD_CGEMV( 'No transpose', M-I, N-I+1, ONE, A( I+1, I ),  &
                           LDA, A( I, I ), LDA, ZERO, X( I+1, I ), 1 )  
               CALL CSVD_CGEMV( 'Conjugate transpose', N-I+1, I-1, ONE,        &
                           Y( I, 1 ), LDY, A( I, I ), LDA, ZERO,          &
                           X( 1, I ), 1 )                               
               CALL CSVD_CGEMV( 'No transpose', M-I, I-1, -ONE, A( I+1, 1 ),   &
                           LDA, X( 1, I ), 1, ONE, X( I+1, I ), 1 )     
               CALL CSVD_CGEMV( 'No transpose', I-1, N-I+1, ONE, A( 1, I ),    &
                           LDA, A( I, I ), LDA, ZERO, X( 1, I ), 1 )    
               CALL CSVD_CGEMV( 'No transpose', M-I, I-1, -ONE, X( I+1, 1 ),   &
                           LDX, X( 1, I ), 1, ONE, X( I+1, I ), 1 )     
               CALL CSVD_cscal( M-I, TAUP( I ), X( I+1, I ), 1 )             
               CALL CSVD_CLACGV( N-I+1, A( I, I ), LDA )                     
!                                                                       
!              Update A(i+1:m,i)                                        
!                                                                       
               CALL CSVD_CLACGV( I-1, Y( I, 1 ), LDY )                       
               CALL CSVD_CGEMV( 'No transpose', M-I, I-1, -ONE, A( I+1, 1 ),   &
                           LDA, Y( I, 1 ), LDY, ONE, A( I+1, I ), 1 )   
               CALL CSVD_CLACGV( I-1, Y( I, 1 ), LDY )                       
               CALL CSVD_CGEMV( 'No transpose', M-I, I, -ONE, X( I+1, 1 ),     &
                           LDX, A( 1, I ), 1, ONE, A( I+1, I ), 1 )     
!                                                                       
!              Generate reflection Q(i) to annihilate A(i+2:m,i)        
!                                                                       
               ALPHA = A( I+1, I )                                      
               CALL CSVD_CLARFG( M-I, ALPHA, A( MIN( I+2, M ), I ), 1,         &
                            TAUQ( I ) )                                 
               E( I ) = ALPHA                                           
               A( I+1, I ) = ONE                                        
!                                                                       
!              Compute Y(i+1:n,i)                                       
!                                                                       
               CALL CSVD_CGEMV( 'Conjugate transpose', M-I, N-I, ONE,          &
                           A( I+1, I+1 ), LDA, A( I+1, I ), 1, ZERO,      &
                           Y( I+1, I ), 1 )                             
               CALL CSVD_CGEMV( 'Conjugate transpose', M-I, I-1, ONE,          &
                           A( I+1, 1 ), LDA, A( I+1, I ), 1, ZERO,        &
                           Y( 1, I ), 1 )                               
               CALL CSVD_CGEMV( 'No transpose', N-I, I-1, -ONE, Y( I+1, 1 ),   &
                           LDY, Y( 1, I ), 1, ONE, Y( I+1, I ), 1 )     
               CALL CSVD_CGEMV( 'Conjugate transpose', M-I, I, ONE,            &
                           X( I+1, 1 ), LDX, A( I+1, I ), 1, ZERO,        &
                           Y( 1, I ), 1 )                               
               CALL CSVD_CGEMV( 'Conjugate transpose', I, N-I, -ONE,           &
                           A( 1, I+1 ), LDA, Y( 1, I ), 1, ONE,           &
                           Y( I+1, I ), 1 )                             
               CALL CSVD_cscal( N-I, TAUQ( I ), Y( I+1, I ), 1 )             
            ELSE                                                        
               CALL CSVD_CLACGV( N-I+1, A( I, I ), LDA )                     
            END IF                                                      
   20    CONTINUE                                                       
      END IF                                                            
      RETURN                                                            
!                                                                       
!     End of CSVD_CLABRD                                                     
!                                                                       
      END SUBROUTINE CSVD_CLABRD
                                                               
      SUBROUTINE CSVD_CLACGV( N, X, INCX )                                   
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     October 31, 1992                                                  
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INCX, N                                        
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            X( * )                                         
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CLACGV conjugates a complex vector of length N.                      
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  N       (input) INTEGER                                              
!          The length of the vector X.  N &gt;= 0.                      
!                                                                       
!  X       (input/output) COMPLEX array, dimension                      
!                         (1+(N-1)*abs(INCX))                           
!          On entry, the vector of length N to be conjugated.           
!          On exit, X is overwritten with conjg(X).                     
!                                                                       
!  INCX    (input) INTEGER                                              
!          The spacing between successive elements of X.                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Local Scalars ..                                               
      INTEGER            I, IOFF                                        
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          CONJG                                          
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( INCX.EQ.1 ) THEN                                              
         DO 10 I = 1, N                                                 
            X( I ) = CONJG( X( I ) )                                    
   10    CONTINUE                                                       
      ELSE                                                              
         IOFF = 1                                                       
         IF( INCX.LT.0 )                                                  &
            IOFF = 1 - ( N-1 )*INCX                                     
         DO 20 I = 1, N                                                 
            X( IOFF ) = CONJG( X( IOFF ) )                              
            IOFF = IOFF + INCX                                          
   20    CONTINUE                                                       
      END IF                                                            
      RETURN                                                            
!                                                                       
!     End of CSVD_CLACGV                                                     
!                                                                       
      END SUBROUTINE CSVD_CLACGV
                                                              
      SUBROUTINE CSVD_CLACPY( UPLO, M, N, A, LDA, B, LDB )                   
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     February 29, 1992                                                 
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          UPLO                                           
      INTEGER            LDA, LDB, M, N                                 
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * ), B( LDB, * )                       
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CLACPY copies all or part of a two-dimensional matrix A to another   
!  matrix B.                                                            
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  UPLO    (input) CHARACTER*1                                          
!          Specifies the part of the matrix A to be copied to B.        
!          = 'U':      Upper triangular part                            
!          = 'L':      Lower triangular part                            
!          Otherwise:  All of the matrix A                              
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix A.  M &gt;= 0.              
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix A.  N &gt;= 0.           
!                                                                       
!  A       (input) COMPLEX array, dimension (LDA,N)                     
!          The m by n matrix A.  If UPLO = 'U', only the upper trapezium
!          is accessed; if UPLO = 'L', only the lower trapezium is      
!          accessed.                                                    
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA &gt;= max(1,M).   
!                                                                       
!  B       (output) COMPLEX array, dimension (LDB,N)                    
!          On exit, B = A in the locations specified by UPLO.           
!                                                                       
!  LDB     (input) INTEGER                                              
!          The leading dimension of the array B.  LDB &gt;= max(1,M).   
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      INTEGER            I, J                                           
!     ..                                                                
!     .. External Functions ..                                          
!      LOGICAL            csvd_lsame                                          
!      EXTERNAL           csvd_lsame                                          
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MIN                                            
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( csvd_lsame( UPLO, 'U' ) ) THEN                                     
         DO 20 J = 1, N                                                 
            DO 10 I = 1, MIN( J, M )                                    
               B( I, J ) = A( I, J )                                    
   10       CONTINUE                                                    
   20    CONTINUE                                                       
!                                                                       
      ELSE IF( csvd_lsame( UPLO, 'L' ) ) THEN                                
         DO 40 J = 1, N                                                 
            DO 30 I = J, M                                              
               B( I, J ) = A( I, J )                                    
   30       CONTINUE                                                    
   40    CONTINUE                                                       
!                                                                       
      ELSE                                                              
         DO 60 J = 1, N                                                 
            DO 50 I = 1, M                                              
               B( I, J ) = A( I, J )                                    
   50       CONTINUE                                                    
   60    CONTINUE                                                       
      END IF                                                            
!                                                                       
      RETURN                                                            
!                                                                       
!     End of CSVD_CLACPY                                                     
!                                                                       
      END SUBROUTINE CSVD_CLACPY
                                                              
      COMPLEX FUNCTION csvd_cladiv( X, Y )                                   
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     October 31, 1992                                                  
!                                                                       
!     .. Scalar Arguments ..                                            
      COMPLEX            X, Y                                           
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CLADIV := X / Y, where X and Y are complex.  The computation of X / Y
!  will not overflow on an intermediary step unless the results         
!  overflows.                                                           
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  X       (input) COMPLEX                                              
!  Y       (input) COMPLEX                                              
!          The complex scalars X and Y.                                 
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      REAL               ZI, ZR                                         
!     ..                                                                
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_SLADIV                                         
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          AIMAG, CMPLX, REAL                             
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      CALL CSVD_SLADIV( REAL( X ), AIMAG( X ), REAL( Y ), AIMAG( Y ), ZR,      &
                   ZI )                                                 
      csvd_cladiv = CMPLX( ZR, ZI )                                          
!                                                                       
      RETURN                                                            
!                                                                       
!     End of csvd_cladiv                                                     
!                                                                       
      END FUNCTION csvd_cladiv 
                                                              
      REAL             FUNCTION csvd_clange( NORM, M, N, A, LDA, WORK )      
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     October 31, 1992                                                  
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          NORM                                           
      INTEGER            LDA, M, N                                      
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               WORK( * )                                      
      COMPLEX            A( LDA, * )                                    
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  csvd_clange  returns the value of the one norm,  or the Frobenius norm, or
!  the  infinity norm,  or the  element of  largest absolute value  of a
!  complex matrix A.                                                    
!                                                                       
!  Description                                                          
!  ===========                                                          
!                                                                       
!  csvd_clange returns the value                                             
!                                                                       
!     csvd_clange = ( max(abs(A(i,j))), NORM = 'M' or 'm'                    
!              (                                                        
!              ( norm1(A),         NORM = '1', 'O' or 'o'               
!              (                                                        
!              ( normI(A),         NORM = 'I' or 'i'                    
!              (                                                        
!              ( normF(A),         NORM = 'F', 'f', 'E' or 'e'          
!                                                                       
!  where  norm1  denotes the  one norm of a matrix (maximum column sum),
!  normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
!  normF  denotes the  Frobenius norm of a matrix (square root of sum of
!  squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm.       
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  NORM    (input) CHARACTER*1                                          
!          Specifies the value to be returned in csvd_clange as described    
!          above.                                                       
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix A.  M &gt;= 0.  When M = 0, 
!          csvd_clange is set to zero.                                       
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix A.  N &gt;= 0.  When N = 
!          csvd_clange is set to zero.                                       
!                                                                       
!  A       (input) COMPLEX array, dimension (LDA,N)                     
!          The m by n matrix A.                                         
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA &gt;= max(M,1).   
!                                                                       
!  WORK    (workspace) REAL array, dimension (LWORK),                   
!          where LWORK &gt;= M when NORM = 'I'; otherwise, WORK is not  
!          referenced.                                                  
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      REAL               ONE, ZERO                                      
      PARAMETER          ( ONE = 1.0E+0, ZERO = 0.0E+0 )                
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, J                                           
      REAL               SCALE, SUM, VALUE                              
!     ..                                                                
!     .. External Functions ..                                          
!      LOGICAL            csvd_lsame                                          
!      EXTERNAL           csvd_lsame                                          
!     ..                                                                
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_CLASSQ                                         
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, MIN, SQRT                            
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( MIN( M, N ).EQ.0 ) THEN                                       
         VALUE = ZERO                                                   
      ELSE IF( csvd_lsame( NORM, 'M' ) ) THEN                                
!                                                                       
!        Find max(abs(A(i,j))).                                         
!                                                                       
         VALUE = ZERO                                                   
         DO 20 J = 1, N                                                 
            DO 10 I = 1, M                                              
               VALUE = MAX( VALUE, ABS( A( I, J ) ) )                   
   10       CONTINUE                                                    
   20    CONTINUE                                                       
      ELSE IF( ( csvd_lsame( NORM, 'O' ) ) .OR. ( NORM.EQ.'1' ) ) THEN       
!                                                                       
!        Find norm1(A).                                                 
!                                                                       
         VALUE = ZERO                                                   
         DO 40 J = 1, N                                                 
            SUM = ZERO                                                  
            DO 30 I = 1, M                                              
               SUM = SUM + ABS( A( I, J ) )                             
   30       CONTINUE                                                    
            VALUE = MAX( VALUE, SUM )                                   
   40    CONTINUE                                                       
      ELSE IF( csvd_lsame( NORM, 'I' ) ) THEN                                
!                                                                       
!        Find normI(A).                                                 
!                                                                       
         DO 50 I = 1, M                                                 
            WORK( I ) = ZERO                                            
   50    CONTINUE                                                       
         DO 70 J = 1, N                                                 
            DO 60 I = 1, M                                              
               WORK( I ) = WORK( I ) + ABS( A( I, J ) )                 
   60       CONTINUE                                                    
   70    CONTINUE                                                       
         VALUE = ZERO                                                   
         DO 80 I = 1, M                                                 
            VALUE = MAX( VALUE, WORK( I ) )                             
   80    CONTINUE                                                       
      ELSE IF( ( csvd_lsame( NORM, 'F' ) ) .OR.  &
               ( csvd_lsame( NORM, 'E' ) ) ) THEN
!                                                                       
!        Find normF(A).                                                 
!                                                                       
         SCALE = ZERO                                                   
         SUM = ONE                                                      
         DO 90 J = 1, N                                                 
            CALL CSVD_CLASSQ( M, A( 1, J ), 1, SCALE, SUM )                  
   90    CONTINUE                                                       
         VALUE = SCALE*SQRT( SUM )                                      
      END IF                                                            
!                                                                       
      csvd_clange = VALUE                                                    
      RETURN                                                            
!                                                                       
!     End of csvd_clange                                                     
!                                                                       
      END  FUNCTION csvd_clange
                                                             
      SUBROUTINE CSVD_CLARF( SIDE, M, N, V, INCV, TAU, C, LDC, WORK )        
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     September 30, 1994                                                
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          SIDE                                           
      INTEGER            INCV, LDC, M, N                                
      COMPLEX            TAU                                            
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            C( LDC, * ), V( * ), WORK( * )                 
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CLARF applies a complex elementary reflector H to a complex M-by-N   
!  matrix C, from either the left or the right. H is represented in the 
!  form                                                                 
!                                                                       
!        H = I - tau * v * v'                                           
!                                                                       
!  where tau is a complex scalar and v is a complex vector.             
!                                                                       
!  If tau = 0, then H is taken to be the unit matrix.                   
!                                                                       
!  To apply H' (the conjugate transpose of H), supply conjg(tau) instead
!  tau.                                                                 
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  SIDE    (input) CHARACTER*1                                          
!          = 'L': form  H * C                                           
!          = 'R': form  C * H                                           
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix C.                          
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix C.                       
!                                                                       
!  V       (input) COMPLEX array, dimension                             
!                     (1 + (M-1)*abs(INCV)) if SIDE = 'L'               
!                  or (1 + (N-1)*abs(INCV)) if SIDE = 'R'               
!          The vector v in the representation of H. V is not used if    
!          TAU = 0.                                                     
!                                                                       
!  INCV    (input) INTEGER                                              
!          The increment between elements of v. INCV &lt;&gt; 0.        
!                                                                       
!  TAU     (input) COMPLEX                                              
!          The value tau in the representation of H.                    
!                                                                       
!  C       (input/output) COMPLEX array, dimension (LDC,N)              
!          On entry, the M-by-N matrix C.                               
!          On exit, C is overwritten by the matrix H * C if SIDE = 'L', 
!          or C * H if SIDE = 'R'.                                      
!                                                                       
!  LDC     (input) INTEGER                                              
!          The leading dimension of the array C. LDC &gt;= max(1,M).    
!                                                                       
!  WORK    (workspace) COMPLEX array, dimension                         
!                         (N) if SIDE = 'L'                             
!                      or (M) if SIDE = 'R'                             
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      COMPLEX            ONE, ZERO                                      
!      PARAMETER          ( ONE = CMPLX( 1.0E+0, 0.0E+0 ),               &
!                         ZERO = CMPLX( 0.0E+0, 0.0E+0 ) )
!     ..                                                                
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_CGEMV, CSVD_CGERC
!     ..                                                                
!     .. External Functions ..                                          
!      LOGICAL            csvd_lsame                                          
!      EXTERNAL           csvd_lsame                                          
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      ONE  = CMPLX( 1.0E+0, 0.0E+0 )               
      ZERO = CMPLX( 0.0E+0, 0.0E+0 ) 

      IF( csvd_lsame( SIDE, 'L' ) ) THEN                                     
!                                                                       
!        Form  H * C                                                    
!                                                                       
         IF( TAU.NE.ZERO ) THEN                                         
!                                                                       
!           w := C' * v                                                 
!                                                                       
            CALL CSVD_CGEMV( 'Conjugate transpose', M, N, ONE, C, LDC, V,      &
                        INCV, ZERO, WORK, 1 )                           
!                                                                       
!           C := C - v * w'                                             
!                                                                       
            CALL CSVD_CGERC( M, N, -TAU, V, INCV, WORK, 1, C, LDC )          
         END IF                                                         
      ELSE                                                              
!                                                                       
!        Form  C * H                                                    
!                                                                       
         IF( TAU.NE.ZERO ) THEN                                         
!                                                                       
!           w := C * v                                                  
!                                                                       
            CALL CSVD_CGEMV( 'No transpose', M, N, ONE, C, LDC, V, INCV,       &
                        ZERO, WORK, 1 )                                 
!                                                                       
!           C := C - w * v'                                             
!                                                                       
            CALL CSVD_CGERC( M, N, -TAU, WORK, 1, V, INCV, C, LDC )          
         END IF                                                         
      END IF                                                            
      RETURN                                                            
!                                                                       
!     End of CSVD_CLARF                                                      
!                                                                       
      END  SUBROUTINE CSVD_CLARF
                                                             
      SUBROUTINE CSVD_CLARFB( SIDE, TRANS, DIRECT, STOREV, M, N, K, V, LDV, &
                         T, LDT, C, LDC, WORK, LDWORK )                 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     September 30, 1994                                                
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          DIRECT, SIDE, STOREV, TRANS                    
      INTEGER            K, LDC, LDT, LDV, LDWORK, M, N                 
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            C( LDC, * ), T( LDT, * ), V( LDV, * ),           &
                         WORK( LDWORK, * )                              
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CLARFB applies a complex block reflector H or its transpose H' to a  
!  complex M-by-N matrix C, from either the left or the right.          
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  SIDE    (input) CHARACTER*1                                          
!          = 'L': apply H or H' from the Left                           
!          = 'R': apply H or H' from the Right                          
!                                                                       
!  TRANS   (input) CHARACTER*1                                          
!          = 'N': apply H (No transpose)                                
!          = 'C': apply H' (Conjugate transpose)                        
!                                                                       
!  DIRECT  (input) CHARACTER*1                                          
!          Indicates how H is formed from a product of elementary       
!          reflectors                                                   
!          = 'F': H = H(1) H(2) . . . H(k) (Forward)                    
!          = 'B': H = H(k) . . . H(2) H(1) (Backward)                   
!                                                                       
!  STOREV  (input) CHARACTER*1                                          
!          Indicates how the vectors which define the elementary        
!          reflectors are stored:                                       
!          = 'C': Columnwise                                            
!          = 'R': Rowwise                                               
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix C.                          
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix C.                       
!                                                                       
!  K       (input) INTEGER                                              
!          The order of the matrix T (= the number of elementary        
!          reflectors whose product defines the block reflector).       
!                                                                       
!  V       (input) COMPLEX array, dimension                             
!                                (LDV,K) if STOREV = 'C'                
!                                (LDV,M) if STOREV = 'R' and SIDE = 'L' 
!                                (LDV,N) if STOREV = 'R' and SIDE = 'R' 
!          The matrix V. See further details.                           
!                                                                       
!  LDV     (input) INTEGER                                              
!          The leading dimension of the array V.                        
!          If STOREV = 'C' and SIDE = 'L', LDV &gt;= max(1,M);          
!          if STOREV = 'C' and SIDE = 'R', LDV &gt;= max(1,N);          
!          if STOREV = 'R', LDV &gt;= K.                                
!                                                                       
!  T       (input) COMPLEX array, dimension (LDT,K)                     
!          The triangular K-by-K matrix T in the representation of the  
!          block reflector.                                             
!                                                                       
!  LDT     (input) INTEGER                                              
!          The leading dimension of the array T. LDT &gt;= K.           
!                                                                       
!  C       (input/output) COMPLEX array, dimension (LDC,N)              
!          On entry, the M-by-N matrix C.                               
!          On exit, C is overwritten by H*C or H'*C or C*H or C*H'.     
!                                                                       
!  LDC     (input) INTEGER                                              
!          The leading dimension of the array C. LDC &gt;= max(1,M).    
!                                                                       
!  WORK    (workspace) COMPLEX array, dimension (LDWORK,K)              
!                                                                       
!  LDWORK  (input) INTEGER                                              
!          The leading dimension of the array WORK.                     
!          If SIDE = 'L', LDWORK &gt;= max(1,N);                        
!          if SIDE = 'R', LDWORK &gt;= max(1,M).                        
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      COMPLEX            ONE                                            
!      PARAMETER          ( ONE = CMPLX( 1.0E+0, 0.0E+0 ) )
!     ..                                                                
!     .. Local Scalars ..                                               
      CHARACTER          TRANST                                         
      INTEGER            I, J                                           
!     ..                                                                
!     .. External Functions ..                                          
!      LOGICAL            csvd_lsame                                          
!      EXTERNAL           csvd_lsame                                          
!     ..                                                                
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_ccopy, CSVD_CGEMM, CSVD_CLACGV, CSVD_CTRMM
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          CONJG                                          
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Quick return if possible                                          
!                                                                       
      ONE  = CMPLX( 1.0E+0, 0.0E+0 )

      IF( M.LE.0 .OR. N.LE.0 )                                            &
         RETURN                                                         
!                                                                       
      IF( csvd_lsame( TRANS, 'N' ) ) THEN                                    
         TRANST = 'C'                                                   
      ELSE                                                              
         TRANST = 'N'                                                   
      END IF                                                            
!                                                                       
      IF( csvd_lsame( STOREV, 'C' ) ) THEN                                   
!                                                                       
         IF( csvd_lsame( DIRECT, 'F' ) ) THEN                                
!                                                                       
!           Let  V =  ( V1 )    (first K rows)                          
!                     ( V2 )                                            
!           where  V1  is unit lower triangular.                        
!                                                                       
            IF( csvd_lsame( SIDE, 'L' ) ) THEN                               
!                                                                       
!              Form  H * C  or  H' * C  where  C = ( C1 )               
!                                                  ( C2 )               
!                                                                       
!              W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK)      
!                                                                       
!              W := C1'                                                 
!                                                                       
               DO 10 J = 1, K                                           
                  CALL CSVD_ccopy( N, C( J, 1 ), LDC, WORK( 1, J ), 1 )      
                  CALL CSVD_CLACGV( N, WORK( 1, J ), 1 )                     
   10          CONTINUE                                                 
!                                                                       
!              W := W * V1                                              
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Lower', 'No transpose', 'Unit', N,   &
                           K, ONE, V, LDV, WORK, LDWORK )               
               IF( M.GT.K ) THEN                                        
!                                                                       
!                 W := W + C2'*V2                                       
!                                                                       
                  CALL CSVD_CGEMM( 'Conjugate transpose', 'No transpose', N,   &
                              K, M-K, ONE, C( K+1, 1 ), LDC,              &
                              V( K+1, 1 ), LDV, ONE, WORK, LDWORK )     
               END IF                                                   
!                                                                       
!              W := W * T'  or  W * T                                   
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Upper', TRANST, 'Non-unit', N, K,    &
                           ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - V * W'                                          
!                                                                       
               IF( M.GT.K ) THEN                                        
!                                                                       
!                 C2 := C2 - V2 * W'                                    
!                                                                       
                  CALL CSVD_CGEMM( 'No transpose', 'Conjugate transpose',      &
                              M-K, N, K, -ONE, V( K+1, 1 ), LDV, WORK,    &
                              LDWORK, ONE, C( K+1, 1 ), LDC )           
               END IF                                                   
!                                                                       
!              W := W * V1'                                             
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Lower', 'Conjugate transpose',       &
                           'Unit', N, K, ONE, V, LDV, WORK, LDWORK )    
!                                                                       
!              C1 := C1 - W'                                            
!                                                                       
               DO 30 J = 1, K                                           
                  DO 20 I = 1, N                                        
                     C( J, I ) = C( J, I ) - CONJG( WORK( I, J ) )      
   20             CONTINUE                                              
   30          CONTINUE                                                 
!                                                                       
            ELSE IF( csvd_lsame( SIDE, 'R' ) ) THEN                          
!                                                                       
!              Form  C * H  or  C * H'  where  C = ( C1  C2 )           
!                                                                       
!              W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)         
!                                                                       
!              W := C1                                                  
!                                                                       
               DO 40 J = 1, K                                           
                  CALL CSVD_ccopy( M, C( 1, J ), 1, WORK( 1, J ), 1 )        
   40          CONTINUE                                                 
!                                                                       
!              W := W * V1                                              
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Lower', 'No transpose', 'Unit', M,   &
                           K, ONE, V, LDV, WORK, LDWORK )               
               IF( N.GT.K ) THEN                                        
!                                                                       
!                 W := W + C2 * V2                                      
!                                                                       
                  CALL CSVD_CGEMM( 'No transpose', 'No transpose', M, K, N-K,  &
                              ONE, C( 1, K+1 ), LDC, V( K+1, 1 ), LDV,    &
                              ONE, WORK, LDWORK )                       
               END IF                                                   
!                                                                       
!              W := W * T  or  W * T'                                   
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Upper', TRANS, 'Non-unit', M, K,     &
                           ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - W * V'                                          
!                                                                       
               IF( N.GT.K ) THEN                                        
!                                                                       
!                 C2 := C2 - W * V2'                                    
!                                                                       
                  CALL CSVD_CGEMM( 'No transpose', 'Conjugate transpose', M,   &
                              N-K, K, -ONE, WORK, LDWORK, V( K+1, 1 ),    &
                              LDV, ONE, C( 1, K+1 ), LDC )              
               END IF                                                   
!                                                                       
!              W := W * V1'                                             
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Lower', 'Conjugate transpose',       &
                           'Unit', M, K, ONE, V, LDV, WORK, LDWORK )    
!                                                                       
!              C1 := C1 - W                                             
!                                                                       
               DO 60 J = 1, K                                           
                  DO 50 I = 1, M                                        
                     C( I, J ) = C( I, J ) - WORK( I, J )               
   50             CONTINUE                                              
   60          CONTINUE                                                 
            END IF                                                      
!                                                                       
         ELSE                                                           
!                                                                       
!           Let  V =  ( V1 )                                            
!                     ( V2 )    (last K rows)                           
!           where  V2  is unit upper triangular.                        
!                                                                       
            IF( csvd_lsame( SIDE, 'L' ) ) THEN                               
!                                                                       
!              Form  H * C  or  H' * C  where  C = ( C1 )               
!                                                  ( C2 )               
!                                                                       
!              W := C' * V  =  (C1'*V1 + C2'*V2)  (stored in WORK)      
!                                                                       
!              W := C2'                                                 
!                                                                       
               DO 70 J = 1, K                                           
                  CALL CSVD_ccopy( N, C( M-K+J, 1 ), LDC, WORK( 1, J ), 1 )  
                  CALL CSVD_CLACGV( N, WORK( 1, J ), 1 )                     
   70          CONTINUE                                                 
!                                                                       
!              W := W * V2                                              
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Upper', 'No transpose', 'Unit', N,   &
                           K, ONE, V( M-K+1, 1 ), LDV, WORK, LDWORK )   
               IF( M.GT.K ) THEN                                        
!                                                                       
!                 W := W + C1'*V1                                       
!                                                                       
                  CALL CSVD_CGEMM( 'Conjugate transpose', 'No transpose', N,   &
                              K, M-K, ONE, C, LDC, V, LDV, ONE, WORK,     &
                              LDWORK )                                  
               END IF                                                   
!                                                                       
!              W := W * T'  or  W * T                                   
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Lower', TRANST, 'Non-unit', N, K,    &
                           ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - V * W'                                          
!                                                                       
               IF( M.GT.K ) THEN                                        
!                                                                       
!                 C1 := C1 - V1 * W'                                    
!                                                                       
                  CALL CSVD_CGEMM( 'No transpose', 'Conjugate transpose',      &
                              M-K, N, K, -ONE, V, LDV, WORK, LDWORK,      &
                              ONE, C, LDC )                             
               END IF                                                   
!                                                                       
!              W := W * V2'                                             
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Upper', 'Conjugate transpose',       &
                           'Unit', N, K, ONE, V( M-K+1, 1 ), LDV, WORK,   &
                           LDWORK )                                     
!                                                                       
!              C2 := C2 - W'                                            
!                                                                       
               DO 90 J = 1, K                                           
                  DO 80 I = 1, N                                        
                     C( M-K+J, I ) = C( M-K+J, I ) -                      &
                                     CONJG( WORK( I, J ) )              
   80             CONTINUE                                              
   90          CONTINUE                                                 
!                                                                       
            ELSE IF( csvd_lsame( SIDE, 'R' ) ) THEN                          
!                                                                       
!              Form  C * H  or  C * H'  where  C = ( C1  C2 )           
!                                                                       
!              W := C * V  =  (C1*V1 + C2*V2)  (stored in WORK)         
!                                                                       
!              W := C2                                                  
!                                                                       
               DO 100 J = 1, K                                          
                  CALL CSVD_ccopy( M, C( 1, N-K+J ), 1, WORK( 1, J ), 1 )    
  100          CONTINUE                                                 
!                                                                       
!              W := W * V2                                              
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Upper', 'No transpose', 'Unit', M,   &
                           K, ONE, V( N-K+1, 1 ), LDV, WORK, LDWORK )   
               IF( N.GT.K ) THEN                                        
!                                                                       
!                 W := W + C1 * V1                                      
!                                                                       
                  CALL CSVD_CGEMM( 'No transpose', 'No transpose', M, K, N-K,  &
                              ONE, C, LDC, V, LDV, ONE, WORK, LDWORK )  
               END IF                                                   
!                                                                       
!              W := W * T  or  W * T'                                   
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Lower', TRANS, 'Non-unit', M, K,     &
                           ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - W * V'                                          
!                                                                       
               IF( N.GT.K ) THEN                                        
!                                                                       
!                 C1 := C1 - W * V1'                                    
!                                                                       
                  CALL CSVD_CGEMM( 'No transpose', 'Conjugate transpose', M,   &
                              N-K, K, -ONE, WORK, LDWORK, V, LDV, ONE,    &
                              C, LDC )                                  
               END IF                                                   
!                                                                       
!              W := W * V2'                                             
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Upper', 'Conjugate transpose',       &
                           'Unit', M, K, ONE, V( N-K+1, 1 ), LDV, WORK,   &
                           LDWORK )                                     
!                                                                       
!              C2 := C2 - W                                             
!                                                                       
               DO 120 J = 1, K                                          
                  DO 110 I = 1, M                                       
                     C( I, N-K+J ) = C( I, N-K+J ) - WORK( I, J )       
  110             CONTINUE                                              
  120          CONTINUE                                                 
            END IF                                                      
         END IF                                                         
!                                                                       
      ELSE IF( csvd_lsame( STOREV, 'R' ) ) THEN                              
!                                                                       
         IF( csvd_lsame( DIRECT, 'F' ) ) THEN                                
!                                                                       
!           Let  V =  ( V1  V2 )    (V1: first K columns)               
!           where  V1  is unit upper triangular.                        
!                                                                       
            IF( csvd_lsame( SIDE, 'L' ) ) THEN                               
!                                                                       
!              Form  H * C  or  H' * C  where  C = ( C1 )               
!                                                  ( C2 )               
!                                                                       
!              W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)    
!                                                                       
!              W := C1'                                                 
!                                                                       
               DO 130 J = 1, K                                          
                  CALL CSVD_ccopy( N, C( J, 1 ), LDC, WORK( 1, J ), 1 )      
                  CALL CSVD_CLACGV( N, WORK( 1, J ), 1 )                     
  130          CONTINUE                                                 
!                                                                       
!              W := W * V1'                                             
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Upper', 'Conjugate transpose',       &
                           'Unit', N, K, ONE, V, LDV, WORK, LDWORK )    
               IF( M.GT.K ) THEN                                        
!                                                                       
!                 W := W + C2'*V2'                                      
!                                                                       
                  CALL CSVD_CGEMM( 'Conjugate transpose',                      &
                              'Conjugate transpose', N, K, M-K, ONE,      &
                              C( K+1, 1 ), LDC, V( 1, K+1 ), LDV, ONE,    &
                              WORK, LDWORK )                            
               END IF                                                   
!                                                                       
!              W := W * T'  or  W * T                                   
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Upper', TRANST, 'Non-unit', N, K,    &
                           ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - V' * W'                                         
!                                                                       
               IF( M.GT.K ) THEN                                        
!                                                                       
!                 C2 := C2 - V2' * W'                                   
!                                                                       
                  CALL CSVD_CGEMM( 'Conjugate transpose',                      &
                              'Conjugate transpose', M-K, N, K, -ONE,     &
                              V( 1, K+1 ), LDV, WORK, LDWORK, ONE,        &
                              C( K+1, 1 ), LDC )                        
               END IF                                                   
!                                                                       
!              W := W * V1                                              
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Upper', 'No transpose', 'Unit', N,   &
                           K, ONE, V, LDV, WORK, LDWORK )               
!                                                                       
!              C1 := C1 - W'                                            
!                                                                       
               DO 150 J = 1, K                                          
                  DO 140 I = 1, N                                       
                     C( J, I ) = C( J, I ) - CONJG( WORK( I, J ) )      
  140             CONTINUE                                              
  150          CONTINUE                                                 
!                                                                       
            ELSE IF( csvd_lsame( SIDE, 'R' ) ) THEN                          
!                                                                       
!              Form  C * H  or  C * H'  where  C = ( C1  C2 )           
!                                                                       
!              W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)      
!                                                                       
!              W := C1                                                  
!                                                                       
               DO 160 J = 1, K                                          
                  CALL CSVD_ccopy( M, C( 1, J ), 1, WORK( 1, J ), 1 )        
  160          CONTINUE                                                 
!                                                                       
!              W := W * V1'                                             
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Upper', 'Conjugate transpose',       &
                           'Unit', M, K, ONE, V, LDV, WORK, LDWORK )    
               IF( N.GT.K ) THEN                                        
!                                                                       
!                 W := W + C2 * V2'                                     
!                                                                       
                  CALL CSVD_CGEMM( 'No transpose', 'Conjugate transpose', M,   &
                              K, N-K, ONE, C( 1, K+1 ), LDC,              &
                              V( 1, K+1 ), LDV, ONE, WORK, LDWORK )     
               END IF                                                   
!                                                                       
!              W := W * T  or  W * T'                                   
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Upper', TRANS, 'Non-unit', M, K,     &
                           ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - W * V                                           
!                                                                       
               IF( N.GT.K ) THEN                                        
!                                                                       
!                 C2 := C2 - W * V2                                     
!                                                                       
                  CALL CSVD_CGEMM( 'No transpose', 'No transpose', M, N-K, K,  &
                              -ONE, WORK, LDWORK, V( 1, K+1 ), LDV, ONE,  &
                              C( 1, K+1 ), LDC )                        
               END IF                                                   
!                                                                       
!              W := W * V1                                              
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Upper', 'No transpose', 'Unit', M,   &
                           K, ONE, V, LDV, WORK, LDWORK )               
!                                                                       
!              C1 := C1 - W                                             
!                                                                       
               DO 180 J = 1, K                                          
                  DO 170 I = 1, M                                       
                     C( I, J ) = C( I, J ) - WORK( I, J )               
  170             CONTINUE                                              
  180          CONTINUE                                                 
!                                                                       
            END IF                                                      
!                                                                       
         ELSE                                                           
!                                                                       
!           Let  V =  ( V1  V2 )    (V2: last K columns)                
!           where  V2  is unit lower triangular.                        
!                                                                       
            IF( csvd_lsame( SIDE, 'L' ) ) THEN                               
!                                                                       
!              Form  H * C  or  H' * C  where  C = ( C1 )               
!                                                  ( C2 )               
!                                                                       
!              W := C' * V'  =  (C1'*V1' + C2'*V2') (stored in WORK)    
!                                                                       
!              W := C2'                                                 
!                                                                       
               DO 190 J = 1, K                                          
                  CALL CSVD_ccopy( N, C( M-K+J, 1 ), LDC, WORK( 1, J ), 1 )  
                  CALL CSVD_CLACGV( N, WORK( 1, J ), 1 )                     
  190          CONTINUE                                                 
!                                                                       
!              W := W * V2'                                             
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Lower', 'Conjugate transpose',       &
                           'Unit', N, K, ONE, V( 1, M-K+1 ), LDV, WORK,   &
                           LDWORK )                                     
               IF( M.GT.K ) THEN                                        
!                                                                       
!                 W := W + C1'*V1'                                      
!                                                                       
                  CALL CSVD_CGEMM( 'Conjugate transpose',                      &
                              'Conjugate transpose', N, K, M-K, ONE, C,   &
                              LDC, V, LDV, ONE, WORK, LDWORK )          
               END IF                                                   
!                                                                       
!              W := W * T'  or  W * T                                   
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Lower', TRANST, 'Non-unit', N, K,    &
                           ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - V' * W'                                         
!                                                                       
               IF( M.GT.K ) THEN                                        
!                                                                       
!                 C1 := C1 - V1' * W'                                   
!                                                                       
                  CALL CSVD_CGEMM( 'Conjugate transpose',                      &
                              'Conjugate transpose', M-K, N, K, -ONE, V,  &
                              LDV, WORK, LDWORK, ONE, C, LDC )          
               END IF                                                   
!                                                                       
!              W := W * V2                                              
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Lower', 'No transpose', 'Unit', N,   &
                           K, ONE, V( 1, M-K+1 ), LDV, WORK, LDWORK )   
!                                                                       
!              C2 := C2 - W'                                            
!                                                                       
               DO 210 J = 1, K                                          
                  DO 200 I = 1, N                                       
                     C( M-K+J, I ) = C( M-K+J, I ) -                      &
                                     CONJG( WORK( I, J ) )              
  200             CONTINUE                                              
  210          CONTINUE                                                 
!                                                                       
            ELSE IF( csvd_lsame( SIDE, 'R' ) ) THEN                          
!                                                                       
!              Form  C * H  or  C * H'  where  C = ( C1  C2 )           
!                                                                       
!              W := C * V'  =  (C1*V1' + C2*V2')  (stored in WORK)      
!                                                                       
!              W := C2                                                  
!                                                                       
               DO 220 J = 1, K                                          
                  CALL CSVD_ccopy( M, C( 1, N-K+J ), 1, WORK( 1, J ), 1 )    
  220          CONTINUE                                                 
!                                                                       
!              W := W * V2'                                             
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Lower', 'Conjugate transpose',       &
                           'Unit', M, K, ONE, V( 1, N-K+1 ), LDV, WORK,   &
                           LDWORK )                                     
               IF( N.GT.K ) THEN                                        
!                                                                       
!                 W := W + C1 * V1'                                     
!                                                                       
                  CALL CSVD_CGEMM( 'No transpose', 'Conjugate transpose', M,   &
                              K, N-K, ONE, C, LDC, V, LDV, ONE, WORK,     &
                              LDWORK )                                  
               END IF                                                   
!                                                                       
!              W := W * T  or  W * T'                                   
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Lower', TRANS, 'Non-unit', M, K,     &
                           ONE, T, LDT, WORK, LDWORK )                  
!                                                                       
!              C := C - W * V                                           
!                                                                       
               IF( N.GT.K ) THEN                                        
!                                                                       
!                 C1 := C1 - W * V1                                     
!                                                                       
                  CALL CSVD_CGEMM( 'No transpose', 'No transpose', M, N-K, K,  &
                              -ONE, WORK, LDWORK, V, LDV, ONE, C, LDC ) 
               END IF                                                   
!                                                                       
!              W := W * V2                                              
!                                                                       
               CALL CSVD_CTRMM( 'Right', 'Lower', 'No transpose', 'Unit', M,   &
                           K, ONE, V( 1, N-K+1 ), LDV, WORK, LDWORK )   
!                                                                       
!              C1 := C1 - W                                             
!                                                                       
               DO 240 J = 1, K                                          
                  DO 230 I = 1, M                                       
                     C( I, N-K+J ) = C( I, N-K+J ) - WORK( I, J )       
  230             CONTINUE                                              
  240          CONTINUE                                                 
!                                                                       
            END IF                                                      
!                                                                       
         END IF                                                         
      END IF                                                            
!                                                                       
      RETURN                                                            
!                                                                       
!     End of CSVD_CLARFB                                                     
!                                                                       
      END SUBROUTINE CSVD_CLARFB
                                                              
      SUBROUTINE CSVD_CLARFG( N, ALPHA, X, INCX, TAU )                       
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     September 30, 1994                                                
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INCX, N                                        
      COMPLEX            ALPHA, TAU                                     
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            X( * )                                         
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CLARFG generates a complex elementary reflector H of order n, such   
!  that                                                                 
!                                                                       
!        H' * ( alpha ) = ( beta ),   H' * H = I.                       
!             (   x   )   (   0  )                                      
!                                                                       
!  where alpha and beta are scalars, with beta real, and x is an        
!  (n-1)-element complex vector. H is represented in the form           
!                                                                       
!        H = I - tau * ( 1 ) * ( 1 v' ) ,                               
!                      ( v )                                            
!                                                                       
!  where tau is a complex scalar and v is a complex (n-1)-element       
!  vector. Note that H is not hermitian.                                
!                                                                       
!  If the elements of x are all zero and alpha is real, then tau = 0    
!  and H is taken to be the unit matrix.                                
!                                                                       
!  Otherwise  1 &lt;= real(tau) &lt;= 2  and  abs(tau-1) &lt;= 1 .      
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  N       (input) INTEGER                                              
!          The order of the elementary reflector.                       
!                                                                       
!  ALPHA   (input/output) COMPLEX                                       
!          On entry, the value alpha.                                   
!          On exit, it is overwritten with the value beta.              
!                                                                       
!  X       (input/output) COMPLEX array, dimension                      
!                         (1+(N-2)*abs(INCX))                           
!          On entry, the vector x.                                      
!          On exit, it is overwritten with the vector v.                
!                                                                       
!  INCX    (input) INTEGER                                              
!          The increment between elements of X. INCX &gt; 0.            
!                                                                       
!  TAU     (output) COMPLEX                                             
!          The value tau.                                               
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ONE, ZERO                                      
      PARAMETER          ( ONE = 1.0E+0, ZERO = 0.0E+0 )                
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            J, KNT                                         
      REAL               ALPHI, ALPHR, BETA, RSAFMN, SAFMIN, XNORM      
!     ..                                                                
!     .. External Functions ..                                          
!     REAL               csvd_scnrm2, csvd_slamch, csvd_slapy3
!     COMPLEX            csvd_cladiv                                         
!     EXTERNAL           csvd_scnrm2, csvd_slamch, csvd_slapy3, csvd_cladiv
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, AIMAG, CMPLX, REAL, SIGN                  
!     ..                                                                
!     .. External Subroutines ..                                        
!     EXTERNAL           CSVD_cscal, CSVD_csscal
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( N.LE.0 ) THEN                                                 
         TAU = ZERO                                                     
         RETURN                                                         
      END IF                                                            
!                                                                       
      XNORM = csvd_scnrm2( N-1, X, INCX )                                    
      ALPHR = REAL( ALPHA )                                             
      ALPHI = AIMAG( ALPHA )                                            
!                                                                       
      IF( XNORM.EQ.ZERO .AND. ALPHI.EQ.ZERO ) THEN                      
!                                                                       
!        H  =  I                                                        
!                                                                       
         TAU = ZERO                                                     
      ELSE                                                              
!                                                                       
!        general case                                                   
!                                                                       
         BETA = -SIGN( csvd_slapy3( ALPHR, ALPHI, XNORM ), ALPHR )           
         SAFMIN = csvd_slamch( 'S' ) / csvd_slamch( 'E' )
         RSAFMN = ONE / SAFMIN                                          
!                                                                       
         IF( ABS( BETA ).LT.SAFMIN ) THEN                               
!                                                                       
!           XNORM, BETA may be inaccurate; scale X and recompute them   
!                                                                       
            KNT = 0                                                     
   10       CONTINUE                                                    
            KNT = KNT + 1                                               
            CALL CSVD_csscal( N-1, RSAFMN, X, INCX )                         
            BETA = BETA*RSAFMN                                          
            ALPHI = ALPHI*RSAFMN                                        
            ALPHR = ALPHR*RSAFMN                                        
            IF( ABS( BETA ).LT.SAFMIN )                                   &
               GO TO 10                                                 
!                                                                       
!           New BETA is at most 1, at least SAFMIN                      
!                                                                       
            XNORM = csvd_scnrm2( N-1, X, INCX )                              
            ALPHA = CMPLX( ALPHR, ALPHI )                               
            BETA = -SIGN( csvd_slapy3( ALPHR, ALPHI, XNORM ), ALPHR )        
            TAU = CMPLX( ( BETA-ALPHR ) / BETA, -ALPHI / BETA )         
            ALPHA = csvd_cladiv( CMPLX( ONE ), ALPHA-BETA )                  
            CALL CSVD_cscal( N-1, ALPHA, X, INCX )                           
!                                                                       
!           If ALPHA is subnormal, it may lose relative accuracy        
!                                                                       
            ALPHA = BETA                                                
            DO 20 J = 1, KNT                                            
               ALPHA = ALPHA*SAFMIN                                     
   20       CONTINUE                                                    
         ELSE                                                           
            TAU = CMPLX( ( BETA-ALPHR ) / BETA, -ALPHI / BETA )         
            ALPHA = csvd_cladiv( CMPLX( ONE ), ALPHA-BETA )                  
            CALL CSVD_cscal( N-1, ALPHA, X, INCX )                           
            ALPHA = BETA                                                
         END IF                                                         
      END IF                                                            
!                                                                       
      RETURN                                                            
!                                                                       
!     End of CSVD_CLARFG                                                     
!                                                                       
      END SUBROUTINE CSVD_CLARFG
                                                              
      SUBROUTINE CSVD_CLARFT( DIRECT, STOREV, N, K, V, LDV, TAU, T, LDT )    
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     September 30, 1994                                                
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          DIRECT, STOREV                                 
      INTEGER            K, LDT, LDV, N                                 
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            T( LDT, * ), TAU( * ), V( LDV, * )             
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CLARFT forms the triangular factor T of a complex block reflector H  
!  of order n, which is defined as a product of k elementary reflectors.
!                                                                       
!  If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular; 
!                                                                       
!  If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular. 
!                                                                       
!  If STOREV = 'C', the vector which defines the elementary reflector   
!  H(i) is stored in the i-th column of the array V, and                
!                                                                       
!     H  =  I - V * T * V'                                              
!                                                                       
!  If STOREV = 'R', the vector which defines the elementary reflector   
!  H(i) is stored in the i-th row of the array V, and                   
!                                                                       
!     H  =  I - V' * T * V                                              
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  DIRECT  (input) CHARACTER*1                                          
!          Specifies the order in which the elementary reflectors are   
!          multiplied to form the block reflector:                      
!          = 'F': H = H(1) H(2) . . . H(k) (Forward)                    
!          = 'B': H = H(k) . . . H(2) H(1) (Backward)                   
!                                                                       
!  STOREV  (input) CHARACTER*1                                          
!          Specifies how the vectors which define the elementary        
!          reflectors are stored (see also Further Details):            
!          = 'C': columnwise                                            
!          = 'R': rowwise                                               
!                                                                       
!  N       (input) INTEGER                                              
!          The order of the block reflector H. N &gt;= 0.               
!                                                                       
!  K       (input) INTEGER                                              
!          The order of the triangular factor T (= the number of        
!          elementary reflectors). K &gt;= 1.                           
!                                                                       
!  V       (input/output) COMPLEX array, dimension                      
!                               (LDV,K) if STOREV = 'C'                 
!                               (LDV,N) if STOREV = 'R'                 
!          The matrix V. See further details.                           
!                                                                       
!  LDV     (input) INTEGER                                              
!          The leading dimension of the array V.                        
!          If STOREV = 'C', LDV &gt;= max(1,N); if STOREV = 'R', LDV &gt
!                                                                       
!  TAU     (input) COMPLEX array, dimension (K)                         
!          TAU(i) must contain the scalar factor of the elementary      
!          reflector H(i).                                              
!                                                                       
!  T       (output) COMPLEX array, dimension (LDT,K)                    
!          The k by k triangular factor T of the block reflector.       
!          If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
!          lower triangular. The rest of the array is not used.         
!                                                                       
!  LDT     (input) INTEGER                                              
!          The leading dimension of the array T. LDT &gt;= K.           
!                                                                       
!  Further Details                                                      
!  ===============                                                      
!                                                                       
!  The shape of the matrix V and the storage of the vectors which define
!  the H(i) is best illustrated by the following example with n = 5 and 
!  k = 3. The elements equal to 1 are not stored; the corresponding     
!  array elements are modified but restored on exit. The rest of the    
!  array is not used.                                                   
!                                                                       
!  DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
!                                                                       
!               V = (  1       )                 V = (  1 v1 v1 v1 v1 ) 
!                   ( v1  1    )                     (     1 v2 v2 v2 ) 
!                   ( v1 v2  1 )                     (        1 v3 v3 ) 
!                   ( v1 v2 v3 )                                        
!                   ( v1 v2 v3 )                                        
!                                                                       
!  DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
!                                                                       
!               V = ( v1 v2 v3 )                 V = ( v1 v1  1       ) 
!                   ( v1 v2 v3 )                     ( v2 v2 v2  1    ) 
!                   (  1 v2 v3 )                     ( v3 v3 v3 v3  1 ) 
!                   (     1 v3 )                                        
!                   (        1 )                                        
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      COMPLEX            ONE, ZERO                                      
!      PARAMETER          ( ONE = CMPLX( 1.0E+0, 0.0E+0 ),              &
!                         ZERO = CMPLX( 0.0E+0, 0.0E+0 ) )
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, J                                           
      COMPLEX            VII                                            
!     ..                                                                
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_CGEMV, CSVD_CLACGV, CSVD_CTRMV
!     ..                                                                
!     .. External Functions ..                                          
!     LOGICAL            csvd_lsame                                          
!     EXTERNAL           csvd_lsame                                          
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Quick return if possible                                          
!                                                                       
      ONE  = CMPLX( 1.0E+0, 0.0E+0 )               
      ZERO = CMPLX( 0.0E+0, 0.0E+0 ) 

      IF( N.EQ.0 )                                                        &
         RETURN                                                         
!                                                                       
      IF( csvd_lsame( DIRECT, 'F' ) ) THEN                                   
         DO 20 I = 1, K                                                 
            IF( TAU( I ).EQ.ZERO ) THEN                                 
!                                                                       
!              H(i)  =  I                                               
!                                                                       
               DO 10 J = 1, I                                           
                  T( J, I ) = ZERO                                      
   10          CONTINUE                                                 
            ELSE                                                        
!                                                                       
!              general case                                             
!                                                                       
               VII = V( I, I )                                          
               V( I, I ) = ONE                                          
               IF( csvd_lsame( STOREV, 'C' ) ) THEN                          
!                                                                       
!                 T(1:i-1,i) := - tau(i) * V(i:n,1:i-1)' * V(i:n,i)     
!                                                                       
                  CALL CSVD_CGEMV( 'Conjugate transpose', N-I+1, I-1,          &
                              -TAU( I ), V( I, 1 ), LDV, V( I, I ), 1,    &
                              ZERO, T( 1, I ), 1 )                      
               ELSE                                                     
!                                                                       
!                 T(1:i-1,i) := - tau(i) * V(1:i-1,i:n) * V(i,i:n)'     
!                                                                       
                  IF( I.LT.N )                                            &
                     CALL CSVD_CLACGV( N-I, V( I, I+1 ), LDV )               
                  CALL CSVD_CGEMV( 'No transpose', I-1, N-I+1, -TAU( I ),      &
                              V( 1, I ), LDV, V( I, I ), LDV, ZERO,       &
                              T( 1, I ), 1 )                            
                  IF( I.LT.N )                                            &
                     CALL CSVD_CLACGV( N-I, V( I, I+1 ), LDV )               
               END IF                                                   
               V( I, I ) = VII                                          
!                                                                       
!              T(1:i-1,i) := T(1:i-1,1:i-1) * T(1:i-1,i)                
!                                                                       
               CALL CSVD_CTRMV( 'Upper', 'No transpose', 'Non-unit', I-1, T,   &
                           LDT, T( 1, I ), 1 )                          
               T( I, I ) = TAU( I )                                     
            END IF                                                      
   20    CONTINUE                                                       
      ELSE                                                              
         DO 40 I = K, 1, -1                                             
            IF( TAU( I ).EQ.ZERO ) THEN                                 
!                                                                       
!              H(i)  =  I                                               
!                                                                       
               DO 30 J = I, K                                           
                  T( J, I ) = ZERO                                      
   30          CONTINUE                                                 
            ELSE                                                        
!                                                                       
!              general case                                             
!                                                                       
               IF( I.LT.K ) THEN                                        
                  IF( csvd_lsame( STOREV, 'C' ) ) THEN                       
                     VII = V( N-K+I, I )                                
                     V( N-K+I, I ) = ONE                                
!                                                                       
!                    T(i+1:k,i) :=                                      
!                            - tau(i) * V(1:n-k+i,i+1:k)' * V(1:n-k+i,i)
!                                                                       
                     CALL CSVD_CGEMV( 'Conjugate transpose', N-K+I, K-I,       &
                                 -TAU( I ), V( 1, I+1 ), LDV, V( 1, I ),  &
                                 1, ZERO, T( I+1, I ), 1 )              
                     V( N-K+I, I ) = VII                                
                  ELSE                                                  
                     VII = V( I, N-K+I )                                
                     V( I, N-K+I ) = ONE                                
!                                                                       
!                    T(i+1:k,i) :=                                      
!                            - tau(i) * V(i+1:k,1:n-k+i) * V(i,1:n-k+i)'
!                                                                       
                     CALL CSVD_CLACGV( N-K+I-1, V( I, 1 ), LDV )             
                     CALL CSVD_CGEMV( 'No transpose', K-I, N-K+I, -TAU( I ),   &
                                 V( I+1, 1 ), LDV, V( I, 1 ), LDV, ZERO,  &
                                 T( I+1, I ), 1 )                       
                     CALL CSVD_CLACGV( N-K+I-1, V( I, 1 ), LDV )             
                     V( I, N-K+I ) = VII                                
                  END IF                                                
!                                                                       
!                 T(i+1:k,i) := T(i+1:k,i+1:k) * T(i+1:k,i)             
!                                                                       
                  CALL CSVD_CTRMV( 'Lower', 'No transpose', 'Non-unit', K-I,   &
                              T( I+1, I+1 ), LDT, T( I+1, I ), 1 )      
               END IF                                                   
               T( I, I ) = TAU( I )                                     
            END IF                                                      
   40    CONTINUE                                                       
      END IF                                                            
      RETURN                                                            
!                                                                       
!     End of CSVD_CLARFT                                                     
!                                                                       
      END SUBROUTINE CSVD_CLARFT
                                                               
      SUBROUTINE CSVD_CLASCL( TYPE, KL, KU, CFROM, CTO, M, N, A, LDA, INFO ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     February 29, 1992                                                 
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          TYPE                                           
      INTEGER            INFO, KL, KU, LDA, M, N                        
      REAL               CFROM, CTO                                     
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * )                                    
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CLASCL multiplies the M by N complex matrix A by the real scalar     
!  CTO/CFROM.  This is done without over/underflow as long as the final 
!  result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that 
!  A may be full, upper triangular, lower triangular, upper Hessenberg, 
!  or banded.                                                           
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  TYPE    (input) CHARACTER*1                                          
!          TYPE indices the storage type of the input matrix.           
!          = 'G':  A is a full matrix.                                  
!          = 'L':  A is a lower triangular matrix.                      
!          = 'U':  A is an upper triangular matrix.                     
!          = 'H':  A is an upper Hessenberg matrix.                     
!          = 'B':  A is a symmetric band matrix with lower bandwidth KL 
!                  and upper bandwidth KU and with the only the lower   
!                  half stored.                                         
!          = 'Q':  A is a symmetric band matrix with lower bandwidth KL 
!                  and upper bandwidth KU and with the only the upper   
!                  half stored.                                         
!          = 'Z':  A is a band matrix with lower bandwidth KL and upper 
!                  bandwidth KU.                                        
!                                                                       
!  KL      (input) INTEGER                                              
!          The lower bandwidth of A.  Referenced only if TYPE = 'B',    
!          'Q' or 'Z'.                                                  
!                                                                       
!  KU      (input) INTEGER                                              
!          The upper bandwidth of A.  Referenced only if TYPE = 'B',    
!          'Q' or 'Z'.                                                  
!                                                                       
!  CFROM   (input) REAL                                                 
!  CTO     (input) REAL                                                 
!          The matrix A is multiplied by CTO/CFROM. A(I,J) is computed  
!          without over/underflow if the final result CTO*A(I,J)/CFROM  
!          can be represented without over/underflow.  CFROM must be    
!          nonzero.                                                     
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix A.  M &gt;= 0.              
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix A.  N &gt;= 0.           
!                                                                       
!  A       (input/output) COMPLEX array, dimension (LDA,M)              
!          The matrix to be multiplied by CTO/CFROM.  See TYPE for the  
!          storage type.                                                
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA &gt;= max(1,M).   
!                                                                       
!  INFO    (output) INTEGER                                             
!          0  - successful exit                                         
!          &lt;0 - if INFO = -i, the i-th argument had an illegal value.
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO, ONE                                      
      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0 )                  
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            DONE                                           
      INTEGER            I, ITYPE, J, K1, K2, K3, K4                    
      REAL               BIGNUM, CFROM1, CFROMC, CTO1, CTOC, MUL, SMLNUM
!     ..                                                                
!     .. External Functions ..                                          
!      LOGICAL            csvd_lsame                                          
!      REAL               csvd_slamch                                         
!      EXTERNAL           csvd_lsame, csvd_slamch
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, MIN                                  
!     ..                                                                
!     .. External Subroutines ..                                        
!     EXTERNAL           CSVD_XERBLA                                         
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      INFO = 0                                                          
!                                                                       
      IF( csvd_lsame( TYPE, 'G' ) ) THEN                                     
         ITYPE = 0                                                      
      ELSE IF( csvd_lsame( TYPE, 'L' ) ) THEN                                
         ITYPE = 1                                                      
      ELSE IF( csvd_lsame( TYPE, 'U' ) ) THEN                                
         ITYPE = 2                                                      
      ELSE IF( csvd_lsame( TYPE, 'H' ) ) THEN                                
         ITYPE = 3                                                      
      ELSE IF( csvd_lsame( TYPE, 'B' ) ) THEN                                
         ITYPE = 4                                                      
      ELSE IF( csvd_lsame( TYPE, 'Q' ) ) THEN                                
         ITYPE = 5                                                      
      ELSE IF( csvd_lsame( TYPE, 'Z' ) ) THEN                                
         ITYPE = 6                                                      
      ELSE                                                              
         ITYPE = -1                                                     
      END IF                                                            
!                                                                       
      IF( ITYPE.EQ.-1 ) THEN                                            
         INFO = -1                                                      
      ELSE IF( CFROM.EQ.ZERO ) THEN                                     
         INFO = -4                                                      
      ELSE IF( M.LT.0 ) THEN                                            
         INFO = -6                                                      
      ELSE IF( N.LT.0 .OR. ( ITYPE.EQ.4 .AND. N.NE.M ) .OR.               &
               ( ITYPE.EQ.5 .AND. N.NE.M ) ) THEN                       
         INFO = -7                                                      
      ELSE IF( ITYPE.LE.3 .AND. LDA.LT.MAX( 1, M ) ) THEN               
         INFO = -9                                                      
      ELSE IF( ITYPE.GE.4 ) THEN                                        
         IF( KL.LT.0 .OR. KL.GT.MAX( M-1, 0 ) ) THEN                    
            INFO = -2                                                   
         ELSE IF( KU.LT.0 .OR. KU.GT.MAX( N-1, 0 ) .OR.                   &
                  ( ( ITYPE.EQ.4 .OR. ITYPE.EQ.5 ) .AND. KL.NE.KU ) )     &
                   THEN                                                 
            INFO = -3                                                   
         ELSE IF( ( ITYPE.EQ.4 .AND. LDA.LT.KL+1 ) .OR.                   &
                  ( ITYPE.EQ.5 .AND. LDA.LT.KU+1 ) .OR.                   &
                  ( ITYPE.EQ.6 .AND. LDA.LT.2*KL+KU+1 ) ) THEN          
            INFO = -9                                                   
         END IF                                                         
      END IF                                                            
!                                                                       
      IF( INFO.NE.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_CLASCL', -INFO )
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.EQ.0 .OR. M.EQ.0 )                                            &
         RETURN                                                         
!                                                                       
!     Get machine parameters                                            
!                                                                       
      SMLNUM = csvd_slamch( 'S' )                                            
      BIGNUM = ONE / SMLNUM                                             
!                                                                       
      CFROMC = CFROM                                                    
      CTOC = CTO                                                        
!                                                                       
   10 CONTINUE                                                          
      CFROM1 = CFROMC*SMLNUM                                            
      CTO1 = CTOC / BIGNUM                                              
      IF( ABS( CFROM1 ).GT.ABS( CTOC ) .AND. CTOC.NE.ZERO ) THEN        
         MUL = SMLNUM                                                   
         DONE = .FALSE.                                                 
         CFROMC = CFROM1                                                
      ELSE IF( ABS( CTO1 ).GT.ABS( CFROMC ) ) THEN                      
         MUL = BIGNUM                                                   
         DONE = .FALSE.                                                 
         CTOC = CTO1                                                    
      ELSE                                                              
         MUL = CTOC / CFROMC                                            
         DONE = .TRUE.                                                  
      END IF                                                            
!                                                                       
      IF( ITYPE.EQ.0 ) THEN                                             
!                                                                       
!        Full matrix                                                    
!                                                                       
         DO 30 J = 1, N                                                 
            DO 20 I = 1, M                                              
               A( I, J ) = A( I, J )*MUL                                
   20       CONTINUE                                                    
   30    CONTINUE                                                       
!                                                                       
      ELSE IF( ITYPE.EQ.1 ) THEN                                        
!                                                                       
!        Lower triangular matrix                                        
!                                                                       
         DO 50 J = 1, N                                                 
            DO 40 I = J, M                                              
               A( I, J ) = A( I, J )*MUL                                
   40       CONTINUE                                                    
   50    CONTINUE                                                       
!                                                                       
      ELSE IF( ITYPE.EQ.2 ) THEN                                        
!                                                                       
!        Upper triangular matrix                                        
!                                                                       
         DO 70 J = 1, N                                                 
            DO 60 I = 1, MIN( J, M )                                    
               A( I, J ) = A( I, J )*MUL                                
   60       CONTINUE                                                    
   70    CONTINUE                                                       
!                                                                       
      ELSE IF( ITYPE.EQ.3 ) THEN                                        
!                                                                       
!        Upper Hessenberg matrix                                        
!                                                                       
         DO 90 J = 1, N                                                 
            DO 80 I = 1, MIN( J+1, M )                                  
               A( I, J ) = A( I, J )*MUL                                
   80       CONTINUE                                                    
   90    CONTINUE                                                       
!                                                                       
      ELSE IF( ITYPE.EQ.4 ) THEN                                        
!                                                                       
!        Lower half of a symmetric band matrix                          
!                                                                       
         K3 = KL + 1                                                    
         K4 = N + 1                                                     
         DO 110 J = 1, N                                                
            DO 100 I = 1, MIN( K3, K4-J )                               
               A( I, J ) = A( I, J )*MUL                                
  100       CONTINUE                                                    
  110    CONTINUE                                                       
!                                                                       
      ELSE IF( ITYPE.EQ.5 ) THEN                                        
!                                                                       
!        Upper half of a symmetric band matrix                          
!                                                                       
         K1 = KU + 2                                                    
         K3 = KU + 1                                                    
         DO 130 J = 1, N                                                
            DO 120 I = MAX( K1-J, 1 ), K3                               
               A( I, J ) = A( I, J )*MUL                                
  120       CONTINUE                                                    
  130    CONTINUE                                                       
!                                                                       
      ELSE IF( ITYPE.EQ.6 ) THEN                                        
!                                                                       
!        Band matrix                                                    
!                                                                       
         K1 = KL + KU + 2                                               
         K2 = KL + 1                                                    
         K3 = 2*KL + KU + 1                                             
         K4 = KL + KU + 1 + M                                           
         DO 150 J = 1, N                                                
            DO 140 I = MAX( K1-J, K2 ), MIN( K3, K4-J )                 
               A( I, J ) = A( I, J )*MUL                                
  140       CONTINUE                                                    
  150    CONTINUE                                                       
!                                                                       
      END IF                                                            
!                                                                       
      IF( .NOT.DONE )                                                     &
         GO TO 10                                                       
!                                                                       
      RETURN                                                            
!                                                                       
!     End of CSVD_CLASCL                                                     
!                                                                       
      END SUBROUTINE CSVD_CLASCL 
                                                             
      SUBROUTINE CSVD_CLASET( UPLO, M, N, ALPHA, BETA, A, LDA )              
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     October 31, 1992                                                  
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          UPLO                                           
      INTEGER            LDA, M, N                                      
      COMPLEX            ALPHA, BETA                                    
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * )                                    
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CLASET initializes a 2-D array A to BETA on the diagonal and         
!  ALPHA on the offdiagonals.                                           
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  UPLO    (input) CHARACTER*1                                          
!          Specifies the part of the matrix A to be set.                
!          = 'U':      Upper triangular part is set. The lower triangle 
!                      is unchanged.                                    
!          = 'L':      Lower triangular part is set. The upper triangle 
!                      is unchanged.                                    
!          Otherwise:  All of the matrix A is set.                      
!                                                                       
!  M       (input) INTEGER                                              
!          On entry, M specifies the number of rows of A.               
!                                                                       
!  N       (input) INTEGER                                              
!          On entry, N specifies the number of columns of A.            
!                                                                       
!  ALPHA   (input) COMPLEX                                              
!          All the offdiagonal array elements are set to ALPHA.         
!                                                                       
!  BETA    (input) COMPLEX                                              
!          All the diagonal array elements are set to BETA.             
!                                                                       
!  A       (input/output) COMPLEX array, dimension (LDA,N)              
!          On entry, the m by n matrix A.                               
!          On exit, A(i,j) = ALPHA, 1 &lt;= i &lt;= m, 1 &lt;= j &lt;= n
!                   A(i,i) = BETA , 1 &lt;= i &lt;= min(m,n)            
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA &gt;= max(1,M).   
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      INTEGER            I, J                                           
!     ..                                                                
!     .. External Functions ..                                          
!      LOGICAL            csvd_lsame                                          
!      EXTERNAL           csvd_lsame                                          
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MIN                                            
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( csvd_lsame( UPLO, 'U' ) ) THEN                                     
!                                                                       
!        Set the diagonal to BETA and the strictly upper triangular     
!        part of the array to ALPHA.                                    
!                                                                       
         DO 20 J = 2, N                                                 
            DO 10 I = 1, MIN( J-1, M )                                  
               A( I, J ) = ALPHA                                        
   10       CONTINUE                                                    
   20    CONTINUE                                                       
         DO 30 I = 1, MIN( N, M )                                       
            A( I, I ) = BETA                                            
   30    CONTINUE                                                       
!                                                                       
      ELSE IF( csvd_lsame( UPLO, 'L' ) ) THEN                                
!                                                                       
!        Set the diagonal to BETA and the strictly lower triangular     
!        part of the array to ALPHA.                                    
!                                                                       
         DO 50 J = 1, MIN( M, N )                                       
            DO 40 I = J + 1, M                                          
               A( I, J ) = ALPHA                                        
   40       CONTINUE                                                    
   50    CONTINUE                                                       
         DO 60 I = 1, MIN( N, M )                                       
            A( I, I ) = BETA                                            
   60    CONTINUE                                                       
!                                                                       
      ELSE                                                              
!                                                                       
!        Set the array to BETA on the diagonal and ALPHA on the         
!        offdiagonal.                                                   
!                                                                       
         DO 80 J = 1, N                                                 
            DO 70 I = 1, M                                              
               A( I, J ) = ALPHA                                        
   70       CONTINUE                                                    
   80    CONTINUE                                                       
         DO 90 I = 1, MIN( M, N )                                       
            A( I, I ) = BETA                                            
   90    CONTINUE                                                       
      END IF                                                            
!                                                                       
      RETURN                                                            
!                                                                       
!     End of CSVD_CLASET                                                     
!                                                                       
      END SUBROUTINE CSVD_CLASET
                                                              
      SUBROUTINE CSVD_CLASR( SIDE, PIVOT, DIRECT, M, N, C, S, A, LDA )       
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     October 31, 1992                                                  
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          DIRECT, PIVOT, SIDE                            
      INTEGER            LDA, M, N                                      
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               C( * ), S( * )                                 
      COMPLEX            A( LDA, * )                                    
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CLASR   performs the transformation                                  
!                                                                       
!     A := P*A,   when SIDE = 'L' or 'l'  (  Left-hand side )           
!                                                                       
!     A := A*P',  when SIDE = 'R' or 'r'  ( Right-hand side )           
!                                                                       
!  where A is an m by n complex matrix and P is an orthogonal matrix,   
!  consisting of a sequence of plane rotations determined by the        
!  parameters PIVOT and DIRECT as follows ( z = m when SIDE = 'L' or 'l'
!  and z = n when SIDE = 'R' or 'r' ):                                  
!                                                                       
!  When  DIRECT = 'F' or 'f'  ( Forward sequence ) then                 
!                                                                       
!     P = P( z - 1 )*...*P( 2 )*P( 1 ),                                 
!                                                                       
!  and when DIRECT = 'B' or 'b'  ( Backward sequence ) then             
!                                                                       
!     P = P( 1 )*P( 2 )*...*P( z - 1 ),                                 
!                                                                       
!  where  P( k ) is a plane rotation matrix for the following planes:   
!                                                                       
!     when  PIVOT = 'V' or 'v'  ( Variable pivot ),                     
!        the plane ( k, k + 1 )                                         
!                                                                       
!     when  PIVOT = 'T' or 't'  ( Top pivot ),                          
!        the plane ( 1, k + 1 )                                         
!                                                                       
!     when  PIVOT = 'B' or 'b'  ( Bottom pivot ),                       
!        the plane ( k, z )                                             
!                                                                       
!  c( k ) and s( k )  must contain the  cosine and sine that define the 
!  matrix  P( k ).  The two by two plane rotation part of the matrix    
!  P( k ), R( k ), is assumed to be of the form                         
!                                                                       
!     R( k ) = (  c( k )  s( k ) ).                                     
!              ( -s( k )  c( k ) )                                      
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  SIDE    (input) CHARACTER*1                                          
!          Specifies whether the plane rotation matrix P is applied to  
!          A on the left or the right.                                  
!          = 'L':  Left, compute A := P*A                               
!          = 'R':  Right, compute A:= A*P'                              
!                                                                       
!  DIRECT  (input) CHARACTER*1                                          
!          Specifies whether P is a forward or backward sequence of     
!          plane rotations.                                             
!          = 'F':  Forward, P = P( z - 1 )*...*P( 2 )*P( 1 )            
!          = 'B':  Backward, P = P( 1 )*P( 2 )*...*P( z - 1 )           
!                                                                       
!  PIVOT   (input) CHARACTER*1                                          
!          Specifies the plane for which P(k) is a plane rotation       
!          matrix.                                                      
!          = 'V':  Variable pivot, the plane (k,k+1)                    
!          = 'T':  Top pivot, the plane (1,k+1)                         
!          = 'B':  Bottom pivot, the plane (k,z)                        
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix A.  If m &lt;= 1, an immedia
!          return is effected.                                          
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix A.  If n &lt;= 1, an     
!          immediate return is effected.                                
!                                                                       
!  C, S    (input) REAL arrays, dimension                               
!                  (M-1) if SIDE = 'L'                                  
!                  (N-1) if SIDE = 'R'                                  
!          c(k) and s(k) contain the cosine and sine that define the    
!          matrix P(k).  The two by two plane rotation part of the      
!          matrix P(k), R(k), is assumed to be of the form              
!          R( k ) = (  c( k )  s( k ) ).                                
!                   ( -s( k )  c( k ) )                                 
!                                                                       
!  A       (input/output) COMPLEX array, dimension (LDA,N)              
!          The m by n matrix A.  On exit, A is overwritten by P*A if    
!          SIDE = 'R' or by A*P' if SIDE = 'L'.                         
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA &gt;= max(1,M).   
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ONE, ZERO                                      
      PARAMETER          ( ONE = 1.0E+0, ZERO = 0.0E+0 )                
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, INFO, J                                     
      REAL               CTEMP, STEMP                                   
      COMPLEX            TEMP                                           
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX                                            
!     ..                                                                
!     .. External Functions ..                                          
!     LOGICAL            csvd_lsame                                          
!     EXTERNAL           csvd_lsame                                          
!     ..                                                                
!     .. External Subroutines ..                                        
!     EXTERNAL           CSVD_XERBLA                                         
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters                                         
!                                                                       
      INFO = 0                                                          
      IF( .NOT.( csvd_lsame( SIDE, 'L' ) .OR. csvd_lsame( SIDE, 'R' ) ) ) THEN 
         INFO = 1                                                       
      ELSE IF( .NOT.( csvd_lsame( PIVOT, 'V' ) .OR. csvd_lsame( PIVOT,    &
               'T' ) .OR. csvd_lsame( PIVOT, 'B' ) ) ) THEN                  
         INFO = 2                                                       
      ELSE IF( .NOT.( csvd_lsame( DIRECT, 'F' )               &
              .OR. csvd_lsame( DIRECT, 'B' )))  THEN
         INFO = 3                                                       
      ELSE IF( M.LT.0 ) THEN                                            
         INFO = 4                                                       
      ELSE IF( N.LT.0 ) THEN                                            
         INFO = 5                                                       
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN                                
         INFO = 9                                                       
      END IF                                                            
      IF( INFO.NE.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_CLASR ', INFO )
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( ( M.EQ.0 ) .OR. ( N.EQ.0 ) )                                    &
         RETURN                                                         
      IF( csvd_lsame( SIDE, 'L' ) ) THEN                                     
!                                                                       
!        Form  P * A                                                    
!                                                                       
         IF( csvd_lsame( PIVOT, 'V' ) ) THEN                                 
            IF( csvd_lsame( DIRECT, 'F' ) ) THEN                             
               DO 20 J = 1, M - 1                                       
                  CTEMP = C( J )                                        
                  STEMP = S( J )                                        
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN    
                     DO 10 I = 1, N                                     
                        TEMP = A( J+1, I )                              
                        A( J+1, I ) = CTEMP*TEMP - STEMP*A( J, I )      
                        A( J, I ) = STEMP*TEMP + CTEMP*A( J, I )        
   10                CONTINUE                                           
                  END IF                                                
   20          CONTINUE                                                 
            ELSE IF( csvd_lsame( DIRECT, 'B' ) ) THEN                        
               DO 40 J = M - 1, 1, -1                                   
                  CTEMP = C( J )                                        
                  STEMP = S( J )                                        
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN    
                     DO 30 I = 1, N                                     
                        TEMP = A( J+1, I )                              
                        A( J+1, I ) = CTEMP*TEMP - STEMP*A( J, I )      
                        A( J, I ) = STEMP*TEMP + CTEMP*A( J, I )        
   30                CONTINUE                                           
                  END IF                                                
   40          CONTINUE                                                 
            END IF                                                      
         ELSE IF( csvd_lsame( PIVOT, 'T' ) ) THEN                            
            IF( csvd_lsame( DIRECT, 'F' ) ) THEN                             
               DO 60 J = 2, M                                           
                  CTEMP = C( J-1 )                                      
                  STEMP = S( J-1 )                                      
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN    
                     DO 50 I = 1, N                                     
                        TEMP = A( J, I )                                
                        A( J, I ) = CTEMP*TEMP - STEMP*A( 1, I )        
                        A( 1, I ) = STEMP*TEMP + CTEMP*A( 1, I )        
   50                CONTINUE                                           
                  END IF                                                
   60          CONTINUE                                                 
            ELSE IF( csvd_lsame( DIRECT, 'B' ) ) THEN                        
               DO 80 J = M, 2, -1                                       
                  CTEMP = C( J-1 )                                      
                  STEMP = S( J-1 )                                      
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN    
                     DO 70 I = 1, N                                     
                        TEMP = A( J, I )                                
                        A( J, I ) = CTEMP*TEMP - STEMP*A( 1, I )        
                        A( 1, I ) = STEMP*TEMP + CTEMP*A( 1, I )        
   70                CONTINUE                                           
                  END IF                                                
   80          CONTINUE                                                 
            END IF                                                      
         ELSE IF( csvd_lsame( PIVOT, 'B' ) ) THEN                            
            IF( csvd_lsame( DIRECT, 'F' ) ) THEN                             
               DO 100 J = 1, M - 1                                      
                  CTEMP = C( J )                                        
                  STEMP = S( J )                                        
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN    
                     DO 90 I = 1, N                                     
                        TEMP = A( J, I )                                
                        A( J, I ) = STEMP*A( M, I ) + CTEMP*TEMP        
                        A( M, I ) = CTEMP*A( M, I ) - STEMP*TEMP        
   90                CONTINUE                                           
                  END IF                                                
  100          CONTINUE                                                 
            ELSE IF( csvd_lsame( DIRECT, 'B' ) ) THEN                        
               DO 120 J = M - 1, 1, -1                                  
                  CTEMP = C( J )                                        
                  STEMP = S( J )                                        
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN    
                     DO 110 I = 1, N                                    
                        TEMP = A( J, I )                                
                        A( J, I ) = STEMP*A( M, I ) + CTEMP*TEMP        
                        A( M, I ) = CTEMP*A( M, I ) - STEMP*TEMP        
  110                CONTINUE                                           
                  END IF                                                
  120          CONTINUE                                                 
            END IF                                                      
         END IF                                                         
      ELSE IF( csvd_lsame( SIDE, 'R' ) ) THEN                                
!                                                                       
!        Form A * P'                                                    
!                                                                       
         IF( csvd_lsame( PIVOT, 'V' ) ) THEN                                 
            IF( csvd_lsame( DIRECT, 'F' ) ) THEN                             
               DO 140 J = 1, N - 1                                      
                  CTEMP = C( J )                                        
                  STEMP = S( J )                                        
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN    
                     DO 130 I = 1, M                                    
                        TEMP = A( I, J+1 )                              
                        A( I, J+1 ) = CTEMP*TEMP - STEMP*A( I, J )      
                        A( I, J ) = STEMP*TEMP + CTEMP*A( I, J )        
  130                CONTINUE                                           
                  END IF                                                
  140          CONTINUE                                                 
            ELSE IF( csvd_lsame( DIRECT, 'B' ) ) THEN                        
               DO 160 J = N - 1, 1, -1                                  
                  CTEMP = C( J )                                        
                  STEMP = S( J )                                        
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN    
                     DO 150 I = 1, M                                    
                        TEMP = A( I, J+1 )                              
                        A( I, J+1 ) = CTEMP*TEMP - STEMP*A( I, J )      
                        A( I, J ) = STEMP*TEMP + CTEMP*A( I, J )        
  150                CONTINUE                                           
                  END IF                                                
  160          CONTINUE                                                 
            END IF                                                      
         ELSE IF( csvd_lsame( PIVOT, 'T' ) ) THEN                            
            IF( csvd_lsame( DIRECT, 'F' ) ) THEN                             
               DO 180 J = 2, N                                          
                  CTEMP = C( J-1 )                                      
                  STEMP = S( J-1 )                                      
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN    
                     DO 170 I = 1, M                                    
                        TEMP = A( I, J )                                
                        A( I, J ) = CTEMP*TEMP - STEMP*A( I, 1 )        
                        A( I, 1 ) = STEMP*TEMP + CTEMP*A( I, 1 )        
  170                CONTINUE                                           
                  END IF                                                
  180          CONTINUE                                                 
            ELSE IF( csvd_lsame( DIRECT, 'B' ) ) THEN                        
               DO 200 J = N, 2, -1                                      
                  CTEMP = C( J-1 )                                      
                  STEMP = S( J-1 )                                      
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN    
                     DO 190 I = 1, M                                    
                        TEMP = A( I, J )                                
                        A( I, J ) = CTEMP*TEMP - STEMP*A( I, 1 )        
                        A( I, 1 ) = STEMP*TEMP + CTEMP*A( I, 1 )        
  190                CONTINUE                                           
                  END IF                                                
  200          CONTINUE                                                 
            END IF                                                      
         ELSE IF( csvd_lsame( PIVOT, 'B' ) ) THEN                            
            IF( csvd_lsame( DIRECT, 'F' ) ) THEN                             
               DO 220 J = 1, N - 1                                      
                  CTEMP = C( J )                                        
                  STEMP = S( J )                                        
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN    
                     DO 210 I = 1, M                                    
                        TEMP = A( I, J )                                
                        A( I, J ) = STEMP*A( I, N ) + CTEMP*TEMP        
                        A( I, N ) = CTEMP*A( I, N ) - STEMP*TEMP        
  210                CONTINUE                                           
                  END IF                                                
  220          CONTINUE                                                 
            ELSE IF( csvd_lsame( DIRECT, 'B' ) ) THEN                        
               DO 240 J = N - 1, 1, -1                                  
                  CTEMP = C( J )                                        
                  STEMP = S( J )                                        
                  IF( ( CTEMP.NE.ONE ) .OR. ( STEMP.NE.ZERO ) ) THEN    
                     DO 230 I = 1, M                                    
                        TEMP = A( I, J )                                
                        A( I, J ) = STEMP*A( I, N ) + CTEMP*TEMP        
                        A( I, N ) = CTEMP*A( I, N ) - STEMP*TEMP        
  230                CONTINUE                                           
                  END IF                                                
  240          CONTINUE                                                 
            END IF                                                      
         END IF                                                         
      END IF                                                            
!                                                                       
      RETURN                                                            
!                                                                       
!     End of CSVD_CLASR                                                      
!                                                                       
      END SUBROUTINE CSVD_CLASR
                                                              
      SUBROUTINE CSVD_CLASSQ( N, X, INCX, SCALE, SUMSQ )                     
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     June 30, 1999                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INCX, N                                        
      REAL               SCALE, SUMSQ                                   
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            X( * )                                         
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CLASSQ returns the values scl and ssq such that                      
!                                                                       
!     ( scl**2 )*ssq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,  
!                                                                       
!  where x( i ) = abs( X( 1 + ( i - 1 )*INCX ) ). The value of sumsq is 
!  assumed to be at least unity and the value of ssq will then satisfy  
!                                                                       
!     1.0 .le. ssq .le. ( sumsq + 2*n ).                                
!                                                                       
!  scale is assumed to be non-negative and scl returns the value        
!                                                                       
!     scl = max( scale, abs( real( x( i ) ) ), abs( aimag( x( i ) ) ) ),
!            i                                                          
!                                                                       
!  scale and sumsq must be supplied in SCALE and SUMSQ respectively.    
!  SCALE and SUMSQ are overwritten by scl and ssq respectively.         
!                                                                       
!  The routine makes only one pass through the vector X.                
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  N       (input) INTEGER                                              
!          The number of elements to be used from the vector X.         
!                                                                       
!  X       (input) COMPLEX array, dimension (N)                         
!          The vector x as described above.                             
!             x( i )  = X( 1 + ( i - 1 )*INCX ), 1 &lt;= i &lt;= n.     
!                                                                       
!  INCX    (input) INTEGER                                              
!          The increment between successive values of the vector X.     
!          INCX &gt; 0.                                                 
!                                                                       
!  SCALE   (input/output) REAL                                          
!          On entry, the value  scale  in the equation above.           
!          On exit, SCALE is overwritten with the value  scl .          
!                                                                       
!  SUMSQ   (input/output) REAL                                          
!          On entry, the value  sumsq  in the equation above.           
!          On exit, SUMSQ is overwritten with the value  ssq .          
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO                                           
      PARAMETER          ( ZERO = 0.0E+0 )                              
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            IX                                             
      REAL               TEMP1                                          
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, AIMAG, REAL                               
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( N.GT.0 ) THEN                                                 
         DO 10 IX = 1, 1 + ( N-1 )*INCX, INCX                           
            IF( REAL( X( IX ) ).NE.ZERO ) THEN                          
               TEMP1 = ABS( REAL( X( IX ) ) )                           
               IF( SCALE.LT.TEMP1 ) THEN                                
                  SUMSQ = 1 + SUMSQ*( SCALE / TEMP1 )**2                
                  SCALE = TEMP1                                         
               ELSE                                                     
                  SUMSQ = SUMSQ + ( TEMP1 / SCALE )**2                  
               END IF                                                   
            END IF                                                      
            IF( AIMAG( X( IX ) ).NE.ZERO ) THEN                         
               TEMP1 = ABS( AIMAG( X( IX ) ) )                          
               IF( SCALE.LT.TEMP1 ) THEN                                
                  SUMSQ = 1 + SUMSQ*( SCALE / TEMP1 )**2                
                  SCALE = TEMP1                                         
               ELSE                                                     
                  SUMSQ = SUMSQ + ( TEMP1 / SCALE )**2                  
               END IF                                                   
            END IF                                                      
   10    CONTINUE                                                       
      END IF                                                            
!                                                                       
      RETURN                                                            
!                                                                       
!     End of CSVD_CLASSQ                                                     
!                                                                       
      END SUBROUTINE CSVD_CLASSQ
                                                              
      SUBROUTINE CSVD_CSROT( N, CX, INCX, CY, INCY, C, S )                   
!                                                                       
!     applies a plane rotation, where the cos and sin (c and s) are real
!     and the vectors cx and cy are complex.                            
!     jack dongarra, linpack, 3/11/78.                                  
!                                                                       
!  =====================================================================
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER           INCX, INCY, N                                   
      REAL              C, S                                            
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX           CX( * ), CY( * )                                
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER           I, IX, IY                                       
      COMPLEX           CTEMP                                           
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( N.LE.0 )                                                        &
         RETURN                                                         
      IF( INCX.EQ.1 .AND. INCY.EQ.1 )                                     &
         GO TO 20                                                       
!                                                                       
!        code for unequal increments or equal increments not equal      
!          to 1                                                         
!                                                                       
      IX = 1                                                            
      IY = 1                                                            
      IF( INCX.LT.0 )                                                     &
         IX = ( -N+1 )*INCX + 1                                         
      IF( INCY.LT.0 )                                                     &
         IY = ( -N+1 )*INCY + 1                                         
      DO 10 I = 1, N                                                    
         CTEMP = C*CX( IX ) + S*CY( IY )                                
         CY( IY ) = C*CY( IY ) - S*CX( IX )                             
         CX( IX ) = CTEMP                                               
         IX = IX + INCX                                                 
         IY = IY + INCY                                                 
   10 CONTINUE                                                          
      RETURN                                                            
!                                                                       
!        code for both increments equal to 1                            
!                                                                       
   20 DO 30 I = 1, N                                                    
         CTEMP = C*CX( I ) + S*CY( I )                                  
         CY( I ) = C*CY( I ) - S*CX( I )                                
         CX( I ) = CTEMP                                                
   30 CONTINUE                                                          
      RETURN                                                            
      END SUBROUTINE CSVD_CSROT
                                                              
      SUBROUTINE CSVD_CUNG2R( M, N, K, A, LDA, TAU, WORK, INFO )             
!                                                                       
!  -- LAPACK routine (version 3.0) --                                   
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     September 30, 1994                                                
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, K, LDA, M, N                             
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * ), TAU( * ), WORK( * )               
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CUNG2R generates an m by n complex matrix Q with orthonormal columns,
!  which is defined as the first n columns of a product of k elementary 
!  reflectors of order m                                                
!                                                                       
!        Q  =  H(1) H(2) . . . H(k)                                     
!                                                                       
!  as returned by CSVD_CGEQRF.                                               
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix Q. M &gt;= 0.               
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix Q. M &gt;= N &gt;= 0.    
!                                                                       
!  K       (input) INTEGER                                              
!          The number of elementary reflectors whose product defines the
!          matrix Q. N &gt;= K &gt;= 0.                                 
!                                                                       
!  A       (input/output) COMPLEX array, dimension (LDA,N)              
!          On entry, the i-th column must contain the vector which      
!          defines the elementary reflector H(i), for i = 1,2,...,k, as 
!          returned by CSVD_CGEQRF in the first k columns of its array       
!          argument A.                                                  
!          On exit, the m by n matrix Q.                                
!                                                                       
!  LDA     (input) INTEGER                                              
!          The first dimension of the array A. LDA &gt;= max(1,M).      
!                                                                       
!  TAU     (input) COMPLEX array, dimension (K)                         
!          TAU(i) must contain the scalar factor of the elementary      
!          reflector H(i), as returned by CSVD_CGEQRF.                       
!                                                                       
!  WORK    (workspace) COMPLEX array, dimension (N)                     
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0: successful exit                                         
!          &lt; 0: if INFO = -i, the i-th argument has an illegal value 
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      COMPLEX            ONE, ZERO                                      

!      PARAMETER          ( ONE = CMPLX( 1.0E+0, 0.0E+0 ),           &
!                         ZERO = CMPLX( 0.0E+0, 0.0E+0 ) )
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, J, L                                        
!     ..                                                                
!     .. External Subroutines ..                                        
!     EXTERNAL           CSVD_CLARF, CSVD_cscal, CSVD_XERBLA
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX                                            
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      ONE  = CMPLX( 1.0E+0, 0.0E+0 )               
      ZERO = CMPLX( 0.0E+0, 0.0E+0 ) 

      INFO = 0                                                          
      IF( M.LT.0 ) THEN                                                 
         INFO = -1                                                      
      ELSE IF( N.LT.0 .OR. N.GT.M ) THEN                                
         INFO = -2                                                      
      ELSE IF( K.LT.0 .OR. K.GT.N ) THEN                                
         INFO = -3                                                      
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN                                
         INFO = -5                                                      
      END IF                                                            
      IF( INFO.NE.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_CUNG2R', -INFO )
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 )                                                        &
         RETURN                                                         
!                                                                       
!     Initialise columns k+1:n to columns of the unit matrix            
!                                                                       
      DO 20 J = K + 1, N                                                
         DO 10 L = 1, M                                                 
            A( L, J ) = ZERO                                            
   10    CONTINUE                                                       
         A( J, J ) = ONE                                                
   20 CONTINUE                                                          
!                                                                       
      DO 40 I = K, 1, -1                                                
!                                                                       
!        Apply H(i) to A(i:m,i:n) from the left                         
!                                                                       
         IF( I.LT.N ) THEN                                              
            A( I, I ) = ONE                                             
            CALL CSVD_CLARF( 'Left', M-I+1, N-I, A( I, I ), 1, TAU( I ),       &
                        A( I, I+1 ), LDA, WORK )                        
         END IF                                                         
         IF( I.LT.M )                                                     &
            CALL CSVD_cscal( M-I, -TAU( I ), A( I+1, I ), 1 )                
         A( I, I ) = ONE - TAU( I )                                     
!                                                                       
!        Set A(1:i-1,i) to zero                                         
!                                                                       
         DO 30 L = 1, I - 1                                             
            A( L, I ) = ZERO                                            
   30    CONTINUE                                                       
   40 CONTINUE                                                          
      RETURN                                                            
!                                                                       
!     End of CSVD_CUNG2R                                                     
!                                                                       
      END SUBROUTINE CSVD_CUNG2R
                                                              
      SUBROUTINE CSVD_CUNGBR( VECT, M, N, K, A, LDA, TAU, WORK, LWORK, INFO )
!                                                                       
!  -- LAPACK routine (version 3.0) --                                   
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     June 30, 1999                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          VECT                                           
      INTEGER            INFO, K, LDA, LWORK, M, N                      
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * ), TAU( * ), WORK( * )               
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CUNGBR generates one of the complex unitary matrices Q or P**H       
!  determined by CSVD_CGEBRD when reducing a complex matrix A to bidiagonal  
!  form: A = Q * B * P**H.  Q and P**H are defined as products of       
!  elementary reflectors H(i) or G(i) respectively.                     
!                                                                       
!  If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q     
!  is of order M:                                                       
!  if m &gt;= k, Q = H(1) H(2) . . . H(k) and CSVD_CUNGBR returns the first n
!  columns of Q, where m &gt;= n &gt;= k;                               
!  if m &lt; k, Q = H(1) H(2) . . . H(m-1) and CSVD_CUNGBR returns Q as an   
!  M-by-M matrix.                                                       
!                                                                       
!  If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**H   
!  is of order N:                                                       
!  if k &lt; n, P**H = G(k) . . . G(2) G(1) and CSVD_CUNGBR returns the first
!  rows of P**H, where n &gt;= m &gt;= k;                               
!  if k &gt;= n, P**H = G(n-1) . . . G(2) G(1) and CSVD_CUNGBR returns P**H a
!  an N-by-N matrix.                                                    
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  VECT    (input) CHARACTER*1                                          
!          Specifies whether the matrix Q or the matrix P**H is         
!          required, as defined in the transformation applied by CSVD_CGEBRD:
!          = 'Q':  generate Q;                                          
!          = 'P':  generate P**H.                                       
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix Q or P**H to be returned.   
!          M &gt;= 0.                                                   
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix Q or P**H to be returned.
!          N &gt;= 0.                                                   
!          If VECT = 'Q', M &gt;= N &gt;= min(M,K);                     
!          if VECT = 'P', N &gt;= M &gt;= min(N,K).                     
!                                                                       
!  K       (input) INTEGER                                              
!          If VECT = 'Q', the number of columns in the original M-by-K  
!          matrix reduced by CSVD_CGEBRD.                                    
!          If VECT = 'P', the number of rows in the original K-by-N     
!          matrix reduced by CSVD_CGEBRD.                                    
!          K &gt;= 0.                                                   
!                                                                       
!  A       (input/output) COMPLEX array, dimension (LDA,N)              
!          On entry, the vectors which define the elementary reflectors,
!          as returned by CSVD_CGEBRD.                                       
!          On exit, the M-by-N matrix Q or P**H.                        
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A. LDA &gt;= M.           
!                                                                       
!  TAU     (input) COMPLEX array, dimension                             
!                                (min(M,K)) if VECT = 'Q'               
!                                (min(N,K)) if VECT = 'P'               
!          TAU(i) must contain the scalar factor of the elementary      
!          reflector H(i) or G(i), which determines Q or P**H, as       
!          returned by CSVD_CGEBRD in its array argument TAUQ or TAUP.       
!                                                                       
!  WORK    (workspace/output) COMPLEX array, dimension (LWORK)          
!          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.     
!                                                                       
!  LWORK   (input) INTEGER                                              
!          The dimension of the array WORK. LWORK &gt;= max(1,min(M,N)).
!          For optimum performance LWORK &gt;= min(M,N)*NB, where NB    
!          is the optimal blocksize.                                    
!                                                                       
!          If LWORK = -1, then a workspace query is assumed; the routine
!          only calculates the optimal size of the WORK array, returns  
!          this value as the first entry of the WORK array, and no error
!          message related to LWORK is issued by CSVD_XERBLA.                
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0:  successful exit                                        
!          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      COMPLEX            ZERO, ONE                                      

!      PARAMETER          ( ZERO = CMPLX( 0.0E+0, 0.0E+0 ),          &
!                         ONE = CMPLX( 1.0E+0, 0.0E+0 ) )
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            LQUERY, WANTQ                                  
      INTEGER            I, IINFO, J, LWKOPT, MN, NB                    
!     ..                                                                
!     .. External Functions ..                                          
!      LOGICAL            csvd_lsame                                          
!      INTEGER            csvd_ilaenv                                         
!      EXTERNAL           csvd_ilaenv, csvd_lsame 
!     ..                                                                
!     .. External Subroutines ..                                        
!     EXTERNAL           CSVD_CUNGLQ, CSVD_CUNGQR, CSVD_XERBLA
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN                                       
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      ONE  = CMPLX( 1.0E+0, 0.0E+0 )               
      ZERO = CMPLX( 0.0E+0, 0.0E+0 ) 

      INFO = 0                                                          
      WANTQ = csvd_lsame( VECT, 'Q' )                                        
      MN = MIN( M, N )                                                  
      LQUERY = ( LWORK.EQ.-1 )                                          
      IF( .NOT.WANTQ .AND. .NOT.csvd_lsame( VECT, 'P' ) ) THEN               
         INFO = -1                                                      
      ELSE IF( M.LT.0 ) THEN                                            
         INFO = -2                                                      
      ELSE IF( N.LT.0 .OR. ( WANTQ .AND. ( N.GT.M .OR. N.LT.MIN( M,       &
               K ) ) ) .OR. ( .NOT.WANTQ .AND. ( M.GT.N .OR. M.LT.        &
               MIN( N, K ) ) ) ) THEN                                   
         INFO = -3                                                      
      ELSE IF( K.LT.0 ) THEN                                            
         INFO = -4                                                      
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN                                
         INFO = -6                                                      
      ELSE IF( LWORK.LT.MAX( 1, MN ) .AND. .NOT.LQUERY ) THEN           
         INFO = -9                                                      
      END IF                                                            
!                                                                       
      IF( INFO.EQ.0 ) THEN                                              
         IF( WANTQ ) THEN                                               
            NB = csvd_ilaenv( 1, 'CSVD_CUNGQR', ' ', M, N, K, -1 )
         ELSE                                                           
            NB = csvd_ilaenv( 1, 'CSVD_CUNGLQ', ' ', M, N, K, -1 )
         END IF                                                         
         LWKOPT = MAX( 1, MN )*NB                                       
         WORK( 1 ) = LWKOPT                                             
      END IF                                                            
!                                                                       
      IF( INFO.NE.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_CUNGBR', -INFO )
         RETURN                                                         
      ELSE IF( LQUERY ) THEN                                            
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( M.EQ.0 .OR. N.EQ.0 ) THEN                                     
         WORK( 1 ) = 1                                                  
         RETURN                                                         
      END IF                                                            
!                                                                       
      IF( WANTQ ) THEN                                                  
!                                                                       
!        Form Q, determined by a call to CSVD_CGEBRD to reduce an m-by-k     
!        matrix                                                         
!                                                                       
         IF( M.GE.K ) THEN                                              
!                                                                       
!           If m &gt;= k, assume m &gt;= n &gt;= k                      
!                                                                       
            CALL CSVD_CUNGQR( M, N, K, A, LDA, TAU, WORK, LWORK, IINFO )     
!                                                                       
         ELSE                                                           
!                                                                       
!           If m &lt; k, assume m = n                                   
!                                                                       
!           Shift the vectors which define the elementary reflectors one
!           column to the right, and set the first row and column of Q  
!           to those of the unit matrix                                 
!                                                                       
            DO 20 J = M, 2, -1                                          
               A( 1, J ) = ZERO                                         
               DO 10 I = J + 1, M                                       
                  A( I, J ) = A( I, J-1 )                               
   10          CONTINUE                                                 
   20       CONTINUE                                                    
            A( 1, 1 ) = ONE                                             
            DO 30 I = 2, M                                              
               A( I, 1 ) = ZERO                                         
   30       CONTINUE                                                    
            IF( M.GT.1 ) THEN                                           
!                                                                       
!              Form Q(2:m,2:m)                                          
!                                                                       
               CALL CSVD_CUNGQR( M-1, M-1, M-1, A( 2, 2 ), LDA, TAU, WORK,     &
                            LWORK, IINFO )                              
            END IF                                                      
         END IF                                                         
      ELSE                                                              
!                                                                       
!        Form P', determined by a call to CSVD_CGEBRD to reduce a k-by-n     
!        matrix                                                         
!                                                                       
         IF( K.LT.N ) THEN                                              
!                                                                       
!           If k &lt; n, assume k &lt;= m &lt;= n                       
!                                                                       
            CALL CSVD_CUNGLQ( M, N, K, A, LDA, TAU, WORK, LWORK, IINFO )     
!                                                                       
         ELSE                                                           
!                                                                       
!           If k &gt;= n, assume m = n                                  
!                                                                       
!           Shift the vectors which define the elementary reflectors one
!           row downward, and set the first row and column of P' to     
!           those of the unit matrix                                    
!                                                                       
            A( 1, 1 ) = ONE                                             
            DO 40 I = 2, N                                              
               A( I, 1 ) = ZERO                                         
   40       CONTINUE                                                    
            DO 60 J = 2, N                                              
               DO 50 I = J - 1, 2, -1                                   
                  A( I, J ) = A( I-1, J )                               
   50          CONTINUE                                                 
               A( 1, J ) = ZERO                                         
   60       CONTINUE                                                    
            IF( N.GT.1 ) THEN                                           
!                                                                       
!              Form P'(2:n,2:n)                                         
!                                                                       
               CALL CSVD_CUNGLQ( N-1, N-1, N-1, A( 2, 2 ), LDA, TAU, WORK,     &
                            LWORK, IINFO )                              
            END IF                                                      
         END IF                                                         
      END IF                                                            
      WORK( 1 ) = LWKOPT                                                
      RETURN                                                            
!                                                                       
!     End of CSVD_CUNGBR                                                     
!                                                                       
      END SUBROUTINE CSVD_CUNGBR
                                                              
      SUBROUTINE CSVD_CUNGL2( M, N, K, A, LDA, TAU, WORK, INFO )             
!                                                                       
!  -- LAPACK routine (version 3.0) --                                   
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     June 30, 1999                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, K, LDA, M, N                             
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * ), TAU( * ), WORK( * )               
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CUNGL2 generates an m-by-n complex matrix Q with orthonormal rows,   
!  which is defined as the first m rows of a product of k elementary    
!  reflectors of order n                                                
!                                                                       
!        Q  =  H(k)' . . . H(2)' H(1)'                                  
!                                                                       
!  as returned by CSVD_CGELQF.                                               
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix Q. M &gt;= 0.               
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix Q. N &gt;= M.            
!                                                                       
!  K       (input) INTEGER                                              
!          The number of elementary reflectors whose product defines the
!          matrix Q. M &gt;= K &gt;= 0.                                 
!                                                                       
!  A       (input/output) COMPLEX array, dimension (LDA,N)              
!          On entry, the i-th row must contain the vector which defines 
!          the elementary reflector H(i), for i = 1,2,...,k, as returned
!          by CSVD_CGELQF in the first k rows of its array argument A.       
!          On exit, the m by n matrix Q.                                
!                                                                       
!  LDA     (input) INTEGER                                              
!          The first dimension of the array A. LDA &gt;= max(1,M).      
!                                                                       
!  TAU     (input) COMPLEX array, dimension (K)                         
!          TAU(i) must contain the scalar factor of the elementary      
!          reflector H(i), as returned by CSVD_CGELQF.                       
!                                                                       
!  WORK    (workspace) COMPLEX array, dimension (M)                     
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0: successful exit                                         
!          &lt; 0: if INFO = -i, the i-th argument has an illegal value 
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
       COMPLEX            ONE, ZERO                                      

!      PARAMETER          ( ONE = CMPLX( 1.0E+0, 0.0E+0 ),          &
!                         ZERO = CMPLX( 0.0E+0, 0.0E+0 ) )
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, J, L                                        
!     ..                                                                
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_CLACGV, CSVD_CLARF, CSVD_cscal, CSVD_XERBLA
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          CONJG, MAX                                     
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      ONE  = CMPLX( 1.0E+0, 0.0E+0 )               
      ZERO = CMPLX( 0.0E+0, 0.0E+0 ) 

      INFO = 0                                                          
      IF( M.LT.0 ) THEN                                                 
         INFO = -1                                                      
      ELSE IF( N.LT.M ) THEN                                            
         INFO = -2                                                      
      ELSE IF( K.LT.0 .OR. K.GT.M ) THEN                                
         INFO = -3                                                      
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN                                
         INFO = -5                                                      
      END IF                                                            
      IF( INFO.NE.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_CUNGL2', -INFO )
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( M.LE.0 )                                                        &
         RETURN                                                         
!                                                                       
      IF( K.LT.M ) THEN                                                 
!                                                                       
!        Initialise rows k+1:m to rows of the unit matrix               
!                                                                       
         DO 20 J = 1, N                                                 
            DO 10 L = K + 1, M                                          
               A( L, J ) = ZERO                                         
   10       CONTINUE                                                    
            IF( J.GT.K .AND. J.LE.M )                                     &
               A( J, J ) = ONE                                          
   20    CONTINUE                                                       
      END IF                                                            
!                                                                       
      DO 40 I = K, 1, -1                                                
!                                                                       
!        Apply H(i)' to A(i:m,i:n) from the right                       
!                                                                       
         IF( I.LT.N ) THEN                                              
            CALL CSVD_CLACGV( N-I, A( I, I+1 ), LDA )                        
            IF( I.LT.M ) THEN                                           
               A( I, I ) = ONE                                          
               CALL CSVD_CLARF( 'Right', M-I, N-I+1, A( I, I ), LDA,           &
                           CONJG( TAU( I ) ), A( I+1, I ), LDA, WORK )  
            END IF                                                      
            CALL CSVD_cscal( N-I, -TAU( I ), A( I, I+1 ), LDA )              
            CALL CSVD_CLACGV( N-I, A( I, I+1 ), LDA )                        
         END IF                                                         
         A( I, I ) = ONE - CONJG( TAU( I ) )                            
!                                                                       
!        Set A(i,1:i-1,i) to zero                                       
!                                                                       
         DO 30 L = 1, I - 1                                             
            A( I, L ) = ZERO                                            
   30    CONTINUE                                                       
   40 CONTINUE                                                          
      RETURN                                                            
!                                                                       
!     End of CSVD_CUNGL2                                                     
!                                                                       
      END SUBROUTINE CSVD_CUNGL2
                                                              
      SUBROUTINE CSVD_CUNGLQ( M, N, K, A, LDA, TAU, WORK, LWORK, INFO )      
!                                                                       
!  -- LAPACK routine (version 3.0) --                                   
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     June 30, 1999                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, K, LDA, LWORK, M, N                      
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * ), TAU( * ), WORK( * )               
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CUNGLQ generates an M-by-N complex matrix Q with orthonormal rows,   
!  which is defined as the first M rows of a product of K elementary    
!  reflectors of order N                                                
!                                                                       
!        Q  =  H(k)' . . . H(2)' H(1)'                                  
!                                                                       
!  as returned by CSVD_CGELQF.                                               
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix Q. M &gt;= 0.               
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix Q. N &gt;= M.            
!                                                                       
!  K       (input) INTEGER                                              
!          The number of elementary reflectors whose product defines the
!          matrix Q. M &gt;= K &gt;= 0.                                 
!                                                                       
!  A       (input/output) COMPLEX array, dimension (LDA,N)              
!          On entry, the i-th row must contain the vector which defines 
!          the elementary reflector H(i), for i = 1,2,...,k, as returned
!          by CSVD_CGELQF in the first k rows of its array argument A.       
!          On exit, the M-by-N matrix Q.                                
!                                                                       
!  LDA     (input) INTEGER                                              
!          The first dimension of the array A. LDA &gt;= max(1,M).      
!                                                                       
!  TAU     (input) COMPLEX array, dimension (K)                         
!          TAU(i) must contain the scalar factor of the elementary      
!          reflector H(i), as returned by CSVD_CGELQF.                       
!                                                                       
!  WORK    (workspace/output) COMPLEX array, dimension (LWORK)          
!          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.     
!                                                                       
!  LWORK   (input) INTEGER                                              
!          The dimension of the array WORK. LWORK &gt;= max(1,M).       
!          For optimum performance LWORK &gt;= M*NB, where NB is        
!          the optimal blocksize.                                       
!                                                                       
!          If LWORK = -1, then a workspace query is assumed; the routine
!          only calculates the optimal size of the WORK array, returns  
!          this value as the first entry of the WORK array, and no error
!          message related to LWORK is issued by CSVD_XERBLA.                
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0:  successful exit;                                       
!          &lt; 0:  if INFO = -i, the i-th argument has an illegal value
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      COMPLEX            ZERO                                           
!      PARAMETER          ( ZERO = CMPLX( 0.0E+0, 0.0E+0 ) )
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            LQUERY                                         
      INTEGER            I, IB, IINFO, IWS, J, KI, KK, L, LDWORK,         &
                         LWKOPT, NB, NBMIN, NX                          
!     ..                                                                
!     .. External Subroutines ..                                        
!     EXTERNAL           CSVD_CLARFB, CSVD_CLARFT, CSVD_CUNGL2, CSVD_XERBLA
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN                                       
!     ..                                                                
!     .. External Functions ..                                          
!      INTEGER            csvd_ilaenv                                         
!      EXTERNAL           csvd_ilaenv                                         
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      ZERO = CMPLX( 0.0E+0, 0.0E+0 ) 

      INFO = 0                                                          
      NB = csvd_ilaenv( 1, 'CSVD_CUNGLQ', ' ', M, N, K, -1 )
      LWKOPT = MAX( 1, M )*NB                                           
      WORK( 1 ) = LWKOPT                                                
      LQUERY = ( LWORK.EQ.-1 )                                          
      IF( M.LT.0 ) THEN                                                 
         INFO = -1                                                      
      ELSE IF( N.LT.M ) THEN                                            
         INFO = -2                                                      
      ELSE IF( K.LT.0 .OR. K.GT.M ) THEN                                
         INFO = -3                                                      
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN                                
         INFO = -5                                                      
      ELSE IF( LWORK.LT.MAX( 1, M ) .AND. .NOT.LQUERY ) THEN            
         INFO = -8                                                      
      END IF                                                            
      IF( INFO.NE.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_CUNGLQ', -INFO )
         RETURN                                                         
      ELSE IF( LQUERY ) THEN                                            
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( M.LE.0 ) THEN                                                 
         WORK( 1 ) = 1                                                  
         RETURN                                                         
      END IF                                                            
!                                                                       
      NBMIN = 2                                                         
      NX = 0                                                            
      IWS = M                                                           
      IF( NB.GT.1 .AND. NB.LT.K ) THEN                                  
!                                                                       
!        Determine when to cross over from blocked to unblocked code.   
!                                                                       
         NX = MAX( 0, csvd_ilaenv( 3, 'CSVD_CUNGLQ', ' ', M, N, K, -1 ) )
         IF( NX.LT.K ) THEN                                             
!                                                                       
!           Determine if workspace is large enough for blocked code.    
!                                                                       
            LDWORK = M                                                  
            IWS = LDWORK*NB                                             
            IF( LWORK.LT.IWS ) THEN                                     
!                                                                       
!              Not enough workspace to use optimal NB:  reduce NB and   
!              determine the minimum value of NB.                       
!                                                                       
               NB = LWORK / LDWORK                                      
               NBMIN = MAX( 2, csvd_ilaenv( 2, 'CSVD_CUNGLQ', ' ', M, N, K, -1))
            END IF                                                      
         END IF                                                         
      END IF                                                            
!                                                                       
      IF( NB.GE.NBMIN .AND. NB.LT.K .AND. NX.LT.K ) THEN                
!                                                                       
!        Use blocked code after the last block.                         
!        The first kk rows are handled by the block method.             
!                                                                       
         KI = ( ( K-NX-1 ) / NB )*NB                                    
         KK = MIN( K, KI+NB )                                           
!                                                                       
!        Set A(kk+1:m,1:kk) to zero.                                    
!                                                                       
         DO 20 J = 1, KK                                                
            DO 10 I = KK + 1, M                                         
               A( I, J ) = ZERO                                         
   10       CONTINUE                                                    
   20    CONTINUE                                                       
      ELSE                                                              
         KK = 0                                                         
      END IF                                                            
!                                                                       
!     Use unblocked code for the last or only block.                    
!                                                                       
      IF( KK.LT.M )                                                       &
         CALL CSVD_CUNGL2( M-KK, N-KK, K-KK, A( KK+1, KK+1 ), LDA,             &
                      TAU( KK+1 ), WORK, IINFO )                        
!                                                                       
      IF( KK.GT.0 ) THEN                                                
!                                                                       
!        Use blocked code                                               
!                                                                       
         DO 50 I = KI + 1, 1, -NB                                       
            IB = MIN( NB, K-I+1 )                                       
            IF( I+IB.LE.M ) THEN                                        
!                                                                       
!              Form the triangular factor of the block reflector        
!              H = H(i) H(i+1) . . . H(i+ib-1)                          
!                                                                       
               CALL CSVD_CLARFT( 'Forward', 'Rowwise', N-I+1, IB, A( I, I ),   &
                            LDA, TAU( I ), WORK, LDWORK )               
!                                                                       
!              Apply H' to A(i+ib:m,i:n) from the right                 
!                                                                       
               CALL CSVD_CLARFB( 'Right', 'Conjugate transpose', 'Forward',    &
                            'Rowwise', M-I-IB+1, N-I+1, IB, A( I, I ),    &
                            LDA, WORK, LDWORK, A( I+IB, I ), LDA,         &
                            WORK( IB+1 ), LDWORK )                      
            END IF                                                      
!                                                                       
!           Apply H' to columns i:n of current block                    
!                                                                       
            CALL CSVD_CUNGL2( IB, N-I+1, IB, A( I, I ), LDA, TAU( I ), WORK,   &
                         IINFO )                                        
!                                                                       
!           Set columns 1:i-1 of current block to zero                  
!                                                                       
            DO 40 J = 1, I - 1                                          
               DO 30 L = I, I + IB - 1                                  
                  A( L, J ) = ZERO                                      
   30          CONTINUE                                                 
   40       CONTINUE                                                    
   50    CONTINUE                                                       
      END IF                                                            
!                                                                       
      WORK( 1 ) = IWS                                                   
      RETURN                                                            
!                                                                       
!     End of CSVD_CUNGLQ                                                     
!                                                                       
      END SUBROUTINE CSVD_CUNGLQ
                                                              
      SUBROUTINE CSVD_CUNGQR( M, N, K, A, LDA, TAU, WORK, LWORK, INFO )      
!                                                                       
!  -- LAPACK routine (version 3.0) --                                   
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     June 30, 1999                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, K, LDA, LWORK, M, N                      
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * ), TAU( * ), WORK( * )               
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CUNGQR generates an M-by-N complex matrix Q with orthonormal columns,
!  which is defined as the first N columns of a product of K elementary 
!  reflectors of order M                                                
!                                                                       
!        Q  =  H(1) H(2) . . . H(k)                                     
!                                                                       
!  as returned by CSVD_CGEQRF.                                               
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix Q. M &gt;= 0.               
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix Q. M &gt;= N &gt;= 0.    
!                                                                       
!  K       (input) INTEGER                                              
!          The number of elementary reflectors whose product defines the
!          matrix Q. N &gt;= K &gt;= 0.                                 
!                                                                       
!  A       (input/output) COMPLEX array, dimension (LDA,N)              
!          On entry, the i-th column must contain the vector which      
!          defines the elementary reflector H(i), for i = 1,2,...,k, as 
!          returned by CSVD_CGEQRF in the first k columns of its array       
!          argument A.                                                  
!          On exit, the M-by-N matrix Q.                                
!                                                                       
!  LDA     (input) INTEGER                                              
!          The first dimension of the array A. LDA &gt;= max(1,M).      
!                                                                       
!  TAU     (input) COMPLEX array, dimension (K)                         
!          TAU(i) must contain the scalar factor of the elementary      
!          reflector H(i), as returned by CSVD_CGEQRF.                       
!                                                                       
!  WORK    (workspace/output) COMPLEX array, dimension (LWORK)          
!          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.     
!                                                                       
!  LWORK   (input) INTEGER                                              
!          The dimension of the array WORK. LWORK &gt;= max(1,N).       
!          For optimum performance LWORK &gt;= N*NB, where NB is the    
!          optimal blocksize.                                           
!                                                                       
!          If LWORK = -1, then a workspace query is assumed; the routine
!          only calculates the optimal size of the WORK array, returns  
!          this value as the first entry of the WORK array, and no error
!          message related to LWORK is issued by CSVD_XERBLA.                
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0:  successful exit                                        
!          &lt; 0:  if INFO = -i, the i-th argument has an illegal value
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      COMPLEX            ZERO                                           
!      PARAMETER          ( ZERO = CMPLX( 0.0E+0, 0.0E+0 ) )
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            LQUERY                                         
      INTEGER            I, IB, IINFO, IWS, J, KI, KK, L, LDWORK,         &
                         LWKOPT, NB, NBMIN, NX                          
!     ..                                                                
!     .. External Subroutines ..                                        
!     EXTERNAL           CSVD_CLARFB, CSVD_CLARFT, CSVD_CUNG2R, CSVD_XERBLA
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN                                       
!     ..                                                                
!     .. External Functions ..                                          
!      INTEGER            csvd_ilaenv                                         
!      EXTERNAL           csvd_ilaenv                                         
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      ZERO = CMPLX( 0.0E+0, 0.0E+0 )

      INFO = 0                                                          
      NB = csvd_ilaenv( 1, 'CSVD_CUNGQR', ' ', M, N, K, -1 )
      LWKOPT = MAX( 1, N )*NB                                           
      WORK( 1 ) = LWKOPT                                                
      LQUERY = ( LWORK.EQ.-1 )                                          
      IF( M.LT.0 ) THEN                                                 
         INFO = -1                                                      
      ELSE IF( N.LT.0 .OR. N.GT.M ) THEN                                
         INFO = -2                                                      
      ELSE IF( K.LT.0 .OR. K.GT.N ) THEN                                
         INFO = -3                                                      
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN                                
         INFO = -5                                                      
      ELSE IF( LWORK.LT.MAX( 1, N ) .AND. .NOT.LQUERY ) THEN            
         INFO = -8                                                      
      END IF                                                            
      IF( INFO.NE.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_CUNGQR', -INFO )
         RETURN                                                         
      ELSE IF( LQUERY ) THEN                                            
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.0 ) THEN                                                 
         WORK( 1 ) = 1                                                  
         RETURN                                                         
      END IF                                                            
!                                                                       
      NBMIN = 2                                                         
      NX = 0                                                            
      IWS = N                                                           
      IF( NB.GT.1 .AND. NB.LT.K ) THEN                                  
!                                                                       
!        Determine when to cross over from blocked to unblocked code.   
!                                                                       
         NX = MAX( 0, csvd_ilaenv( 3, 'CSVD_CUNGQR', ' ', M, N, K, -1 ) )
         IF( NX.LT.K ) THEN                                             
!                                                                       
!           Determine if workspace is large enough for blocked code.    
!                                                                       
            LDWORK = N                                                  
            IWS = LDWORK*NB                                             
            IF( LWORK.LT.IWS ) THEN                                     
!                                                                       
!              Not enough workspace to use optimal NB:  reduce NB and   
!              determine the minimum value of NB.                       
!                                                                       
               NB = LWORK / LDWORK                                      
               NBMIN = MAX( 2, csvd_ilaenv( 2, 'CSVD_CUNGQR', ' ', M, N, K, -1))
            END IF                                                      
         END IF                                                         
      END IF                                                            
!                                                                       
      IF( NB.GE.NBMIN .AND. NB.LT.K .AND. NX.LT.K ) THEN                
!                                                                       
!        Use blocked code after the last block.                         
!        The first kk columns are handled by the block method.          
!                                                                       
         KI = ( ( K-NX-1 ) / NB )*NB                                    
         KK = MIN( K, KI+NB )                                           
!                                                                       
!        Set A(1:kk,kk+1:n) to zero.                                    
!                                                                       
         DO 20 J = KK + 1, N                                            
            DO 10 I = 1, KK                                             
               A( I, J ) = ZERO                                         
   10       CONTINUE                                                    
   20    CONTINUE                                                       
      ELSE                                                              
         KK = 0                                                         
      END IF                                                            
!                                                                       
!     Use unblocked code for the last or only block.                    
!                                                                       
      IF( KK.LT.N )                                                       &
         CALL CSVD_CUNG2R( M-KK, N-KK, K-KK, A( KK+1, KK+1 ), LDA,             &
                      TAU( KK+1 ), WORK, IINFO )                        
!                                                                       
      IF( KK.GT.0 ) THEN                                                
!                                                                       
!        Use blocked code                                               
!                                                                       
         DO 50 I = KI + 1, 1, -NB                                       
            IB = MIN( NB, K-I+1 )                                       
            IF( I+IB.LE.N ) THEN                                        
!                                                                       
!              Form the triangular factor of the block reflector        
!              H = H(i) H(i+1) . . . H(i+ib-1)                          
!                                                                       
               CALL CSVD_CLARFT( 'Forward', 'Columnwise', M-I+1, IB,           &
                            A( I, I ), LDA, TAU( I ), WORK, LDWORK )    
!                                                                       
!              Apply H to A(i:m,i+ib:n) from the left                   
!                                                                       
               CALL CSVD_CLARFB( 'Left', 'No transpose', 'Forward',            &
                            'Columnwise', M-I+1, N-I-IB+1, IB,            &
                            A( I, I ), LDA, WORK, LDWORK, A( I, I+IB ),   &
                            LDA, WORK( IB+1 ), LDWORK )                 
            END IF                                                      
!                                                                       
!           Apply H to rows i:m of current block                        
!                                                                       
            CALL CSVD_CUNG2R( M-I+1, IB, IB, A( I, I ), LDA, TAU( I ), WORK,   &
                         IINFO )                                        
!                                                                       
!           Set rows 1:i-1 of current block to zero                     
!                                                                       
            DO 40 J = I, I + IB - 1                                     
               DO 30 L = 1, I - 1                                       
                  A( L, J ) = ZERO                                      
   30          CONTINUE                                                 
   40       CONTINUE                                                    
   50    CONTINUE                                                       
      END IF                                                            
!                                                                       
      WORK( 1 ) = IWS                                                   
      RETURN                                                            
!                                                                       
!     End of CSVD_CUNGQR                                                     
!                                                                       
      END SUBROUTINE CSVD_CUNGQR
                                                              
      SUBROUTINE CSVD_CUNM2R( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, &
                         WORK, INFO )                                   
!                                                                       
!  -- LAPACK routine (version 3.0) --                                   
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     September 30, 1994                                                
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          SIDE, TRANS                                    
      INTEGER            INFO, K, LDA, LDC, M, N                        
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )  
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CUNM2R overwrites the general complex m-by-n matrix C with           
!                                                                       
!        Q * C  if SIDE = 'L' and TRANS = 'N', or                       
!                                                                       
!        Q'* C  if SIDE = 'L' and TRANS = 'C', or                       
!                                                                       
!        C * Q  if SIDE = 'R' and TRANS = 'N', or                       
!                                                                       
!        C * Q' if SIDE = 'R' and TRANS = 'C',                          
!                                                                       
!  where Q is a complex unitary matrix defined as the product of k      
!  elementary reflectors                                                
!                                                                       
!        Q = H(1) H(2) . . . H(k)                                       
!                                                                       
!  as returned by CSVD_CGEQRF. Q is of order m if SIDE = 'L' and of order n  
!  if SIDE = 'R'.                                                       
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  SIDE    (input) CHARACTER*1                                          
!          = 'L': apply Q or Q' from the Left                           
!          = 'R': apply Q or Q' from the Right                          
!                                                                       
!  TRANS   (input) CHARACTER*1                                          
!          = 'N': apply Q  (No transpose)                               
!          = 'C': apply Q' (Conjugate transpose)                        
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix C. M &gt;= 0.               
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix C. N &gt;= 0.            
!                                                                       
!  K       (input) INTEGER                                              
!          The number of elementary reflectors whose product defines    
!          the matrix Q.                                                
!          If SIDE = 'L', M &gt;= K &gt;= 0;                            
!          if SIDE = 'R', N &gt;= K &gt;= 0.                            
!                                                                       
!  A       (input) COMPLEX array, dimension (LDA,K)                     
!          The i-th column must contain the vector which defines the    
!          elementary reflector H(i), for i = 1,2,...,k, as returned by 
!          CSVD_CGEQRF in the first k columns of its array argument A.       
!          A is modified by the routine but restored on exit.           
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.                        
!          If SIDE = 'L', LDA &gt;= max(1,M);                           
!          if SIDE = 'R', LDA &gt;= max(1,N).                           
!                                                                       
!  TAU     (input) COMPLEX array, dimension (K)                         
!          TAU(i) must contain the scalar factor of the elementary      
!          reflector H(i), as returned by CSVD_CGEQRF.                       
!                                                                       
!  C       (input/output) COMPLEX array, dimension (LDC,N)              
!          On entry, the m-by-n matrix C.                               
!          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.     
!                                                                       
!  LDC     (input) INTEGER                                              
!          The leading dimension of the array C. LDC &gt;= max(1,M).    
!                                                                       
!  WORK    (workspace) COMPLEX array, dimension                         
!                                   (N) if SIDE = 'L',                  
!                                   (M) if SIDE = 'R'                   
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0: successful exit                                         
!          &lt; 0: if INFO = -i, the i-th argument had an illegal value 
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      COMPLEX            ONE                                            
!      PARAMETER          ( ONE = CMPLX( 1.0E+0, 0.0E+0 ) )
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            LEFT, NOTRAN                                   
      INTEGER            I, I1, I2, I3, IC, JC, MI, NI, NQ              
      COMPLEX            AII, TAUI                                      
!     ..                                                                
!     .. External Functions ..                                          
!     LOGICAL            csvd_lsame                                          
!     EXTERNAL           csvd_lsame                                          
!     ..                                                                
!     .. External Subroutines ..                                        
!     EXTERNAL           CSVD_CLARF, CSVD_XERBLA
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          CONJG, MAX                                     
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      ONE  = CMPLX( 1.0E+0, 0.0E+0 ) 

      INFO = 0                                                          
      LEFT = csvd_lsame( SIDE, 'L' )                                         
      NOTRAN = csvd_lsame( TRANS, 'N' )                                      
!                                                                       
!     NQ is the order of Q                                              
!                                                                       
      IF( LEFT ) THEN                                                   
         NQ = M                                                         
      ELSE                                                              
         NQ = N                                                         
      END IF                                                            
      IF( .NOT.LEFT .AND. .NOT.csvd_lsame( SIDE, 'R' ) ) THEN                
         INFO = -1                                                      
      ELSE IF( .NOT.NOTRAN .AND. .NOT.csvd_lsame( TRANS, 'C' ) ) THEN        
         INFO = -2                                                      
      ELSE IF( M.LT.0 ) THEN                                            
         INFO = -3                                                      
      ELSE IF( N.LT.0 ) THEN                                            
         INFO = -4                                                      
      ELSE IF( K.LT.0 .OR. K.GT.NQ ) THEN                               
         INFO = -5                                                      
      ELSE IF( LDA.LT.MAX( 1, NQ ) ) THEN                               
         INFO = -7                                                      
      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN                                
         INFO = -10                                                     
      END IF                                                            
      IF( INFO.NE.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_CUNM2R', -INFO )
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( M.EQ.0 .OR. N.EQ.0 .OR. K.EQ.0 )                                &
         RETURN                                                         
!                                                                       
      IF( ( LEFT .AND. .NOT.NOTRAN .OR. .NOT.LEFT .AND. NOTRAN ) ) THEN 
         I1 = 1                                                         
         I2 = K                                                         
         I3 = 1                                                         
      ELSE                                                              
         I1 = K                                                         
         I2 = 1                                                         
         I3 = -1                                                        
      END IF                                                            
!                                                                       
      IF( LEFT ) THEN                                                   
         NI = N                                                         
         JC = 1                                                         
      ELSE                                                              
         MI = M                                                         
         IC = 1                                                         
      END IF                                                            
!                                                                       
      DO 10 I = I1, I2, I3                                              
         IF( LEFT ) THEN                                                
!                                                                       
!           H(i) or H(i)' is applied to C(i:m,1:n)                      
!                                                                       
            MI = M - I + 1                                              
            IC = I                                                      
         ELSE                                                           
!                                                                       
!           H(i) or H(i)' is applied to C(1:m,i:n)                      
!                                                                       
            NI = N - I + 1                                              
            JC = I                                                      
         END IF                                                         
!                                                                       
!        Apply H(i) or H(i)'                                            
!                                                                       
         IF( NOTRAN ) THEN                                              
            TAUI = TAU( I )                                             
         ELSE                                                           
            TAUI = CONJG( TAU( I ) )                                    
         END IF                                                         
         AII = A( I, I )                                                
         A( I, I ) = ONE                                                
         CALL CSVD_CLARF( SIDE, MI, NI, A( I, I ), 1, TAUI, C( IC, JC ), LDC,  &
                     WORK )                                             
         A( I, I ) = AII                                                
   10 CONTINUE                                                          
      RETURN                                                            
!                                                                       
!     End of CSVD_CUNM2R                                                     
!                                                                       
      END SUBROUTINE CSVD_CUNM2R
                                                             
      SUBROUTINE CSVD_CUNMBR( VECT, SIDE, TRANS, M, N, K, A, LDA, TAU, C, &
                         LDC, WORK, LWORK, INFO )                       
!                                                                       
!  -- LAPACK routine (version 3.0) --                                   
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     June 30, 1999                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          SIDE, TRANS, VECT                              
      INTEGER            INFO, K, LDA, LDC, LWORK, M, N                 
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * ), C( LDC, * ), TAU( * ),              &
                         WORK( * )                                      
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  If VECT = 'Q', CSVD_CUNMBR overwrites the general complex M-by-N matrix C 
!  with                                                                 
!                  SIDE = 'L'     SIDE = 'R'                            
!  TRANS = 'N':      Q * C          C * Q                               
!  TRANS = 'C':      Q**H * C       C * Q**H                            
!                                                                       
!  If VECT = 'P', CSVD_CUNMBR overwrites the general complex M-by-N matrix C 
!  with                                                                 
!                  SIDE = 'L'     SIDE = 'R'                            
!  TRANS = 'N':      P * C          C * P                               
!  TRANS = 'C':      P**H * C       C * P**H                            
!                                                                       
!  Here Q and P**H are the unitary matrices determined by CSVD_CGEBRD when   
!  reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q  
!  and P**H are defined as products of elementary reflectors H(i) and   
!  G(i) respectively.                                                   
!                                                                       
!  Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the    
!  order of the unitary matrix Q or P**H that is applied.               
!                                                                       
!  If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:          
!  if nq &gt;= k, Q = H(1) H(2) . . . H(k);                             
!  if nq &lt; k, Q = H(1) H(2) . . . H(nq-1).                           
!                                                                       
!  If VECT = 'P', A is assumed to have been a K-by-NQ matrix:           
!  if k &lt; nq, P = G(1) G(2) . . . G(k);                              
!  if k &gt;= nq, P = G(1) G(2) . . . G(nq-1).                          
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  VECT    (input) CHARACTER*1                                          
!          = 'Q': apply Q or Q**H;                                      
!          = 'P': apply P or P**H.                                      
!                                                                       
!  SIDE    (input) CHARACTER*1                                          
!          = 'L': apply Q, Q**H, P or P**H from the Left;               
!          = 'R': apply Q, Q**H, P or P**H from the Right.              
!                                                                       
!  TRANS   (input) CHARACTER*1                                          
!          = 'N':  No transpose, apply Q or P;                          
!          = 'C':  Conjugate transpose, apply Q**H or P**H.             
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix C. M &gt;= 0.               
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix C. N &gt;= 0.            
!                                                                       
!  K       (input) INTEGER                                              
!          If VECT = 'Q', the number of columns in the original         
!          matrix reduced by CSVD_CGEBRD.                                    
!          If VECT = 'P', the number of rows in the original            
!          matrix reduced by CSVD_CGEBRD.                                    
!          K &gt;= 0.                                                   
!                                                                       
!  A       (input) COMPLEX array, dimension                             
!                                (LDA,min(nq,K)) if VECT = 'Q'          
!                                (LDA,nq)        if VECT = 'P'          
!          The vectors which define the elementary reflectors H(i) and  
!          G(i), whose products determine the matrices Q and P, as      
!          returned by CSVD_CGEBRD.                                          
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.                        
!          If VECT = 'Q', LDA &gt;= max(1,nq);                          
!          if VECT = 'P', LDA &gt;= max(1,min(nq,K)).                   
!                                                                       
!  TAU     (input) COMPLEX array, dimension (min(nq,K))                 
!          TAU(i) must contain the scalar factor of the elementary      
!          reflector H(i) or G(i) which determines Q or P, as returned  
!          by CSVD_CGEBRD in the array argument TAUQ or TAUP.                
!                                                                       
!  C       (input/output) COMPLEX array, dimension (LDC,N)              
!          On entry, the M-by-N matrix C.                               
!          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q  
!          or P*C or P**H*C or C*P or C*P**H.                           
!                                                                       
!  LDC     (input) INTEGER                                              
!          The leading dimension of the array C. LDC &gt;= max(1,M).    
!                                                                       
!  WORK    (workspace/output) COMPLEX array, dimension (LWORK)          
!          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.     
!                                                                       
!  LWORK   (input) INTEGER                                              
!          The dimension of the array WORK.                             
!          If SIDE = 'L', LWORK &gt;= max(1,N);                         
!          if SIDE = 'R', LWORK &gt;= max(1,M).                         
!          For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and  
!          LWORK &gt;= M*NB if SIDE = 'R', where NB is the optimal      
!          blocksize.                                                   
!                                                                       
!          If LWORK = -1, then a workspace query is assumed; the routine
!          only calculates the optimal size of the WORK array, returns  
!          this value as the first entry of the WORK array, and no error
!          message related to LWORK is issued by CSVD_XERBLA.                
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0:  successful exit                                        
!          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      LOGICAL            APPLYQ, LEFT, LQUERY, NOTRAN                   
      CHARACTER          TRANST                                         
      INTEGER            I1, I2, IINFO, LWKOPT, MI, NB, NI, NQ, NW      
!     ..                                                                
!     .. External Functions ..                                          
!      LOGICAL            csvd_lsame                                          
!      INTEGER            csvd_ilaenv                                         
!      EXTERNAL           csvd_ilaenv, csvd_lsame
!     ..                                                                
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_CUNMLQ, CSVD_CUNMQR, CSVD_XERBLA
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN                                       
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      INFO = 0                                                          
      APPLYQ = csvd_lsame( VECT, 'Q' )                                       
      LEFT = csvd_lsame( SIDE, 'L' )                                         
      NOTRAN = csvd_lsame( TRANS, 'N' )                                      
      LQUERY = ( LWORK.EQ.-1 )                                          
!                                                                       
!     NQ is the order of Q or P and NW is the minimum dimension of WORK 
!                                                                       
      IF( LEFT ) THEN                                                   
         NQ = M                                                         
         NW = N                                                         
      ELSE                                                              
         NQ = N                                                         
         NW = M                                                         
      END IF                                                            
      IF( .NOT.APPLYQ .AND. .NOT.csvd_lsame( VECT, 'P' ) ) THEN              
         INFO = -1                                                      
      ELSE IF( .NOT.LEFT .AND. .NOT.csvd_lsame( SIDE, 'R' ) ) THEN           
         INFO = -2                                                      
      ELSE IF( .NOT.NOTRAN .AND. .NOT.csvd_lsame( TRANS, 'C' ) ) THEN        
         INFO = -3                                                      
      ELSE IF( M.LT.0 ) THEN                                            
         INFO = -4                                                      
      ELSE IF( N.LT.0 ) THEN                                            
         INFO = -5                                                      
      ELSE IF( K.LT.0 ) THEN                                            
         INFO = -6                                                      
      ELSE IF( ( APPLYQ .AND. LDA.LT.MAX( 1, NQ ) ) .OR.                  &
               ( .NOT.APPLYQ .AND. LDA.LT.MAX( 1, MIN( NQ, K ) ) ) )      &
                THEN                                                    
         INFO = -8                                                      
      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN                                
         INFO = -11                                                     
      ELSE IF( LWORK.LT.MAX( 1, NW ) .AND. .NOT.LQUERY ) THEN           
         INFO = -13                                                     
      END IF                                                            
!                                                                       
      IF( INFO.EQ.0 ) THEN                                              
         IF( APPLYQ ) THEN                                              
            IF( LEFT ) THEN                                             
               NB = csvd_ilaenv( 1, 'CSVD_CUNMQR', SIDE // TRANS, M-1, N, M-1, &
                            -1 )                                        
            ELSE                                                        
               NB = csvd_ilaenv( 1, 'CSVD_CUNMQR', SIDE // TRANS, M, N-1, N-1, &
                            -1 )                                        
            END IF                                                      
         ELSE                                                           
            IF( LEFT ) THEN                                             
               NB = csvd_ilaenv( 1, 'CSVD_CUNMLQ', SIDE // TRANS, M-1, N, M-1, &
                            -1 )                                        
            ELSE                                                        
               NB = csvd_ilaenv( 1, 'CSVD_CUNMLQ', SIDE // TRANS, M, N-1, N-1, &
                            -1 )                                        
            END IF                                                      
         END IF                                                         
         LWKOPT = MAX( 1, NW )*NB                                       
         WORK( 1 ) = LWKOPT                                             
      END IF                                                            
!                                                                       
      IF( INFO.NE.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_CUNMBR', -INFO ) 
         RETURN                                                         
      ELSE IF( LQUERY ) THEN                                            
      END IF                                                            
!                                                                       
!     Quick return if possible                                          
!                                                                       
      WORK( 1 ) = 1                                                     
      IF( M.EQ.0 .OR. N.EQ.0 )                                            &
         RETURN                                                         
!                                                                       
      IF( APPLYQ ) THEN                                                 
!                                                                       
!        Apply Q                                                        
!                                                                       
         IF( NQ.GE.K ) THEN                                             
!                                                                       
!           Q was determined by a call to CSVD_CGEBRD with nq &gt;= k        
!                                                                       
            CALL CSVD_CUNMQR( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,       &
                         WORK, LWORK, IINFO )                           
         ELSE IF( NQ.GT.1 ) THEN                                        
!                                                                       
!           Q was determined by a call to CSVD_CGEBRD with nq &lt; k         
!                                                                       
            IF( LEFT ) THEN                                             
               MI = M - 1                                               
               NI = N                                                   
               I1 = 2                                                   
               I2 = 1                                                   
            ELSE                                                        
               MI = M                                                   
               NI = N - 1                                               
               I1 = 1                                                   
               I2 = 2                                                   
            END IF                                                      
            CALL CSVD_CUNMQR( SIDE, TRANS, MI, NI, NQ-1, A( 2, 1 ), LDA, TAU,  &
                         C( I1, I2 ), LDC, WORK, LWORK, IINFO )         
         END IF                                                         
      ELSE                                                              
!                                                                       
!        Apply P                                                        
!                                                                       
         IF( NOTRAN ) THEN                                              
            TRANST = 'C'                                                
         ELSE                                                           
            TRANST = 'N'                                                
         END IF                                                         
         IF( NQ.GT.K ) THEN                                             
!                                                                       
!           P was determined by a call to CSVD_CGEBRD with nq &gt; k         
!                                                                       
            CALL CSVD_CUNMLQ( SIDE, TRANST, M, N, K, A, LDA, TAU, C, LDC,      &
                         WORK, LWORK, IINFO )                           
         ELSE IF( NQ.GT.1 ) THEN                                        
!                                                                       
!           P was determined by a call to CSVD_CGEBRD with nq &lt;= k        
!                                                                       
            IF( LEFT ) THEN                                             
               MI = M - 1                                               
               NI = N                                                   
               I1 = 2                                                   
               I2 = 1                                                   
            ELSE                                                        
               MI = M                                                   
               NI = N - 1                                               
               I1 = 1                                                   
               I2 = 2                                                   
            END IF                                                      
            CALL CSVD_CUNMLQ( SIDE, TRANST, MI, NI, NQ-1, A( 1, 2 ), LDA,      &
                         TAU, C( I1, I2 ), LDC, WORK, LWORK, IINFO )    
         END IF                                                         
      END IF                                                            
      WORK( 1 ) = LWKOPT                                                
      RETURN                                                            
!                                                                       
!     End of CSVD_CUNMBR                                                     
!                                                                       
      END SUBROUTINE CSVD_CUNMBR
                                                               
      SUBROUTINE CSVD_CUNML2( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, &
                         WORK, INFO )                                   
!                                                                       
!  -- LAPACK routine (version 3.0) --                                   
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     September 30, 1994                                                
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          SIDE, TRANS                                    
      INTEGER            INFO, K, LDA, LDC, M, N                        
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * ), C( LDC, * ), TAU( * ), WORK( * )  
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CUNML2 overwrites the general complex m-by-n matrix C with           
!                                                                       
!        Q * C  if SIDE = 'L' and TRANS = 'N', or                       
!                                                                       
!        Q'* C  if SIDE = 'L' and TRANS = 'C', or                       
!                                                                       
!        C * Q  if SIDE = 'R' and TRANS = 'N', or                       
!                                                                       
!        C * Q' if SIDE = 'R' and TRANS = 'C',                          
!                                                                       
!  where Q is a complex unitary matrix defined as the product of k      
!  elementary reflectors                                                
!                                                                       
!        Q = H(k)' . . . H(2)' H(1)'                                    
!                                                                       
!  as returned by CSVD_CGELQF. Q is of order m if SIDE = 'L' and of order n  
!  if SIDE = 'R'.                                                       
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  SIDE    (input) CHARACTER*1                                          
!          = 'L': apply Q or Q' from the Left                           
!          = 'R': apply Q or Q' from the Right                          
!                                                                       
!  TRANS   (input) CHARACTER*1                                          
!          = 'N': apply Q  (No transpose)                               
!          = 'C': apply Q' (Conjugate transpose)                        
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix C. M &gt;= 0.               
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix C. N &gt;= 0.            
!                                                                       
!  K       (input) INTEGER                                              
!          The number of elementary reflectors whose product defines    
!          the matrix Q.                                                
!          If SIDE = 'L', M &gt;= K &gt;= 0;                            
!          if SIDE = 'R', N &gt;= K &gt;= 0.                            
!                                                                       
!  A       (input) COMPLEX array, dimension                             
!                               (LDA,M) if SIDE = 'L',                  
!                               (LDA,N) if SIDE = 'R'                   
!          The i-th row must contain the vector which defines the       
!          elementary reflector H(i), for i = 1,2,...,k, as returned by 
!          CSVD_CGELQF in the first k rows of its array argument A.          
!          A is modified by the routine but restored on exit.           
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A. LDA &gt;= max(1,K).    
!                                                                       
!  TAU     (input) COMPLEX array, dimension (K)                         
!          TAU(i) must contain the scalar factor of the elementary      
!          reflector H(i), as returned by CSVD_CGELQF.                       
!                                                                       
!  C       (input/output) COMPLEX array, dimension (LDC,N)              
!          On entry, the m-by-n matrix C.                               
!          On exit, C is overwritten by Q*C or Q'*C or C*Q' or C*Q.     
!                                                                       
!  LDC     (input) INTEGER                                              
!          The leading dimension of the array C. LDC &gt;= max(1,M).    
!                                                                       
!  WORK    (workspace) COMPLEX array, dimension                         
!                                   (N) if SIDE = 'L',                  
!                                   (M) if SIDE = 'R'                   
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0: successful exit                                         
!          &lt; 0: if INFO = -i, the i-th argument had an illegal value 
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      COMPLEX            ONE                                            
!      PARAMETER          ( ONE = CMPLX( 1.0E+0, 0.0E+0 ) )
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            LEFT, NOTRAN                                   
      INTEGER            I, I1, I2, I3, IC, JC, MI, NI, NQ              
      COMPLEX            AII, TAUI                                      
!     ..                                                                
!     .. External Functions ..                                          
!      LOGICAL            csvd_lsame                                          
!      EXTERNAL           csvd_lsame                                          
!     ..                                                                
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_CLACGV, CSVD_CLARF, CSVD_XERBLA
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          CONJG, MAX                                     
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      ONE  = CMPLX( 1.0E+0, 0.0E+0 ) 

      INFO = 0                                                          
      LEFT = csvd_lsame( SIDE, 'L' )                                         
      NOTRAN = csvd_lsame( TRANS, 'N' )                                      
!                                                                       
!     NQ is the order of Q                                              
!                                                                       
      IF( LEFT ) THEN                                                   
         NQ = M                                                         
      ELSE                                                              
         NQ = N                                                         
      END IF                                                            
      IF( .NOT.LEFT .AND. .NOT.csvd_lsame( SIDE, 'R' ) ) THEN                
         INFO = -1                                                      
      ELSE IF( .NOT.NOTRAN .AND. .NOT.csvd_lsame( TRANS, 'C' ) ) THEN        
         INFO = -2                                                      
      ELSE IF( M.LT.0 ) THEN                                            
         INFO = -3                                                      
      ELSE IF( N.LT.0 ) THEN                                            
         INFO = -4                                                      
      ELSE IF( K.LT.0 .OR. K.GT.NQ ) THEN                               
         INFO = -5                                                      
      ELSE IF( LDA.LT.MAX( 1, K ) ) THEN                                
         INFO = -7                                                      
      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN                                
         INFO = -10                                                     
      END IF                                                            
      IF( INFO.NE.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_CUNML2', -INFO )
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( M.EQ.0 .OR. N.EQ.0 .OR. K.EQ.0 )                                &
         RETURN                                                         
!                                                                       
      IF( ( LEFT .AND. NOTRAN .OR. .NOT.LEFT .AND. .NOT.NOTRAN ) ) THEN 
         I1 = 1                                                         
         I2 = K                                                         
         I3 = 1                                                         
      ELSE                                                              
         I1 = K                                                         
         I2 = 1                                                         
         I3 = -1                                                        
      END IF                                                            
!                                                                       
      IF( LEFT ) THEN                                                   
         NI = N                                                         
         JC = 1                                                         
      ELSE                                                              
         MI = M                                                         
         IC = 1                                                         
      END IF                                                            
!                                                                       
      DO 10 I = I1, I2, I3                                              
         IF( LEFT ) THEN                                                
!                                                                       
!           H(i) or H(i)' is applied to C(i:m,1:n)                      
!                                                                       
            MI = M - I + 1                                              
            IC = I                                                      
         ELSE                                                           
!                                                                       
!           H(i) or H(i)' is applied to C(1:m,i:n)                      
!                                                                       
            NI = N - I + 1                                              
            JC = I                                                      
         END IF                                                         
!                                                                       
!        Apply H(i) or H(i)'                                            
!                                                                       
         IF( NOTRAN ) THEN                                              
            TAUI = CONJG( TAU( I ) )                                    
         ELSE                                                           
            TAUI = TAU( I )                                             
         END IF                                                         
         IF( I.LT.NQ )                                                    &
            CALL CSVD_CLACGV( NQ-I, A( I, I+1 ), LDA )                       
         AII = A( I, I )                                                
         A( I, I ) = ONE                                                
         CALL CSVD_CLARF( SIDE, MI, NI, A( I, I ), LDA, TAUI, C( IC, JC ),     &
                     LDC, WORK )                                        
         A( I, I ) = AII                                                
         IF( I.LT.NQ )                                                    &
            CALL CSVD_CLACGV( NQ-I, A( I, I+1 ), LDA )                       
   10 CONTINUE                                                          
      RETURN                                                            
!                                                                       
!     End of CSVD_CUNML2                                                     
!                                                                       
      END SUBROUTINE CSVD_CUNML2
                                                              
      SUBROUTINE CSVD_CUNMLQ( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,  &
                         WORK, LWORK, INFO )                            
!                                                                       
!  -- LAPACK routine (version 3.0) --                                   
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     June 30, 1999                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          SIDE, TRANS                                    
      INTEGER            INFO, K, LDA, LDC, LWORK, M, N                 
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * ), C( LDC, * ), TAU( * ),              &
                         WORK( * )                                      
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CUNMLQ overwrites the general complex M-by-N matrix C with           
!                                                                       
!                  SIDE = 'L'     SIDE = 'R'                            
!  TRANS = 'N':      Q * C          C * Q                               
!  TRANS = 'C':      Q**H * C       C * Q**H                            
!                                                                       
!  where Q is a complex unitary matrix defined as the product of k      
!  elementary reflectors                                                
!                                                                       
!        Q = H(k)' . . . H(2)' H(1)'                                    
!                                                                       
!  as returned by CSVD_CGELQF. Q is of order M if SIDE = 'L' and of order N  
!  if SIDE = 'R'.                                                       
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  SIDE    (input) CHARACTER*1                                          
!          = 'L': apply Q or Q**H from the Left;                        
!          = 'R': apply Q or Q**H from the Right.                       
!                                                                       
!  TRANS   (input) CHARACTER*1                                          
!          = 'N':  No transpose, apply Q;                               
!          = 'C':  Conjugate transpose, apply Q**H.                     
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix C. M &gt;= 0.               
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix C. N &gt;= 0.            
!                                                                       
!  K       (input) INTEGER                                              
!          The number of elementary reflectors whose product defines    
!          the matrix Q.                                                
!          If SIDE = 'L', M &gt;= K &gt;= 0;                            
!          if SIDE = 'R', N &gt;= K &gt;= 0.                            
!                                                                       
!  A       (input) COMPLEX array, dimension                             
!                               (LDA,M) if SIDE = 'L',                  
!                               (LDA,N) if SIDE = 'R'                   
!          The i-th row must contain the vector which defines the       
!          elementary reflector H(i), for i = 1,2,...,k, as returned by 
!          CSVD_CGELQF in the first k rows of its array argument A.          
!          A is modified by the routine but restored on exit.           
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A. LDA &gt;= max(1,K).    
!                                                                       
!  TAU     (input) COMPLEX array, dimension (K)                         
!          TAU(i) must contain the scalar factor of the elementary      
!          reflector H(i), as returned by CSVD_CGELQF.                       
!                                                                       
!  C       (input/output) COMPLEX array, dimension (LDC,N)              
!          On entry, the M-by-N matrix C.                               
!          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q. 
!                                                                       
!  LDC     (input) INTEGER                                              
!          The leading dimension of the array C. LDC &gt;= max(1,M).    
!                                                                       
!  WORK    (workspace/output) COMPLEX array, dimension (LWORK)          
!          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.     
!                                                                       
!  LWORK   (input) INTEGER                                              
!          The dimension of the array WORK.                             
!          If SIDE = 'L', LWORK &gt;= max(1,N);                         
!          if SIDE = 'R', LWORK &gt;= max(1,M).                         
!          For optimum performance LWORK &gt;= N*NB if SIDE 'L', and    
!          LWORK &gt;= M*NB if SIDE = 'R', where NB is the optimal      
!          blocksize.                                                   
!                                                                       
!          If LWORK = -1, then a workspace query is assumed; the routine
!          only calculates the optimal size of the WORK array, returns  
!          this value as the first entry of the WORK array, and no error
!          message related to LWORK is issued by CSVD_XERBLA.                
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0:  successful exit                                        
!          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      INTEGER            NBMAX, LDT                                     
      PARAMETER          ( NBMAX = 64, LDT = NBMAX+1 )                  
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            LEFT, LQUERY, NOTRAN                           
      CHARACTER          TRANST                                         
      INTEGER            I, I1, I2, I3, IB, IC, IINFO, IWS, JC, LDWORK,   &
                         LWKOPT, MI, NB, NBMIN, NI, NQ, NW              
!     ..                                                                
!     .. Local Arrays ..                                                
      COMPLEX            T( LDT, NBMAX )                                
!     ..                                                                
!     .. External Functions ..                                          
!      LOGICAL            csvd_lsame                                          
!      INTEGER            csvd_ilaenv                                         
!      EXTERNAL           csvd_lsame, csvd_ilaenv 
!     ..                                                                
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_CLARFB, CSVD_CLARFT, CSVD_CUNML2, CSVD_XERBLA 
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN                                       
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      INFO = 0                                                          
      LEFT = csvd_lsame( SIDE, 'L' )                                         
      NOTRAN = csvd_lsame( TRANS, 'N' )                                      
      LQUERY = ( LWORK.EQ.-1 )                                          
!                                                                       
!     NQ is the order of Q and NW is the minimum dimension of WORK      
!                                                                       
      IF( LEFT ) THEN                                                   
         NQ = M                                                         
         NW = N                                                         
      ELSE                                                              
         NQ = N                                                         
         NW = M                                                         
      END IF                                                            
      IF( .NOT.LEFT .AND. .NOT.csvd_lsame( SIDE, 'R' ) ) THEN                
         INFO = -1                                                      
      ELSE IF( .NOT.NOTRAN .AND. .NOT.csvd_lsame( TRANS, 'C' ) ) THEN        
         INFO = -2                                                      
      ELSE IF( M.LT.0 ) THEN                                            
         INFO = -3                                                      
      ELSE IF( N.LT.0 ) THEN                                            
         INFO = -4                                                      
      ELSE IF( K.LT.0 .OR. K.GT.NQ ) THEN                               
         INFO = -5                                                      
      ELSE IF( LDA.LT.MAX( 1, K ) ) THEN                                
         INFO = -7                                                      
      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN                                
         INFO = -10                                                     
      ELSE IF( LWORK.LT.MAX( 1, NW ) .AND. .NOT.LQUERY ) THEN           
         INFO = -12                                                     
      END IF                                                            
!                                                                       
      IF( INFO.EQ.0 ) THEN                                              
!                                                                       
!        Determine the block size.  NB may be at most NBMAX, where NBMAX
!        is used to define the local array T.                           
!                                                                       
         NB = MIN( NBMAX, csvd_ilaenv( 1, 'CSVD_CUNMLQ', SIDE // TRANS, M, N,K,&
                   -1 ) )                                               
         LWKOPT = MAX( 1, NW )*NB                                       
         WORK( 1 ) = LWKOPT                                             
      END IF                                                            
!                                                                       
      IF( INFO.NE.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_CUNMLQ', -INFO )
         RETURN                                                         
      ELSE IF( LQUERY ) THEN                                            
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( M.EQ.0 .OR. N.EQ.0 .OR. K.EQ.0 ) THEN                         
         WORK( 1 ) = 1                                                  
         RETURN                                                         
      END IF                                                            
!                                                                       
      NBMIN = 2                                                         
      LDWORK = NW                                                       
      IF( NB.GT.1 .AND. NB.LT.K ) THEN                                  
         IWS = NW*NB                                                    
         IF( LWORK.LT.IWS ) THEN                                        
            NB = LWORK / LDWORK                                         
            NBMIN = MAX(2, csvd_ilaenv(2,'CSVD_CUNMLQ', SIDE // TRANS, M, N,K,&
                    -1 ) )                                              
         END IF                                                         
      ELSE                                                              
         IWS = NW                                                       
      END IF                                                            
!                                                                       
      IF( NB.LT.NBMIN .OR. NB.GE.K ) THEN                               
!                                                                       
!        Use unblocked code                                             
!                                                                       
         CALL CSVD_CUNML2( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK,    &
                      IINFO )                                           
      ELSE                                                              
!                                                                       
!        Use blocked code                                               
!                                                                       
         IF( ( LEFT .AND. NOTRAN ) .OR.                                   &
             ( .NOT.LEFT .AND. .NOT.NOTRAN ) ) THEN                     
            I1 = 1                                                      
            I2 = K                                                      
            I3 = NB                                                     
         ELSE                                                           
            I1 = ( ( K-1 ) / NB )*NB + 1                                
            I2 = 1                                                      
            I3 = -NB                                                    
         END IF                                                         
!                                                                       
         IF( LEFT ) THEN                                                
            NI = N                                                      
            JC = 1                                                      
         ELSE                                                           
            MI = M                                                      
            IC = 1                                                      
         END IF                                                         
!                                                                       
         IF( NOTRAN ) THEN                                              
            TRANST = 'C'                                                
         ELSE                                                           
            TRANST = 'N'                                                
         END IF                                                         
!                                                                       
         DO 10 I = I1, I2, I3                                           
            IB = MIN( NB, K-I+1 )                                       
!                                                                       
!           Form the triangular factor of the block reflector           
!           H = H(i) H(i+1) . . . H(i+ib-1)                             
!                                                                       
            CALL CSVD_CLARFT( 'Forward', 'Rowwise', NQ-I+1, IB, A( I, I ),     &
                         LDA, TAU( I ), T, LDT )                        
            IF( LEFT ) THEN                                             
!                                                                       
!              H or H' is applied to C(i:m,1:n)                         
!                                                                       
               MI = M - I + 1                                           
               IC = I                                                   
            ELSE                                                        
!                                                                       
!              H or H' is applied to C(1:m,i:n)                         
!                                                                       
               NI = N - I + 1                                           
               JC = I                                                   
            END IF                                                      
!                                                                       
!           Apply H or H'                                               
!                                                                       
            CALL CSVD_CLARFB( SIDE, TRANST, 'Forward', 'Rowwise', MI, NI, IB,  &
                         A( I, I ), LDA, T, LDT, C( IC, JC ), LDC, WORK,  &
                         LDWORK )                                       
   10    CONTINUE                                                       
      END IF                                                            
      WORK( 1 ) = LWKOPT                                                
      RETURN                                                            
!                                                                       
!     End of CSVD_CUNMLQ                                                     
!                                                                       
      END  SUBROUTINE CSVD_CUNMLQ
                                                             
      SUBROUTINE CSVD_CUNMQR( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC,  &
                         WORK, LWORK, INFO )                            
!                                                                       
!  -- LAPACK routine (version 3.0) --                                   
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     June 30, 1999                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          SIDE, TRANS                                    
      INTEGER            INFO, K, LDA, LDC, LWORK, M, N                 
!     ..                                                                
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * ), C( LDC, * ), TAU( * ),              &
                         WORK( * )                                      
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CUNMQR overwrites the general complex M-by-N matrix C with           
!                                                                       
!                  SIDE = 'L'     SIDE = 'R'                            
!  TRANS = 'N':      Q * C          C * Q                               
!  TRANS = 'C':      Q**H * C       C * Q**H                            
!                                                                       
!  where Q is a complex unitary matrix defined as the product of k      
!  elementary reflectors                                                
!                                                                       
!        Q = H(1) H(2) . . . H(k)                                       
!                                                                       
!  as returned by CSVD_CGEQRF. Q is of order M if SIDE = 'L' and of order N  
!  if SIDE = 'R'.                                                       
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  SIDE    (input) CHARACTER*1                                          
!          = 'L': apply Q or Q**H from the Left;                        
!          = 'R': apply Q or Q**H from the Right.                       
!                                                                       
!  TRANS   (input) CHARACTER*1                                          
!          = 'N':  No transpose, apply Q;                               
!          = 'C':  Conjugate transpose, apply Q**H.                     
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix C. M &gt;= 0.               
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix C. N &gt;= 0.            
!                                                                       
!  K       (input) INTEGER                                              
!          The number of elementary reflectors whose product defines    
!          the matrix Q.                                                
!          If SIDE = 'L', M &gt;= K &gt;= 0;                            
!          if SIDE = 'R', N &gt;= K &gt;= 0.                            
!                                                                       
!  A       (input) COMPLEX array, dimension (LDA,K)                     
!          The i-th column must contain the vector which defines the    
!          elementary reflector H(i), for i = 1,2,...,k, as returned by 
!          CSVD_CGEQRF in the first k columns of its array argument A.       
!          A is modified by the routine but restored on exit.           
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.                        
!          If SIDE = 'L', LDA &gt;= max(1,M);                           
!          if SIDE = 'R', LDA &gt;= max(1,N).                           
!                                                                       
!  TAU     (input) COMPLEX array, dimension (K)                         
!          TAU(i) must contain the scalar factor of the elementary      
!          reflector H(i), as returned by CSVD_CGEQRF.                       
!                                                                       
!  C       (input/output) COMPLEX array, dimension (LDC,N)              
!          On entry, the M-by-N matrix C.                               
!          On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q. 
!                                                                       
!  LDC     (input) INTEGER                                              
!          The leading dimension of the array C. LDC &gt;= max(1,M).    
!                                                                       
!  WORK    (workspace/output) COMPLEX array, dimension (LWORK)          
!          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.     
!                                                                       
!  LWORK   (input) INTEGER                                              
!          The dimension of the array WORK.                             
!          If SIDE = 'L', LWORK &gt;= max(1,N);                         
!          if SIDE = 'R', LWORK &gt;= max(1,M).                         
!          For optimum performance LWORK &gt;= N*NB if SIDE = 'L', and  
!          LWORK &gt;= M*NB if SIDE = 'R', where NB is the optimal      
!          blocksize.                                                   
!                                                                       
!          If LWORK = -1, then a workspace query is assumed; the routine
!          only calculates the optimal size of the WORK array, returns  
!          this value as the first entry of the WORK array, and no error
!          message related to LWORK is issued by CSVD_XERBLA.                
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0:  successful exit                                        
!          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      INTEGER            NBMAX, LDT                                     
      PARAMETER          ( NBMAX = 64, LDT = NBMAX+1 )                  
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            LEFT, LQUERY, NOTRAN                           
      INTEGER            I, I1, I2, I3, IB, IC, IINFO, IWS, JC, LDWORK,   &
                         LWKOPT, MI, NB, NBMIN, NI, NQ, NW              
!     ..                                                                
!     .. Local Arrays ..                                                
      COMPLEX            T( LDT, NBMAX )                                
!     ..                                                                
!     .. External Functions ..                                          
!      LOGICAL            csvd_lsame                                          
!      INTEGER            csvd_ilaenv 
!      EXTERNAL           csvd_lsame, csvd_ilaenv
!     ..                                                                
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_CLARFB, CSVD_CLARFT, CSVD_CUNM2R, CSVD_XERBLA
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN                                       
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      INFO = 0                                                          
      LEFT = csvd_lsame( SIDE, 'L' )                                         
      NOTRAN = csvd_lsame( TRANS, 'N' )                                      
      LQUERY = ( LWORK.EQ.-1 )                                          
!                                                                       
!     NQ is the order of Q and NW is the minimum dimension of WORK      
!                                                                       
      IF( LEFT ) THEN                                                   
         NQ = M                                                         
         NW = N                                                         
      ELSE                                                              
         NQ = N                                                         
         NW = M                                                         
      END IF                                                            
      IF( .NOT.LEFT .AND. .NOT.csvd_lsame( SIDE, 'R' ) ) THEN                
         INFO = -1                                                      
      ELSE IF( .NOT.NOTRAN .AND. .NOT.csvd_lsame( TRANS, 'C' ) ) THEN        
         INFO = -2                                                      
      ELSE IF( M.LT.0 ) THEN                                            
         INFO = -3                                                      
      ELSE IF( N.LT.0 ) THEN                                            
         INFO = -4                                                      
      ELSE IF( K.LT.0 .OR. K.GT.NQ ) THEN                               
         INFO = -5                                                      
      ELSE IF( LDA.LT.MAX( 1, NQ ) ) THEN                               
         INFO = -7                                                      
      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN                                
         INFO = -10                                                     
      ELSE IF( LWORK.LT.MAX( 1, NW ) .AND. .NOT.LQUERY ) THEN           
         INFO = -12                                                     
      END IF                                                            
!                                                                       
      IF( INFO.EQ.0 ) THEN                                              
!                                                                       
!        Determine the block size.  NB may be at most NBMAX, where NBMAX
!        is used to define the local array T.                           
!                                                                       
         NB = MIN( NBMAX, csvd_ilaenv( 1, 'CSVD_CUNMQR', SIDE // TRANS, M, N,K,&
              -1 ) )                                                    
         LWKOPT = MAX( 1, NW )*NB                                       
         WORK( 1 ) = LWKOPT                                             
      END IF                                                            
!                                                                       
      IF( INFO.NE.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_CUNMQR', -INFO )
         RETURN                                                         
      ELSE IF( LQUERY ) THEN                                            
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( M.EQ.0 .OR. N.EQ.0 .OR. K.EQ.0 ) THEN                         
         WORK( 1 ) = 1                                                  
         RETURN                                                         
      END IF                                                            
!                                                                       
      NBMIN = 2                                                         
      LDWORK = NW                                                       
      IF( NB.GT.1 .AND. NB.LT.K ) THEN                                  
         IWS = NW*NB                                                    
         IF( LWORK.LT.IWS ) THEN                                        
            NB = LWORK / LDWORK                                         
            NBMIN = MAX( 2, csvd_ilaenv(2,'CSVD_CUNMQR',SIDE // TRANS, M, N,K,&
                    -1 ) )                                              
         END IF
      ELSE                                                              
         IWS = NW                                                       
      END IF                                                            
!                                                                       
      IF( NB.LT.NBMIN .OR. NB.GE.K ) THEN                               
!                                                                       
!        Use unblocked code                                             
!                                                                       
         CALL CSVD_CUNM2R( SIDE, TRANS, M, N, K, A, LDA, TAU, C, LDC, WORK,    &
                      IINFO )                                           
      ELSE                                                              
!                                                                       
!        Use blocked code                                               
!                                                                       
         IF( ( LEFT .AND. .NOT.NOTRAN ) .OR.                              &
             ( .NOT.LEFT .AND. NOTRAN ) ) THEN                          
            I1 = 1                                                      
            I2 = K                                                      
            I3 = NB                                                     
         ELSE                                                           
            I1 = ( ( K-1 ) / NB )*NB + 1                                
            I2 = 1                                                      
            I3 = -NB                                                    
         END IF                                                         
!                                                                       
         IF( LEFT ) THEN                                                
            NI = N                                                      
            JC = 1                                                      
         ELSE                                                           
            MI = M                                                      
            IC = 1                                                      
         END IF                                                         
!                                                                       
         DO 10 I = I1, I2, I3                                           
            IB = MIN( NB, K-I+1 )                                       
!                                                                       
!           Form the triangular factor of the block reflector           
!           H = H(i) H(i+1) . . . H(i+ib-1)                             
!                                                                       
            CALL CSVD_CLARFT( 'Forward', 'Columnwise', NQ-I+1, IB, A( I, I ),  &
                         LDA, TAU( I ), T, LDT )                        
            IF( LEFT ) THEN                                             
!                                                                       
!              H or H' is applied to C(i:m,1:n)                         
!                                                                       
               MI = M - I + 1                                           
               IC = I                                                   
            ELSE                                                        
!                                                                       
!              H or H' is applied to C(1:m,i:n)                         
!                                                                       
               NI = N - I + 1                                           
               JC = I                                                   
            END IF                                                      
!                                                                       
!           Apply H or H'                                               
!                                                                       
            CALL CSVD_CLARFB( SIDE, TRANS, 'Forward', 'Columnwise', MI, NI,    &
                         IB, A( I, I ), LDA, T, LDT, C( IC, JC ), LDC,    &
                         WORK, LDWORK )                                 
   10    CONTINUE                                                       
      END IF                                                            
      WORK( 1 ) = LWKOPT                                                
      RETURN                                                            
!                                                                       
!     End of CSVD_CUNMQR                                                     
!                                                                       
      END SUBROUTINE CSVD_CUNMQR
                                                            
      SUBROUTINE CSVD_SLADIV( A, B, C, D, P, Q )                             
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     October 31, 1992                                                  
!                                                                       
!     .. Scalar Arguments ..                                            
      REAL               A, B, C, D, P, Q                               
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_SLADIV performs complex division in  real arithmetic                 
!                                                                       
!                        a + i*b                                        
!             p + i*q = ---------                                       
!                        c + i*d                                        
!                                                                       
!  The algorithm is due to Robert L. Smith and can be found             
!  in D. Knuth, The art of Computer Programming, Vol.2, p.195           
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  A       (input) REAL                                                 
!  B       (input) REAL                                                 
!  C       (input) REAL                                                 
!  D       (input) REAL                                                 
!          The scalars a, b, c, and d in the above expression.          
!                                                                       
!  P       (output) REAL                                                
!  Q       (output) REAL                                                
!          The scalars p and q in the above expression.                 
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      REAL               E, F                                           
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS                                            
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( ABS( D ).LT.ABS( C ) ) THEN                                   
         E = D / C                                                      
         F = C + D*E                                                    
         P = ( A+B*E ) / F                                              
         Q = ( B-A*E ) / F                                              
      ELSE                                                              
         E = C / D                                                      
         F = D + C*E                                                    
         P = ( B+A*E ) / F                                              
         Q = ( -A+B*E ) / F                                             
      END IF                                                            
!                                                                       
      RETURN                                                            
!                                                                       
!     End of CSVD_SLADIV                                                     
!                                                                       
      END SUBROUTINE CSVD_SLADIV
                                                              
      REAL             FUNCTION csvd_slapy3( X, Y, Z )                       
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     October 31, 1992                                                  
!                                                                       
!     .. Scalar Arguments ..                                            
      REAL               X, Y, Z                                        
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  csvd_slapy3 returns sqrt(x**2+y**2+z**2), taking care not to cause        
!  unnecessary overflow.                                                
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  X       (input) REAL                                                 
!  Y       (input) REAL                                                 
!  Z       (input) REAL                                                 
!          X, Y and Z specify the values x, y and z.                    
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO                                           
      PARAMETER          ( ZERO = 0.0E0 )                               
!     ..                                                                
!     .. Local Scalars ..                                               
      REAL               W, XABS, YABS, ZABS                            
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, SQRT                                 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      XABS = ABS( X )                                                   
      YABS = ABS( Y )                                                   
      ZABS = ABS( Z )                                                   
      W = MAX( XABS, YABS, ZABS )                                       
      IF( W.EQ.ZERO ) THEN                                              
         csvd_slapy3 = ZERO                                                  
      ELSE                                                              
         csvd_slapy3 = W*SQRT( ( XABS / W )**2+( YABS / W )**2+     &
                  ( ZABS / W )**2 )                                     
      END IF                                                            
      RETURN                                                            
!                                                                       
!     End of csvd_slapy3                                                     
!                                                                       
      END FUNCTION csvd_slapy3
                                                             
      SUBROUTINE CSVD_SLARTG( F, G, CS, SN, R )                              
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     September 30, 1994                                                
!                                                                       
!     .. Scalar Arguments ..                                            
      REAL               CS, F, G, R, SN                                
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_SLARTG generate a plane rotation so that                             
!                                                                       
!     [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.       
!     [ -SN  CS  ]     [ G ]     [ 0 ]                                  
!                                                                       
!  This is a slower, more accurate version of the BLAS1 routine SROTG,  
!  with the following other differences:                                
!     F and G are unchanged on return.                                  
!     If G=0, then CS=1 and SN=0.                                       
!     If F=0 and (G .ne. 0), then CS=0 and SN=1 without doing any       
!        floating point operations (saves work in SBDSQR when           
!        there are zeros on the diagonal).                              
!                                                                       
!  If F exceeds G in magnitude, CS will be positive.                    
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  F       (input) REAL                                                 
!          The first component of vector to be rotated.                 
!                                                                       
!  G       (input) REAL                                                 
!          The second component of vector to be rotated.                
!                                                                       
!  CS      (output) REAL                                                
!          The cosine of the rotation.                                  
!                                                                       
!  SN      (output) REAL                                                
!          The sine of the rotation.                                    
!                                                                       
!  R       (output) REAL                                                
!          The nonzero component of the rotated vector.                 
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO                                           
      PARAMETER          ( ZERO = 0.0E0 )                               
      REAL               ONE                                            
      PARAMETER          ( ONE = 1.0E0 )                                
      REAL               TWO                                            
      PARAMETER          ( TWO = 2.0E0 )                                
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            FIRST                                          
      INTEGER            COUNT, I                                       
      REAL               EPS, F1, G1, SAFMIN, SAFMN2, SAFMX2, SCALE     
!     ..                                                                
!     .. External Functions ..                                          
!      REAL               csvd_slamch                                         
!      EXTERNAL           csvd_slamch                                         
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, INT, LOG, MAX, SQRT                       
!     ..                                                                
!     .. Save statement ..                                              
      SAVE               FIRST, SAFMX2, SAFMIN, SAFMN2                  
!     ..                                                                
!     .. Data statements ..                                             
      DATA               FIRST / .TRUE. /                               
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( FIRST ) THEN                                                  
         FIRST = .FALSE.                                                
         SAFMIN = csvd_slamch( 'S' )                                         
         EPS = csvd_slamch( 'E' )                                            
         SAFMN2 = csvd_slamch( 'B' )**INT( LOG( SAFMIN / EPS ) /    &
                  LOG( csvd_slamch( 'B' ) ) / TWO )                          
         SAFMX2 = ONE / SAFMN2                                          
      END IF                                                            
      IF( G.EQ.ZERO ) THEN                                              
         CS = ONE                                                       
         SN = ZERO                                                      
         R = F                                                          
      ELSE IF( F.EQ.ZERO ) THEN                                         
         CS = ZERO                                                      
         SN = ONE                                                       
         R = G                                                          
      ELSE                                                              
         F1 = F                                                         
         G1 = G                                                         
         SCALE = MAX( ABS( F1 ), ABS( G1 ) )                            
         IF( SCALE.GE.SAFMX2 ) THEN                                     
            COUNT = 0                                                   
   10       CONTINUE                                                    
            COUNT = COUNT + 1                                           
            F1 = F1*SAFMN2                                              
            G1 = G1*SAFMN2                                              
            SCALE = MAX( ABS( F1 ), ABS( G1 ) )                         
            IF( SCALE.GE.SAFMX2 )                                  &
               GO TO 10                                                 
            R = SQRT( F1**2+G1**2 )                                     
            CS = F1 / R                                                 
            SN = G1 / R                                                 
            DO 20 I = 1, COUNT                                          
               R = R*SAFMX2                                             
   20       CONTINUE                                                    
         ELSE IF( SCALE.LE.SAFMN2 ) THEN                                
            COUNT = 0                                                   
   30       CONTINUE                                                    
            COUNT = COUNT + 1                                           
            F1 = F1*SAFMX2                                              
            G1 = G1*SAFMX2                                              
            SCALE = MAX( ABS( F1 ), ABS( G1 ) )                         
            IF( SCALE.LE.SAFMN2 )                                  &
               GO TO 30                                                 
            R = SQRT( F1**2+G1**2 )                                     
            CS = F1 / R                                                 
            SN = G1 / R                                                 
            DO 40 I = 1, COUNT                                          
               R = R*SAFMN2                                             
   40       CONTINUE                                                    
         ELSE                                                           
            R = SQRT( F1**2+G1**2 )                                     
            CS = F1 / R                                                 
            SN = G1 / R                                                 
         END IF                                                         
         IF( ABS( F ).GT.ABS( G ) .AND. CS.LT.ZERO ) THEN               
            CS = -CS                                                    
            SN = -SN                                                    
            R = -R                                                      
         END IF                                                         
      END IF                                                            
      RETURN                                                            
!                                                                       
!     End of CSVD_SLARTG                                                     
!                                                                       
      END SUBROUTINE CSVD_SLARTG
                                                              
      SUBROUTINE CSVD_SLAS2( F, G, H, SSMIN, SSMAX )                         
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     September 30, 1994                                                
!                                                                       
!     .. Scalar Arguments ..                                            
      REAL               F, G, H, SSMAX, SSMIN                          
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_SLAS2  computes the singular values of the 2-by-2 matrix             
!     [  F   G  ]                                                       
!     [  0   H  ].                                                      
!  On return, SSMIN is the smaller singular value and SSMAX is the      
!  larger singular value.                                               
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  F       (input) REAL                                                 
!          The (1,1) element of the 2-by-2 matrix.                      
!                                                                       
!  G       (input) REAL                                                 
!          The (1,2) element of the 2-by-2 matrix.                      
!                                                                       
!  H       (input) REAL                                                 
!          The (2,2) element of the 2-by-2 matrix.                      
!                                                                       
!  SSMIN   (output) REAL                                                
!          The smaller singular value.                                  
!                                                                       
!  SSMAX   (output) REAL                                                
!          The larger singular value.                                   
!                                                                       
!  Further Details                                                      
!  ===============                                                      
!                                                                       
!  Barring over/underflow, all output quantities are correct to within  
!  a few units in the last place (ulps), even in the absence of a guard 
!  digit in addition/subtraction.                                       
!                                                                       
!  In IEEE arithmetic, the code works correctly if one matrix element is
!  infinite.                                                            
!                                                                       
!  Overflow will not occur unless the largest singular value itself     
!  overflows, or is within a few ulps of overflow. (On machines with    
!  partial overflow, like the Cray, overflow may occur if the largest   
!  singular value is within a factor of 2 of overflow.)                 
!                                                                       
!  Underflow is harmless if underflow is gradual. Otherwise, results    
!  may correspond to a matrix modified by perturbations of size near    
!  the underflow threshold.                                             
!                                                                       
!  ==================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO                                           
      PARAMETER          ( ZERO = 0.0E0 )                               
      REAL               ONE                                            
      PARAMETER          ( ONE = 1.0E0 )                                
      REAL               TWO                                            
      PARAMETER          ( TWO = 2.0E0 )                                
!     ..                                                                
!     .. Local Scalars ..                                               
      REAL               AS, AT, AU, C, FA, FHMN, FHMX, GA, HA          
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, MIN, SQRT                            
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      FA = ABS( F )                                                     
      GA = ABS( G )                                                     
      HA = ABS( H )                                                     
      FHMN = MIN( FA, HA )                                              
      FHMX = MAX( FA, HA )                                              
      IF( FHMN.EQ.ZERO ) THEN                                           
         SSMIN = ZERO                                                   
         IF( FHMX.EQ.ZERO ) THEN                                        
            SSMAX = GA                                                  
         ELSE                                                           
            SSMAX = MAX( FHMX, GA )*SQRT( ONE+                            &
                    ( MIN( FHMX, GA ) / MAX( FHMX, GA ) )**2 )          
         END IF                                                         
      ELSE                                                              
         IF( GA.LT.FHMX ) THEN                                          
            AS = ONE + FHMN / FHMX                                      
            AT = ( FHMX-FHMN ) / FHMX                                   
            AU = ( GA / FHMX )**2                                       
            C = TWO / ( SQRT( AS*AS+AU )+SQRT( AT*AT+AU ) )             
            SSMIN = FHMN*C                                              
            SSMAX = FHMX / C                                            
         ELSE                                                           
            AU = FHMX / GA                                              
            IF( AU.EQ.ZERO ) THEN                                       
!                                                                       
!              Avoid possible harmful underflow if exponent range       
!              asymmetric (true SSMIN may not underflow even if         
!              AU underflows)                                           
!                                                                       
               SSMIN = ( FHMN*FHMX ) / GA                               
               SSMAX = GA                                               
            ELSE                                                        
               AS = ONE + FHMN / FHMX                                   
               AT = ( FHMX-FHMN ) / FHMX                                
               C = ONE / ( SQRT( ONE+( AS*AU )**2 )+                      &
                   SQRT( ONE+( AT*AU )**2 ) )                           
               SSMIN = ( FHMN*C )*AU                                    
               SSMIN = SSMIN + SSMIN                                    
               SSMAX = GA / ( C+C )                                     
            END IF                                                      
         END IF                                                         
      END IF                                                            
      RETURN                                                            
!                                                                       
!     End of CSVD_SLAS2                                                      
!                                                                       
      END SUBROUTINE CSVD_SLAS2
                                                              
      SUBROUTINE CSVD_SLASCL( TYPE, KL, KU, CFROM, CTO, M, N, A, LDA, INFO ) 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     February 29, 1992                                                 
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          TYPE                                           
      INTEGER            INFO, KL, KU, LDA, M, N                        
      REAL               CFROM, CTO                                     
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               A( LDA, * )                                    
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_SLASCL multiplies the M by N real matrix A by the real scalar        
!  CTO/CFROM.  This is done without over/underflow as long as the final 
!  result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that 
!  A may be full, upper triangular, lower triangular, upper Hessenberg, 
!  or banded.                                                           
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  TYPE    (input) CHARACTER*1                                          
!          TYPE indices the storage type of the input matrix.           
!          = 'G':  A is a full matrix.                                  
!          = 'L':  A is a lower triangular matrix.                      
!          = 'U':  A is an upper triangular matrix.                     
!          = 'H':  A is an upper Hessenberg matrix.                     
!          = 'B':  A is a symmetric band matrix with lower bandwidth KL 
!                  and upper bandwidth KU and with the only the lower   
!                  half stored.                                         
!          = 'Q':  A is a symmetric band matrix with lower bandwidth KL 
!                  and upper bandwidth KU and with the only the upper   
!                  half stored.                                         
!          = 'Z':  A is a band matrix with lower bandwidth KL and upper 
!                  bandwidth KU.                                        
!                                                                       
!  KL      (input) INTEGER                                              
!          The lower bandwidth of A.  Referenced only if TYPE = 'B',    
!          'Q' or 'Z'.                                                  
!                                                                       
!  KU      (input) INTEGER                                              
!          The upper bandwidth of A.  Referenced only if TYPE = 'B',    
!          'Q' or 'Z'.                                                  
!                                                                       
!  CFROM   (input) REAL                                                 
!  CTO     (input) REAL                                                 
!          The matrix A is multiplied by CTO/CFROM. A(I,J) is computed  
!          without over/underflow if the final result CTO*A(I,J)/CFROM  
!          can be represented without over/underflow.  CFROM must be    
!          nonzero.                                                     
!                                                                       
!  M       (input) INTEGER                                              
!          The number of rows of the matrix A.  M &gt;= 0.              
!                                                                       
!  N       (input) INTEGER                                              
!          The number of columns of the matrix A.  N &gt;= 0.           
!                                                                       
!  A       (input/output) REAL array, dimension (LDA,M)                 
!          The matrix to be multiplied by CTO/CFROM.  See TYPE for the  
!          storage type.                                                
!                                                                       
!  LDA     (input) INTEGER                                              
!          The leading dimension of the array A.  LDA &gt;= max(1,M).   
!                                                                       
!  INFO    (output) INTEGER                                             
!          0  - successful exit                                         
!          &lt;0 - if INFO = -i, the i-th argument had an illegal value.
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO, ONE                                      
      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0 )                  
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            DONE                                           
      INTEGER            I, ITYPE, J, K1, K2, K3, K4                    
      REAL               BIGNUM, CFROM1, CFROMC, CTO1, CTOC, MUL, SMLNUM
!     ..                                                                
!     .. External Functions ..                                          
!      LOGICAL            csvd_lsame                                          
!      REAL               csvd_slamch                                         
!      EXTERNAL           csvd_lsame, csvd_slamch
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, MIN                                  
!     ..                                                                
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_XERBLA                                         
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments                                          
!                                                                       
      INFO = 0                                                          
!                                                                       
      IF( csvd_lsame( TYPE, 'G' ) ) THEN                                     
         ITYPE = 0                                                      
      ELSE IF( csvd_lsame( TYPE, 'L' ) ) THEN                                
         ITYPE = 1                                                      
      ELSE IF( csvd_lsame( TYPE, 'U' ) ) THEN                                
         ITYPE = 2                                                      
      ELSE IF( csvd_lsame( TYPE, 'H' ) ) THEN                                
         ITYPE = 3                                                      
      ELSE IF( csvd_lsame( TYPE, 'B' ) ) THEN                                
         ITYPE = 4                                                      
      ELSE IF( csvd_lsame( TYPE, 'Q' ) ) THEN                                
         ITYPE = 5                                                      
      ELSE IF( csvd_lsame( TYPE, 'Z' ) ) THEN                                
         ITYPE = 6                                                      
      ELSE                                                              
         ITYPE = -1                                                     
      END IF                                                            
!                                                                       
      IF( ITYPE.EQ.-1 ) THEN                                            
         INFO = -1                                                      
      ELSE IF( CFROM.EQ.ZERO ) THEN                                     
         INFO = -4                                                      
      ELSE IF( M.LT.0 ) THEN                                            
         INFO = -6                                                      
      ELSE IF( N.LT.0 .OR. ( ITYPE.EQ.4 .AND. N.NE.M ) .OR.               &
               ( ITYPE.EQ.5 .AND. N.NE.M ) ) THEN                       
         INFO = -7                                                      
      ELSE IF( ITYPE.LE.3 .AND. LDA.LT.MAX( 1, M ) ) THEN               
         INFO = -9                                                      
      ELSE IF( ITYPE.GE.4 ) THEN                                        
         IF( KL.LT.0 .OR. KL.GT.MAX( M-1, 0 ) ) THEN                    
            INFO = -2                                                   
         ELSE IF( KU.LT.0 .OR. KU.GT.MAX( N-1, 0 ) .OR.                   &
                  ( ( ITYPE.EQ.4 .OR. ITYPE.EQ.5 ) .AND. KL.NE.KU ) )     &
                   THEN                                                 
            INFO = -3                                                   
         ELSE IF( ( ITYPE.EQ.4 .AND. LDA.LT.KL+1 ) .OR.                   &
                  ( ITYPE.EQ.5 .AND. LDA.LT.KU+1 ) .OR.                   &
                  ( ITYPE.EQ.6 .AND. LDA.LT.2*KL+KU+1 ) ) THEN          
            INFO = -9                                                   
         END IF                                                         
      END IF                                                            
!                                                                       
      IF( INFO.NE.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_SLASCL', -INFO )
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.EQ.0 .OR. M.EQ.0 )                                            &
         RETURN                                                         
!                                                                       
!     Get machine parameters                                            
!                                                                       
      SMLNUM = csvd_slamch( 'S' )                                            
      BIGNUM = ONE / SMLNUM                                             
!                                                                       
      CFROMC = CFROM                                                    
      CTOC = CTO                                                        
!                                                                       
   10 CONTINUE                                                          
      CFROM1 = CFROMC*SMLNUM                                            
      CTO1 = CTOC / BIGNUM                                              
      IF( ABS( CFROM1 ).GT.ABS( CTOC ) .AND. CTOC.NE.ZERO ) THEN        
         MUL = SMLNUM                                                   
         DONE = .FALSE.                                                 
         CFROMC = CFROM1                                                
      ELSE IF( ABS( CTO1 ).GT.ABS( CFROMC ) ) THEN                      
         MUL = BIGNUM                                                   
         DONE = .FALSE.                                                 
         CTOC = CTO1                                                    
      ELSE                                                              
         MUL = CTOC / CFROMC                                            
         DONE = .TRUE.                                                  
      END IF                                                            
!                                                                       
      IF( ITYPE.EQ.0 ) THEN                                             
!                                                                       
!        Full matrix                                                    
!                                                                       
         DO 30 J = 1, N                                                 
            DO 20 I = 1, M                                              
               A( I, J ) = A( I, J )*MUL                                
   20       CONTINUE                                                    
   30    CONTINUE                                                       
!                                                                       
      ELSE IF( ITYPE.EQ.1 ) THEN                                        
!                                                                       
!        Lower triangular matrix                                        
!                                                                       
         DO 50 J = 1, N                                                 
            DO 40 I = J, M                                              
               A( I, J ) = A( I, J )*MUL                                
   40       CONTINUE                                                    
   50    CONTINUE                                                       
!                                                                       
      ELSE IF( ITYPE.EQ.2 ) THEN                                        
!                                                                       
!        Upper triangular matrix                                        
!                                                                       
         DO 70 J = 1, N                                                 
            DO 60 I = 1, MIN( J, M )                                    
               A( I, J ) = A( I, J )*MUL                                
   60       CONTINUE                                                    
   70    CONTINUE                                                       
!                                                                       
      ELSE IF( ITYPE.EQ.3 ) THEN                                        
!                                                                       
!        Upper Hessenberg matrix                                        
!                                                                       
         DO 90 J = 1, N                                                 
            DO 80 I = 1, MIN( J+1, M )                                  
               A( I, J ) = A( I, J )*MUL                                
   80       CONTINUE                                                    
   90    CONTINUE                                                       
!                                                                       
      ELSE IF( ITYPE.EQ.4 ) THEN                                        
!                                                                       
!        Lower half of a symmetric band matrix                          
!                                                                       
         K3 = KL + 1                                                    
         K4 = N + 1                                                     
         DO 110 J = 1, N                                                
            DO 100 I = 1, MIN( K3, K4-J )                               
               A( I, J ) = A( I, J )*MUL                                
  100       CONTINUE                                                    
  110    CONTINUE                                                       
!                                                                       
      ELSE IF( ITYPE.EQ.5 ) THEN                                        
!                                                                       
!        Upper half of a symmetric band matrix                          
!                                                                       
         K1 = KU + 2                                                    
         K3 = KU + 1                                                    
         DO 130 J = 1, N                                                
            DO 120 I = MAX( K1-J, 1 ), K3                               
               A( I, J ) = A( I, J )*MUL                                
  120       CONTINUE                                                    
  130    CONTINUE                                                       
!                                                                       
      ELSE IF( ITYPE.EQ.6 ) THEN                                        
!                                                                       
!        Band matrix                                                    
!                                                                       
         K1 = KL + KU + 2                                               
         K2 = KL + 1                                                    
         K3 = 2*KL + KU + 1                                             
         K4 = KL + KU + 1 + M                                           
         DO 150 J = 1, N                                                
            DO 140 I = MAX( K1-J, K2 ), MIN( K3, K4-J )                 
               A( I, J ) = A( I, J )*MUL                                
  140       CONTINUE                                                    
  150    CONTINUE                                                       
!                                                                       
      END IF                                                            
!                                                                       
      IF( .NOT.DONE )                                                     &
         GO TO 10                                                       
!                                                                       
      RETURN                                                            
!                                                                       
!     End of CSVD_SLASCL                                                     
!                                                                       
      END SUBROUTINE CSVD_SLASCL
                                                              
      SUBROUTINE CSVD_SLASQ1( N, D, E, WORK, INFO )                          
!                                                                       
!  -- LAPACK routine (version 3.0) --                                   
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     October 31, 1999                                                  
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, N                                        
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               D( * ), E( * ), WORK( * )                      
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_SLASQ1 computes the singular values of a real N-by-N bidiagonal      
!  matrix with diagonal D and off-diagonal E. The singular values       
!  are computed to high relative accuracy, in the absence of            
!  denormalization, underflow and overflow. The algorithm was first     
!  presented in                                                         
!                                                                       
!  "Accurate singular values and differential qd algorithms" by K. V.   
!  Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230,
!  1994,                                                                
!                                                                       
!  and the present implementation is described in "An implementation of 
!  the dqds Algorithm (Positive Case)", LAPACK Working Note.            
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  N     (input) INTEGER                                                
!        The number of rows and columns in the matrix. N &gt;= 0.       
!                                                                       
!  D     (input/output) REAL array, dimension (N)                       
!        On entry, D contains the diagonal elements of the              
!        bidiagonal matrix whose SVD is desired. On normal exit,        
!        D contains the singular values in decreasing order.            
!                                                                       
!  E     (input/output) REAL array, dimension (N)                       
!        On entry, elements E(1:N-1) contain the off-diagonal elements  
!        of the bidiagonal matrix whose SVD is desired.                 
!        On exit, E is overwritten.                                     
!                                                                       
!  WORK  (workspace) REAL array, dimension (4*N)                        
!                                                                       
!  INFO  (output) INTEGER                                               
!        = 0: successful exit                                           
!        &lt; 0: if INFO = -i, the i-th argument had an illegal value   
!        &gt; 0: the algorithm failed                                   
!             = 1, a split was marked by a positive value in E          
!             = 2, current block of Z not diagonalized after 30*N       
!                  iterations (in inner while loop)                     
!             = 3, termination criterion of outer while loop not met    
!                  (program created more than N unreduced blocks)       
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO                                           
      PARAMETER          ( ZERO = 0.0E0 )                               
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I, IINFO                                       
      REAL               EPS, SCALE, SAFMIN, SIGMN, SIGMX               
!     ..                                                                
!     .. External Subroutines ..                                        
!    EXTERNAL           CSVD_SLAS2, CSVD_SLASQ2, CSVD_SLASRT, CSVD_XERBLA
!     ..                                                                
!     .. External Functions ..                                          
!      REAL               csvd_slamch                                         
!      EXTERNAL           csvd_slamch                                         
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, SQRT                                 
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      INFO = 0                                                          
      IF( N.LT.0 ) THEN                                                 
         INFO = -2                                                      
         CALL CSVD_XERBLA( 'CSVD_SLASQ1', -INFO )
         RETURN                                                         
      ELSE IF( N.EQ.0 ) THEN                                            
         RETURN                                                         
      ELSE IF( N.EQ.1 ) THEN                                            
         D( 1 ) = ABS( D( 1 ) )                                         
         RETURN                                                         
      ELSE IF( N.EQ.2 ) THEN                                            
         CALL CSVD_SLAS2( D( 1 ), E( 1 ), D( 2 ), SIGMN, SIGMX )             
         D( 1 ) = SIGMX                                                 
         D( 2 ) = SIGMN                                                 
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Estimate the largest singular value.                              
!                                                                       
      SIGMX = ZERO                                                      
      DO 10 I = 1, N - 1                                                
         D( I ) = ABS( D( I ) )                                         
         SIGMX = MAX( SIGMX, ABS( E( I ) ) )                            
   10 CONTINUE                                                          
      D( N ) = ABS( D( N ) )                                            
!                                                                       
!     Early return if SIGMX is zero (matrix is already diagonal).       
!                                                                       
      IF( SIGMX.EQ.ZERO ) THEN                                          
         CALL CSVD_SLASRT( 'D', N, D, IINFO )                                
         RETURN                                                         
      END IF                                                            
!                                                                       
      DO 20 I = 1, N                                                    
         SIGMX = MAX( SIGMX, D( I ) )                                   
   20 CONTINUE                                                          
!                                                                       
!     Copy D and E into WORK (in the Z format) and scale (squaring the  
!     input data makes scaling by a power of the radix pointless).      
!                                                                       
      EPS = csvd_slamch( 'Precision' )                                       
      SAFMIN = csvd_slamch( 'Safe minimum' )                                 
      SCALE = SQRT( EPS / SAFMIN )                                      
      CALL CSVD_scopy( N, D, 1, WORK( 1 ), 2 )                               
      CALL CSVD_scopy( N-1, E, 1, WORK( 2 ), 2 )                             
      CALL CSVD_SLASCL( 'G', 0, 0, SIGMX, SCALE, 2*N-1, 1, WORK, 2*N-1,        &
                   IINFO )                                              
!                                                                       
!     Compute the q's and e's.                                          
!                                                                       
      DO 30 I = 1, 2*N - 1                                              
         WORK( I ) = WORK( I )**2                                       
   30 CONTINUE                                                          
      WORK( 2*N ) = ZERO                                                
!                                                                       
      CALL CSVD_SLASQ2( N, WORK, INFO )                                      
!                                                                       
      IF( INFO.EQ.0 ) THEN                                              
         DO 40 I = 1, N                                                 
            D( I ) = SQRT( WORK( I ) )                                  
   40    CONTINUE                                                       
         CALL CSVD_SLASCL( 'G', 0, 0, SCALE, SIGMX, N, 1, D, N, IINFO )      
      END IF                                                            
!                                                                       
      RETURN                                                            
!                                                                       
!     End of CSVD_SLASQ1                                                     
!                                                                       
      END  SUBROUTINE CSVD_SLASQ1
                                                             
      SUBROUTINE CSVD_SLASQ2( N, Z, INFO )                                   
!                                                                       
!  -- LAPACK routine (version 3.0) --                                   
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     October 31, 1999                                                  
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            INFO, N                                        
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               Z( * )                                         
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_SLASQ2 computes all the eigenvalues of the symmetric positive        
!  definite tridiagonal matrix associated with the qd array Z to high   
!  relative accuracy are computed to high relative accuracy, in the     
!  absence of denormalization, underflow and overflow.                  
!                                                                       
!  To see the relation of Z to the tridiagonal matrix, let L be a       
!  unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and      
!  let U be an upper bidiagonal matrix with 1's above and diagonal      
!  Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the          
!  symmetric tridiagonal to which it is similar.                        
!                                                                       
!  Note : CSVD_SLASQ2 defines a logical variable, IEEE, which is true        
!  on machines which follow ieee-754 floating-point standard in their   
!  handling of infinities and NaNs, and false otherwise. This variable  
!  is passed to CSVD_SLASQ3.                                                 
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  N     (input) INTEGER                                                
!        The number of rows and columns in the matrix. N &gt;= 0.       
!                                                                       
!  Z     (workspace) REAL array, dimension ( 4*N )                      
!        On entry Z holds the qd array. On exit, entries 1 to N hold    
!        the eigenvalues in decreasing order, Z( 2*N+1 ) holds the      
!        trace, and Z( 2*N+2 ) holds the sum of the eigenvalues. If     
!        N &gt; 2, then Z( 2*N+3 ) holds the iteration count, Z( 2*N+4 )
!        holds NDIVS/NIN^2, and Z( 2*N+5 ) holds the percentage of      
!        shifts that failed.                                            
!                                                                       
!  INFO  (output) INTEGER                                               
!        = 0: successful exit                                           
!        &lt; 0: if the i-th argument is a scalar and had an illegal    
!             value, then INFO = -i, if the i-th argument is an         
!             array and the j-entry had an illegal value, then          
!             INFO = -(i*100+j)                                         
!        &gt; 0: the algorithm failed                                   
!              = 1, a split was marked by a positive value in E         
!              = 2, current block of Z not diagonalized after 30*N      
!                   iterations (in inner while loop)                    
!              = 3, termination criterion of outer while loop not met   
!                   (program created more than N unreduced blocks)      
!                                                                       
!  Further Details                                                      
!  ===============                                                      
!  Local Variables: I0:N0 defines a current unreduced segment of Z.     
!  The shifts are accumulated in SIGMA. Iteration count is in ITER.     
!  Ping-pong is controlled by PP (alternates between 0 and 1).          
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               CBIAS                                          
      PARAMETER          ( CBIAS = 1.50E0 )                             
      REAL               ZERO, HALF, ONE, TWO, FOUR, HUNDRD             
      PARAMETER          ( ZERO = 0.0E0, HALF = 0.5E0, ONE = 1.0E0,       &
                           TWO = 2.0E0, FOUR = 4.0E0, HUNDRD = 100.0E0 )
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            IEEE                                           
      INTEGER            I0, I4, IINFO, IPN4, ITER, IWHILA, IWHILB, K,    &
                         N0, NBIG, NDIV, NFAIL, PP, SPLT                
      REAL               D, DESIG, DMIN, E, EMAX, EMIN, EPS, OLDEMN,      &
                         QMAX, QMIN, S, SAFMIN, SIGMA, T, TEMP, TOL,      &
                         TOL2, TRACE, ZMAX                              
!     ..                                                                
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_SLASQ3, CSVD_SLASRT, CSVD_XERBLA 
!     ..                                                                
!     .. External Functions ..                                          
!      INTEGER            csvd_ilaenv                                         
!      REAL               csvd_slamch 
!      EXTERNAL           csvd_ilaenv, csvd_slamch
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN, REAL, SQRT                           
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input arguments.                                         
!     (in case CSVD_SLASQ2 is not called by CSVD_SLASQ1)
!                                                                       
      INFO = 0                                                          
      EPS = csvd_slamch( 'Precision' )                                       
      SAFMIN = csvd_slamch( 'Safe minimum' )                                 
      TOL = EPS*HUNDRD                                                  
      TOL2 = TOL**2                                                     
!                                                                       
      IF( N.LT.0 ) THEN                                                 
         INFO = -1                                                      
         CALL CSVD_XERBLA( 'CSVD_SLASQ2', 1 )
         RETURN                                                         
      ELSE IF( N.EQ.0 ) THEN                                            
         RETURN                                                         
      ELSE IF( N.EQ.1 ) THEN                                            
!                                                                       
!        1-by-1 case.                                                   
!                                                                       
         IF( Z( 1 ).LT.ZERO ) THEN                                      
            INFO = -201                                                 
            CALL CSVD_XERBLA( 'CSVD_SLASQ2', 2 )
         END IF                                                         
         RETURN                                                         
      ELSE IF( N.EQ.2 ) THEN                                            
!                                                                       
!        2-by-2 case.                                                   
!                                                                       
         IF( Z( 2 ).LT.ZERO .OR. Z( 3 ).LT.ZERO ) THEN                  
            INFO = -2                                                   
            CALL CSVD_XERBLA( 'CSVD_SLASQ2', 2 )
            RETURN                                                      
         ELSE IF( Z( 3 ).GT.Z( 1 ) ) THEN                               
            D = Z( 3 )                                                  
            Z( 3 ) = Z( 1 )                                             
            Z( 1 ) = D                                                  
         END IF                                                         
         Z( 5 ) = Z( 1 ) + Z( 2 ) + Z( 3 )                              
         IF( Z( 2 ).GT.Z( 3 )*TOL2 ) THEN                               
            T = HALF*( ( Z( 1 )-Z( 3 ) )+Z( 2 ) )                       
            S = Z( 3 )*( Z( 2 ) / T )                                   
            IF( S.LE.T ) THEN                                           
               S = Z( 3 )*( Z( 2 ) / ( T*( ONE+SQRT( ONE+S / T ) ) ) )  
            ELSE                                                        
               S = Z( 3 )*( Z( 2 ) / ( T+SQRT( T )*SQRT( T+S ) ) )      
            END IF                                                      
            T = Z( 1 ) + ( S+Z( 2 ) )                                   
            Z( 3 ) = Z( 3 )*( Z( 1 ) / T )                              
            Z( 1 ) = T                                                  
         END IF                                                         
         Z( 2 ) = Z( 3 )                                                
         Z( 6 ) = Z( 2 ) + Z( 1 )                                       
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Check for negative data and compute sums of q's and e's.          
!                                                                       
      Z( 2*N ) = ZERO                                                   
      EMIN = Z( 2 )                                                     
      QMAX = ZERO                                                       
      ZMAX = ZERO                                                       
      D = ZERO                                                          
      E = ZERO                                                          
!                                                                       
      DO 10 K = 1, 2*( N-1 ), 2                                         
         IF( Z( K ).LT.ZERO ) THEN                                      
            INFO = -( 200+K )                                           
            CALL CSVD_XERBLA( 'CSVD_SLASQ2', 2 )
            RETURN                                                      
         ELSE IF( Z( K+1 ).LT.ZERO ) THEN                               
            INFO = -( 200+K+1 )                                         
            CALL CSVD_XERBLA( 'CSVD_SLASQ2', 2 )
            RETURN                                                      
         END IF                                                         
         D = D + Z( K )                                                 
         E = E + Z( K+1 )                                               
         QMAX = MAX( QMAX, Z( K ) )                                     
         EMIN = MIN( EMIN, Z( K+1 ) )                                   
         ZMAX = MAX( QMAX, ZMAX, Z( K+1 ) )                             
   10 CONTINUE                                                          
      IF( Z( 2*N-1 ).LT.ZERO ) THEN                                     
         INFO = -( 200+2*N-1 )                                          
         CALL CSVD_XERBLA( 'CSVD_SLASQ2', 2 )
         RETURN                                                         
      END IF                                                            
      D = D + Z( 2*N-1 )                                                
      QMAX = MAX( QMAX, Z( 2*N-1 ) )                                    
      ZMAX = MAX( QMAX, ZMAX )                                          
!                                                                       
!     Check for diagonality.                                            
!                                                                       
      IF( E.EQ.ZERO ) THEN                                              
         DO 20 K = 2, N                                                 
            Z( K ) = Z( 2*K-1 )                                         
   20    CONTINUE                                                       
         CALL CSVD_SLASRT( 'D', N, Z, IINFO )
         Z( 2*N-1 ) = D                                                 
         RETURN                                                         
      END IF                                                            
!                                                                       
      TRACE = D + E                                                     
!                                                                       
!     Check for zero data.                                              
!                                                                       
      IF( TRACE.EQ.ZERO ) THEN                                          
         Z( 2*N-1 ) = ZERO                                              
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Check whether the machine is IEEE conformable.                    
!                                                                       
      IEEE = csvd_ilaenv( 10, 'CSVD_SLASQ2', 'N', 1, 2, 3, 4 ).EQ.1 .AND.  &
             csvd_ilaenv( 11, 'CSVD_SLASQ2', 'N', 1, 2, 3, 4 ).EQ.1
!                                                                       
!     Rearrange data for locality: Z=(q1,qq1,e1,ee1,q2,qq2,e2,ee2,...). 
!                                                                       
      DO 30 K = 2*N, 2, -2                                              
         Z( 2*K ) = ZERO                                                
         Z( 2*K-1 ) = Z( K )                                            
         Z( 2*K-2 ) = ZERO                                              
         Z( 2*K-3 ) = Z( K-1 )                                          
   30 CONTINUE                                                          
!                                                                       
      I0 = 1                                                            
      N0 = N                                                            
!                                                                       
!     Reverse the qd-array, if warranted.                               
!                                                                       
      IF( CBIAS*Z( 4*I0-3 ).LT.Z( 4*N0-3 ) ) THEN                       
         IPN4 = 4*( I0+N0 )                                             
         DO 40 I4 = 4*I0, 2*( I0+N0-1 ), 4                              
            TEMP = Z( I4-3 )                                            
            Z( I4-3 ) = Z( IPN4-I4-3 )                                  
            Z( IPN4-I4-3 ) = TEMP                                       
            TEMP = Z( I4-1 )                                            
            Z( I4-1 ) = Z( IPN4-I4-5 )                                  
            Z( IPN4-I4-5 ) = TEMP                                       
   40    CONTINUE                                                       
      END IF                                                            
!                                                                       
!     Initial split checking via dqd and Li's test.                     
!                                                                       
      PP = 0                                                            
!                                                                       
      DO 80 K = 1, 2                                                    
!                                                                       
         D = Z( 4*N0+PP-3 )                                             
         DO 50 I4 = 4*( N0-1 ) + PP, 4*I0 + PP, -4                      
            IF( Z( I4-1 ).LE.TOL2*D ) THEN                              
               Z( I4-1 ) = -ZERO                                        
               D = Z( I4-3 )                                            
            ELSE                                                        
               D = Z( I4-3 )*( D / ( D+Z( I4-1 ) ) )                    
            END IF                                                      
   50    CONTINUE                                                       
!                                                                       
!        dqd maps Z to ZZ plus Li's test.                               
!                                                                       
         EMIN = Z( 4*I0+PP+1 )                                          
         D = Z( 4*I0+PP-3 )                                             
         DO 60 I4 = 4*I0 + PP, 4*( N0-1 ) + PP, 4                       
            Z( I4-2*PP-2 ) = D + Z( I4-1 )                              
            IF( Z( I4-1 ).LE.TOL2*D ) THEN                              
               Z( I4-1 ) = -ZERO                                        
               Z( I4-2*PP-2 ) = D                                       
               Z( I4-2*PP ) = ZERO                                      
               D = Z( I4+1 )                                            
            ELSE IF( SAFMIN*Z( I4+1 ).LT.Z( I4-2*PP-2 ) .AND.             &
                     SAFMIN*Z( I4-2*PP-2 ).LT.Z( I4+1 ) ) THEN          
               TEMP = Z( I4+1 ) / Z( I4-2*PP-2 )                        
               Z( I4-2*PP ) = Z( I4-1 )*TEMP                            
               D = D*TEMP                                               
            ELSE                                                        
               Z( I4-2*PP ) = Z( I4+1 )*( Z( I4-1 ) / Z( I4-2*PP-2 ) )  
               D = Z( I4+1 )*( D / Z( I4-2*PP-2 ) )                     
            END IF                                                      
            EMIN = MIN( EMIN, Z( I4-2*PP ) )                            
   60    CONTINUE                                                       
         Z( 4*N0-PP-2 ) = D                                             
!                                                                       
!        Now find qmax.                                                 
!                                                                       
         QMAX = Z( 4*I0-PP-2 )                                          
         DO 70 I4 = 4*I0 - PP + 2, 4*N0 - PP - 2, 4                     
            QMAX = MAX( QMAX, Z( I4 ) )                                 
   70    CONTINUE                                                       
!                                                                       
!        Prepare for the next iteration on K.                           
!                                                                       
         PP = 1 - PP                                                    
   80 CONTINUE                                                          
!                                                                       
      ITER = 2                                                          
      NFAIL = 0                                                         
      NDIV = 2*( N0-I0 )                                                
!                                                                       
      DO 140 IWHILA = 1, N + 1                                          
         IF( N0.LT.1 )                                                    &
            GO TO 150                                                   
!                                                                       
!        While array unfinished do                                      
!                                                                       
!        E(N0) holds the value of SIGMA when submatrix in I0:N0         
!        splits from the rest of the array, but is negated.             
!                                                                       
         DESIG = ZERO                                                   
         IF( N0.EQ.N ) THEN                                             
            SIGMA = ZERO                                                
         ELSE                                                           
            SIGMA = -Z( 4*N0-1 )                                        
         END IF                                                         
         IF( SIGMA.LT.ZERO ) THEN                                       
            INFO = 1                                                    
            RETURN                                                      
         END IF                                                         
!                                                                       
!        Find last unreduced submatrix's top index I0, find QMAX and    
!        EMIN. Find Gershgorin-type bound if Q's much greater than E's. 
!                                                                       
         EMAX = ZERO                                                    
         IF( N0.GT.I0 ) THEN                                            
            EMIN = ABS( Z( 4*N0-5 ) )                                   
         ELSE                                                           
            EMIN = ZERO                                                 
         END IF                                                         
         QMIN = Z( 4*N0-3 )                                             
         QMAX = QMIN                                                    
         DO 90 I4 = 4*N0, 8, -4                                         
            IF( Z( I4-5 ).LE.ZERO )                                       &
               GO TO 100                                                
            IF( QMIN.GE.FOUR*EMAX ) THEN                                
               QMIN = MIN( QMIN, Z( I4-3 ) )                            
               EMAX = MAX( EMAX, Z( I4-5 ) )                            
            END IF                                                      
            QMAX = MAX( QMAX, Z( I4-7 )+Z( I4-5 ) )                     
            EMIN = MIN( EMIN, Z( I4-5 ) )                               
   90    CONTINUE                                                       
         I4 = 4                                                         
!                                                                       
  100    CONTINUE                                                       
         I0 = I4 / 4                                                    
!                                                                       
!        Store EMIN for passing to CSVD_SLASQ3.                              
!                                                                       
         Z( 4*N0-1 ) = EMIN                                             
!                                                                       
!        Put -(initial shift) into DMIN.                                
!                                                                       
         DMIN = -MAX( ZERO, QMIN-TWO*SQRT( QMIN )*SQRT( EMAX ) )        
!                                                                       
!        Now I0:N0 is unreduced. PP = 0 for ping, PP = 1 for pong.      
!                                                                       
         PP = 0                                                         
!                                                                       
         NBIG = 30*( N0-I0+1 )                                          
         DO 120 IWHILB = 1, NBIG                                        
            IF( I0.GT.N0 )                                                &
               GO TO 130                                                
!                                                                       
!           While submatrix unfinished take a good dqds step.           
!                                                                       
            CALL CSVD_SLASQ3( I0, N0, Z, PP, DMIN, SIGMA, DESIG, QMAX, NFAIL,  &
                         ITER, NDIV, IEEE )                             
!                                                                       
            PP = 1 - PP                                                 
!                                                                       
!           When EMIN is very small check for splits.                   
!                                                                       
            IF( PP.EQ.0 .AND. N0-I0.GE.3 ) THEN                         
               IF( Z( 4*N0 ).LE.TOL2*QMAX .OR.                            &
                   Z( 4*N0-1 ).LE.TOL2*SIGMA ) THEN                     
                  SPLT = I0 - 1                                         
                  QMAX = Z( 4*I0-3 )                                    
                  EMIN = Z( 4*I0-1 )                                    
                  OLDEMN = Z( 4*I0 )                                    
                  DO 110 I4 = 4*I0, 4*( N0-3 ), 4                       
                     IF( Z( I4 ).LE.TOL2*Z( I4-3 ) .OR.                   &
                         Z( I4-1 ).LE.TOL2*SIGMA ) THEN                 
                        Z( I4-1 ) = -SIGMA                              
                        SPLT = I4 / 4                                   
                        QMAX = ZERO                                     
                        EMIN = Z( I4+3 )                                
                        OLDEMN = Z( I4+4 )                              
                     ELSE                                               
                        QMAX = MAX( QMAX, Z( I4+1 ) )                   
                        EMIN = MIN( EMIN, Z( I4-1 ) )                   
                        OLDEMN = MIN( OLDEMN, Z( I4 ) )                 
                     END IF                                             
  110             CONTINUE                                              
                  Z( 4*N0-1 ) = EMIN                                    
                  Z( 4*N0 ) = OLDEMN                                    
                  I0 = SPLT + 1                                         
               END IF                                                   
            END IF                                                      
!                                                                       
  120    CONTINUE                                                       
!                                                                       
         INFO = 2                                                       
         RETURN                                                         
!                                                                       
!        end IWHILB                                                     
!                                                                       
  130    CONTINUE                                                       
!                                                                       
  140 CONTINUE                                                          
!                                                                       
      INFO = 3                                                          
      RETURN                                                            
!                                                                       
!     end IWHILA                                                        
!                                                                       
  150 CONTINUE                                                          
!                                                                       
!     Move q's to the front.                                            
!                                                                       
      DO 160 K = 2, N                                                   
         Z( K ) = Z( 4*K-3 )                                            
  160 CONTINUE                                                          
!                                                                       
!     Sort and compute sum of eigenvalues.                              
!                                                                       
      CALL CSVD_SLASRT( 'D', N, Z, IINFO )                                   
!                                                                       
      E = ZERO                                                          
      DO 170 K = N, 1, -1                                               
         E = E + Z( K )                                                 
  170 CONTINUE                                                          
!                                                                       
!     Store trace, sum(eigenvalues) and information on performance.     
!                                                                       
      Z( 2*N+1 ) = TRACE                                                
      Z( 2*N+2 ) = E                                                    
      Z( 2*N+3 ) = REAL( ITER )                                         
      Z( 2*N+4 ) = REAL( NDIV ) / REAL( N**2 )                          
      Z( 2*N+5 ) = HUNDRD*NFAIL / REAL( ITER )                          
      RETURN                                                            
!                                                                       
!     End of CSVD_SLASQ2                                                     
!                                                                       
      END SUBROUTINE CSVD_SLASQ2
                                                              
      SUBROUTINE CSVD_SLASQ3(I0, N0, Z, PP, DMIN, SIGMA, DESIG, QMAX, NFAIL, &
                         ITER, NDIV, IEEE )                             
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     May 17, 2000                                                      
!                                                                       
!     .. Scalar Arguments ..                                            
      LOGICAL            IEEE                                           
      INTEGER            I0, ITER, N0, NDIV, NFAIL, PP                  
      REAL               DESIG, DMIN, QMAX, SIGMA                       
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               Z( * )                                         
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_SLASQ3 checks for deflation, computes a shift (TAU) and calls dqds.  
!  In case of failure it changes shifts, and tries again until output   
!  is positive.                                                         
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  I0     (input) INTEGER                                               
!         First index.                                                  
!                                                                       
!  N0     (input) INTEGER                                               
!         Last index.                                                   
!                                                                       
!  Z      (input) REAL array, dimension ( 4*N )                         
!         Z holds the qd array.                                         
!                                                                       
!  PP     (input) INTEGER                                               
!         PP=0 for ping, PP=1 for pong.                                 
!                                                                       
!  DMIN   (output) REAL                                                 
!         Minimum value of d.                                           
!                                                                       
!  SIGMA  (output) REAL                                                 
!         Sum of shifts used in current segment.                        
!                                                                       
!  DESIG  (input/output) REAL                                           
!         Lower order part of SIGMA                                     
!                                                                       
!  QMAX   (input) REAL                                                  
!         Maximum value of q.                                           
!                                                                       
!  NFAIL  (output) INTEGER                                              
!         Number of times shift was too big.                            
!                                                                       
!  ITER   (output) INTEGER                                              
!         Number of iterations.                                         
!                                                                       
!  NDIV   (output) INTEGER                                              
!         Number of divisions.                                          
!                                                                       
!  TTYPE  (output) INTEGER                                              
!         Shift type.                                                   
!                                                                       
!  IEEE   (input) LOGICAL                                               
!         Flag for IEEE or non IEEE arithmetic (passed to CSVD_SLASQ5).      
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               CBIAS                                          
      PARAMETER          ( CBIAS = 1.50E0 )                             
      REAL               ZERO, QURTR, HALF, ONE, TWO, HUNDRD            
      PARAMETER          ( ZERO = 0.0E0, QURTR = 0.250E0, HALF = 0.5E0,   &
                           ONE = 1.0E0, TWO = 2.0E0, HUNDRD = 100.0E0 ) 
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            IPN4, J4, N0IN, NN, TTYPE                      
      REAL               DMIN1, DMIN2, DN, DN1, DN2, EPS, S, SAFMIN, T,   &
                         TAU, TEMP, TOL, TOL2                           
!     ..                                                                
!     .. External Subroutines ..                                        
  !    EXTERNAL           CSVD_SLASQ4, CSVD_SLASQ5, CSVD_SLASQ6
!     ..                                                                
!     .. External Function ..                                           
!      REAL               csvd_slamch 
!      EXTERNAL           csvd_slamch
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MIN, SQRT                                 
!     ..                                                                
!     .. Save statement ..                                              
      SAVE               TTYPE                                          
      SAVE               DMIN1, DMIN2, DN, DN1, DN2, TAU                
!     ..                                                                
!     .. Data statement ..                                              
      DATA               TTYPE / 0 /                                    
      DATA               DMIN1 / ZERO /, DMIN2 / ZERO /, DN / ZERO /,     &
                         DN1 / ZERO /, DN2 / ZERO /, TAU / ZERO /       
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      N0IN = N0                                                         
      EPS = csvd_slamch( 'Precision' )                                       
      SAFMIN = csvd_slamch( 'Safe minimum' )                                 
      TOL = EPS*HUNDRD                                                  
      TOL2 = TOL**2                                                     
!                                                                       
!     Check for deflation.                                              
!                                                                       
   10 CONTINUE                                                          
!                                                                       
      IF( N0.LT.I0 )                                                      &
         RETURN                                                         
      IF( N0.EQ.I0 )                                                      &
         GO TO 20                                                       
      NN = 4*N0 + PP                                                    
      IF( N0.EQ.( I0+1 ) )                                                &
         GO TO 40                                                       
!                                                                       
!     Check whether E(N0-1) is negligible, 1 eigenvalue.                
!                                                                       
      IF( Z( NN-5 ).GT.TOL2*( SIGMA+Z( NN-3 ) ) .AND.                     &
          Z( NN-2*PP-4 ).GT.TOL2*Z( NN-7 ) )                              &
         GO TO 30                                                       
!                                                                       
   20 CONTINUE                                                          
!                                                                       
      Z( 4*N0-3 ) = Z( 4*N0+PP-3 ) + SIGMA                              
      N0 = N0 - 1                                                       
      GO TO 10                                                          
!                                                                       
!     Check  whether E(N0-2) is negligible, 2 eigenvalues.              
!                                                                       
   30 CONTINUE                                                          
!                                                                       
      IF( Z( NN-9 ).GT.TOL2*SIGMA .AND.                                   &
          Z( NN-2*PP-8 ).GT.TOL2*Z( NN-11 ) )                             &
         GO TO 50                                                       
!                                                                       
   40 CONTINUE                                                          
!                                                                       
      IF( Z( NN-3 ).GT.Z( NN-7 ) ) THEN                                 
         S = Z( NN-3 )                                                  
         Z( NN-3 ) = Z( NN-7 )                                          
         Z( NN-7 ) = S                                                  
      END IF                                                            
      IF( Z( NN-5 ).GT.Z( NN-3 )*TOL2 ) THEN                            
         T = HALF*( ( Z( NN-7 )-Z( NN-3 ) )+Z( NN-5 ) )                 
         S = Z( NN-3 )*( Z( NN-5 ) / T )                                
         IF( S.LE.T ) THEN                                              
            S = Z( NN-3 )*( Z( NN-5 ) /                                   &
                ( T*( ONE+SQRT( ONE+S / T ) ) ) )                       
         ELSE                                                           
            S = Z( NN-3 )*( Z( NN-5 ) / ( T+SQRT( T )*SQRT( T+S ) ) )   
         END IF                                                         
         T = Z( NN-7 ) + ( S+Z( NN-5 ) )                                
         Z( NN-3 ) = Z( NN-3 )*( Z( NN-7 ) / T )                        
         Z( NN-7 ) = T                                                  
      END IF                                                            
      Z( 4*N0-7 ) = Z( NN-7 ) + SIGMA                                   
      Z( 4*N0-3 ) = Z( NN-3 ) + SIGMA                                   
      N0 = N0 - 2                                                       
      GO TO 10                                                          
!                                                                       
   50 CONTINUE                                                          
!                                                                       
!     Reverse the qd-array, if warranted.                               
!                                                                       
      IF( DMIN.LE.ZERO .OR. N0.LT.N0IN ) THEN                           
         IF( CBIAS*Z( 4*I0+PP-3 ).LT.Z( 4*N0+PP-3 ) ) THEN              
            IPN4 = 4*( I0+N0 )                                          
            DO 60 J4 = 4*I0, 2*( I0+N0-1 ), 4                           
               TEMP = Z( J4-3 )                                         
               Z( J4-3 ) = Z( IPN4-J4-3 )                               
               Z( IPN4-J4-3 ) = TEMP                                    
               TEMP = Z( J4-2 )                                         
               Z( J4-2 ) = Z( IPN4-J4-2 )                               
               Z( IPN4-J4-2 ) = TEMP                                    
               TEMP = Z( J4-1 )                                         
               Z( J4-1 ) = Z( IPN4-J4-5 )                               
               Z( IPN4-J4-5 ) = TEMP                                    
               TEMP = Z( J4 )                                           
               Z( J4 ) = Z( IPN4-J4-4 )                                 
               Z( IPN4-J4-4 ) = TEMP                                    
   60       CONTINUE                                                    
            IF( N0-I0.LE.4 ) THEN                                       
               Z( 4*N0+PP-1 ) = Z( 4*I0+PP-1 )                          
               Z( 4*N0-PP ) = Z( 4*I0-PP )                              
            END IF                                                      
            DMIN2 = MIN( DMIN2, Z( 4*N0+PP-1 ) )                        
            Z( 4*N0+PP-1 ) = MIN( Z( 4*N0+PP-1 ), Z( 4*I0+PP-1 ),         &
                                  Z( 4*I0+PP+3 ) )                      
            Z( 4*N0-PP ) = MIN( Z( 4*N0-PP ), Z( 4*I0-PP ),               &
                                Z( 4*I0-PP+4 ) )                        
            QMAX = MAX( QMAX, Z( 4*I0+PP-3 ), Z( 4*I0+PP+1 ) )          
            DMIN = -ZERO                                                
         END IF                                                         
      END IF                                                            
!                                                                       
   70 CONTINUE                                                          
!                                                                       
      IF( DMIN.LT.ZERO .OR. SAFMIN*QMAX.LT.MIN( Z( 4*N0+PP-1 ),           &
          Z( 4*N0+PP-9 ), DMIN2+Z( 4*N0-PP ) ) ) THEN                   
!                                                                       
!        Choose a shift.                                                
!                                                                       
         CALL CSVD_SLASQ4( I0, N0, Z, PP, N0IN, DMIN, DMIN1, DMIN2, DN, DN1,   &
                      DN2, TAU, TTYPE )                                 
!                                                                       
!        Call dqds until DMIN &gt; 0.                                   
!                                                                       
   80    CONTINUE                                                       
!                                                                       
         CALL CSVD_SLASQ5( I0, N0, Z, PP, TAU, DMIN, DMIN1, DMIN2, DN,         &
                      DN1, DN2, IEEE )                                  
!                                                                       
         NDIV = NDIV + ( N0-I0+2 )                                      
         ITER = ITER + 1                                                
!                                                                       
!        Check status.                                                  
!                                                                       
         IF( DMIN.GE.ZERO .AND. DMIN1.GT.ZERO ) THEN                    
!                                                                       
!           Success.                                                    
!                                                                       
            GO TO 100                                                   
!                                                                       
         ELSE IF( DMIN.LT.ZERO .AND. DMIN1.GT.ZERO .AND.                  &
                  Z( 4*( N0-1 )-PP ).LT.TOL*( SIGMA+DN1 ) .AND.           &
                  ABS( DN ).LT.TOL*SIGMA ) THEN                         
!                                                                       
!           Convergence hidden by negative DN.                          
!                                                                       
            Z( 4*( N0-1 )-PP+2 ) = ZERO                                 
            DMIN = ZERO                                                 
            GO TO 100                                                   
         ELSE IF( DMIN.LT.ZERO ) THEN                                   
!                                                                       
!           TAU too big. Select new TAU and try again.                  
!                                                                       
            NFAIL = NFAIL + 1                                           
            IF( TTYPE.LT.-22 ) THEN                                     
!                                                                       
!              Failed twice. Play it safe.                              
!                                                                       
               TAU = ZERO                                               
            ELSE IF( DMIN1.GT.ZERO ) THEN                               
!                                                                       
!              Late failure. Gives excellent shift.                     
!                                                                       
               TAU = ( TAU+DMIN )*( ONE-TWO*EPS )                       
               TTYPE = TTYPE - 11                                       
            ELSE                                                        
!                                                                       
!              Early failure. Divide by 4.                              
!                                                                       
               TAU = QURTR*TAU                                          
               TTYPE = TTYPE - 12                                       
            END IF                                                      
            GO TO 80                                                    
         ELSE IF( DMIN.NE.DMIN ) THEN                                   
!                                                                       
!           NaN.                                                        
!                                                                       
            TAU = ZERO                                                  
            GO TO 80                                                    
         ELSE                                                           
!                                                                       
!           Possible underflow. Play it safe.                           
!                                                                       
            GO TO 90                                                    
         END IF                                                         
      END IF                                                            
!                                                                       
!     Risk of underflow.                                                
!                                                                       
   90 CONTINUE                                                          
      CALL CSVD_SLASQ6( I0, N0, Z, PP, DMIN, DMIN1, DMIN2, DN, DN1, DN2 )    
      NDIV = NDIV + ( N0-I0+2 )                                         
      ITER = ITER + 1                                                   
      TAU = ZERO                                                        
!                                                                       
  100 CONTINUE                                                          
      IF( TAU.LT.SIGMA ) THEN                                           
         DESIG = DESIG + TAU                                            
         T = SIGMA + DESIG                                              
         DESIG = DESIG - ( T-SIGMA )                                    
      ELSE                                                              
         T = SIGMA + TAU                                                
         DESIG = SIGMA - ( T-TAU ) + DESIG                              
      END IF                                                            
      SIGMA = T                                                         
!                                                                       
      RETURN                                                            
!                                                                       
!     End of CSVD_SLASQ3                                                     
!                                                                       
      END SUBROUTINE CSVD_SLASQ3
                                                              
      SUBROUTINE CSVD_SLASQ4( I0, N0, Z, PP, N0IN, DMIN, DMIN1, DMIN2, DN, &
                         DN1, DN2, TAU, TTYPE )                         
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     October 31, 1999                                                  
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            I0, N0, N0IN, PP, TTYPE                        
      REAL               DMIN, DMIN1, DMIN2, DN, DN1, DN2, TAU          
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               Z( * )                                         
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_SLASQ4 computes an approximation TAU to the smallest eigenvalue      
!  using values of d from the previous transform.                       
!                                                                       
!  I0    (input) INTEGER                                                
!        First index.                                                   
!                                                                       
!  N0    (input) INTEGER                                                
!        Last index.                                                    
!                                                                       
!  Z     (input) REAL array, dimension ( 4*N )                          
!        Z holds the qd array.                                          
!                                                                       
!  PP    (input) INTEGER                                                
!        PP=0 for ping, PP=1 for pong.                                  
!                                                                       
!  NOIN  (input) INTEGER                                                
!        The value of N0 at start of EIGTEST.                           
!                                                                       
!  DMIN  (input) REAL                                                   
!        Minimum value of d.                                            
!                                                                       
!  DMIN1 (input) REAL                                                   
!        Minimum value of d, excluding D( N0 ).                         
!                                                                       
!  DMIN2 (input) REAL                                                   
!        Minimum value of d, excluding D( N0 ) and D( N0-1 ).           
!                                                                       
!  DN    (input) REAL                                                   
!        d(N)                                                           
!                                                                       
!  DN1   (input) REAL                                                   
!        d(N-1)                                                         
!                                                                       
!  DN2   (input) REAL                                                   
!        d(N-2)                                                         
!                                                                       
!  TAU   (output) REAL                                                  
!        This is the shift.                                             
!                                                                       
!  TTYPE (output) INTEGER                                               
!        Shift type.                                                    
!                                                                       
!  Further Details                                                      
!  ===============                                                      
!  CNST1 = 9/16                                                         
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      REAL               CNST1, CNST2, CNST3                            
      PARAMETER          ( CNST1 = 0.5630E0, CNST2 = 1.010E0,             &
                         CNST3 = 1.050E0 )                              
      REAL               QURTR, THIRD, HALF, ZERO, ONE, TWO, HUNDRD     
      PARAMETER          ( QURTR = 0.250E0, THIRD = 0.3330E0,             &
                         HALF = 0.50E0, ZERO = 0.0E0, ONE = 1.0E0,        &
                         TWO = 2.0E0, HUNDRD = 100.0E0 )                
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            I4, NN, NP                                     
      REAL               A2, B1, B2, G, GAM, GAP1, GAP2, S              
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MAX, MIN, SQRT                                 
!     ..                                                                
!     .. Save statement ..                                              
      SAVE               G                                              
!     ..                                                                
!     .. Data statement ..                                              
      DATA               G / ZERO /                                     
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     A negative DMIN forces the shift to take that absolute value      
!     TTYPE records the type of shift.                                  
!                                                                       
      IF( DMIN.LE.ZERO ) THEN                                           
         TAU = -DMIN                                                    
         TTYPE = -1                                                     
         RETURN                                                         
      END IF                                                            
!                                                                       
      NN = 4*N0 + PP                                                    
      IF( N0IN.EQ.N0 ) THEN                                             
!                                                                       
!        No eigenvalues deflated.                                       
!                                                                       
         IF( DMIN.EQ.DN .OR. DMIN.EQ.DN1 ) THEN                         
!                                                                       
            B1 = SQRT( Z( NN-3 ) )*SQRT( Z( NN-5 ) )                    
            B2 = SQRT( Z( NN-7 ) )*SQRT( Z( NN-9 ) )                    
            A2 = Z( NN-7 ) + Z( NN-5 )                                  
!                                                                       
!           Cases 2 and 3.                                              
!                                                                       
            IF( DMIN.EQ.DN .AND. DMIN1.EQ.DN1 ) THEN                    
               GAP2 = DMIN2 - A2 - DMIN2*QURTR                          
               IF( GAP2.GT.ZERO .AND. GAP2.GT.B2 ) THEN                 
                  GAP1 = A2 - DN - ( B2 / GAP2 )*B2                     
               ELSE                                                     
                  GAP1 = A2 - DN - ( B1+B2 )                            
               END IF                                                   
               IF( GAP1.GT.ZERO .AND. GAP1.GT.B1 ) THEN                 
                  S = MAX( DN-( B1 / GAP1 )*B1, HALF*DMIN )             
                  TTYPE = -2                                            
               ELSE                                                     
                  S = ZERO                                              
                  IF( DN.GT.B1 )                                          &
                     S = DN - B1                                        
                  IF( A2.GT.( B1+B2 ) )                                   &
                     S = MIN( S, A2-( B1+B2 ) )                         
                  S = MAX( S, THIRD*DMIN )                              
                  TTYPE = -3                                            
               END IF                                                   
            ELSE                                                        
!                                                                       
!              Case 4.                                                  
!                                                                       
               TTYPE = -4                                               
               S = QURTR*DMIN                                           
               IF( DMIN.EQ.DN ) THEN                                    
                  GAM = DN                                              
                  A2 = ZERO                                             
                  IF( Z( NN-5 ) .GT. Z( NN-7 ) )                          &
                     RETURN                                             
                  B2 = Z( NN-5 ) / Z( NN-7 )                            
                  NP = NN - 9                                           
               ELSE                                                     
                  NP = NN - 2*PP                                        
                  B2 = Z( NP-2 )                                        
                  GAM = DN1                                             
                  IF( Z( NP-4 ) .GT. Z( NP-2 ) )                          &
                     RETURN                                             
                  A2 = Z( NP-4 ) / Z( NP-2 )                            
                  IF( Z( NN-9 ) .GT. Z( NN-11 ) )                         &
                     RETURN                                             
                  B2 = Z( NN-9 ) / Z( NN-11 )                           
                  NP = NN - 13                                          
               END IF                                                   
!                                                                       
!              Approximate contribution to norm squared from I &lt; NN-1
!                                                                       
               A2 = A2 + B2                                             
               DO 10 I4 = NP, 4*I0 - 1 + PP, -4                         
                  IF( B2.EQ.ZERO )                                        &
                     GO TO 20                                           
                  B1 = B2                                               
                  IF( Z( I4 ) .GT. Z( I4-2 ) )                            &
                     RETURN                                             
                  B2 = B2*( Z( I4 ) / Z( I4-2 ) )                       
                  A2 = A2 + B2                                          
                  IF( HUNDRD*MAX( B2, B1 ).LT.A2 .OR. CNST1.LT.A2 )       &
                     GO TO 20                                           
   10          CONTINUE                                                 
   20          CONTINUE                                                 
               A2 = CNST3*A2                                            
!                                                                       
!              Rayleigh quotient residual bound.                        
!                                                                       
               IF( A2.LT.CNST1 )                                          &
                  S = GAM*( ONE-SQRT( A2 ) ) / ( ONE+A2 )               
            END IF                                                      
         ELSE IF( DMIN.EQ.DN2 ) THEN                                    
!                                                                       
!           Case 5.                                                     
!                                                                       
            TTYPE = -5                                                  
            S = QURTR*DMIN                                              
!                                                                       
!           Compute contribution to norm squared from I &gt; NN-2.      
!                                                                       
            NP = NN - 2*PP                                              
            B1 = Z( NP-2 )                                              
            B2 = Z( NP-6 )                                              
            GAM = DN2                                                   
            IF( Z( NP-8 ).GT.B2 .OR. Z( NP-4 ).GT.B1 )                    &
               RETURN                                                   
            A2 = ( Z( NP-8 ) / B2 )*( ONE+Z( NP-4 ) / B1 )              
!                                                                       
!           Approximate contribution to norm squared from I &lt; NN-2.  
!                                                                       
            IF( N0-I0.GT.2 ) THEN                                       
               B2 = Z( NN-13 ) / Z( NN-15 )                             
               A2 = A2 + B2                                             
               DO 30 I4 = NN - 17, 4*I0 - 1 + PP, -4                    
                  IF( B2.EQ.ZERO )                                        &
                     GO TO 40                                           
                  B1 = B2                                               
                  IF( Z( I4 ) .GT. Z( I4-2 ) )                            &
                     RETURN                                             
                  B2 = B2*( Z( I4 ) / Z( I4-2 ) )                       
                  A2 = A2 + B2                                          
                  IF( HUNDRD*MAX( B2, B1 ).LT.A2 .OR. CNST1.LT.A2 )       &
                     GO TO 40                                           
   30          CONTINUE                                                 
   40          CONTINUE                                                 
               A2 = CNST3*A2                                            
            END IF                                                      
!                                                                       
            IF( A2.LT.CNST1 )                                             &
               S = GAM*( ONE-SQRT( A2 ) ) / ( ONE+A2 )                  
         ELSE                                                           
!                                                                       
!           Case 6, no information to guide us.                         
!                                                                       
            IF( TTYPE.EQ.-6 ) THEN                                      
               G = G + THIRD*( ONE-G )                                  
            ELSE IF( TTYPE.EQ.-18 ) THEN                                
               G = QURTR*THIRD                                          
            ELSE                                                        
               G = QURTR                                                
            END IF                                                      
            S = G*DMIN                                                  
            TTYPE = -6                                                  
         END IF                                                         
!                                                                       
      ELSE IF( N0IN.EQ.( N0+1 ) ) THEN                                  
!                                                                       
!        One eigenvalue just deflated. Use DMIN1, DN1 for DMIN and DN.  
!                                                                       
         IF( DMIN1.EQ.DN1 .AND. DMIN2.EQ.DN2 ) THEN                     
!                                                                       
!           Cases 7 and 8.                                              
!                                                                       
            TTYPE = -7                                                  
            S = THIRD*DMIN1                                             
            IF( Z( NN-5 ).GT.Z( NN-7 ) )                                  &
               RETURN                                                   
            B1 = Z( NN-5 ) / Z( NN-7 )                                  
            B2 = B1                                                     
            IF( B2.EQ.ZERO )                                              &
               GO TO 60                                                 
            DO 50 I4 = 4*N0 - 9 + PP, 4*I0 - 1 + PP, -4                 
               A2 = B1                                                  
               IF( Z( I4 ).GT.Z( I4-2 ) )                                 &
                  RETURN                                                
               B1 = B1*( Z( I4 ) / Z( I4-2 ) )                          
               B2 = B2 + B1                                             
               IF( HUNDRD*MAX( B1, A2 ).LT.B2 )                           &
                  GO TO 60                                              
   50       CONTINUE                                                    
   60       CONTINUE                                                    
            B2 = SQRT( CNST3*B2 )                                       
            A2 = DMIN1 / ( ONE+B2**2 )                                  
            GAP2 = HALF*DMIN2 - A2                                      
            IF( GAP2.GT.ZERO .AND. GAP2.GT.B2*A2 ) THEN                 
               S = MAX( S, A2*( ONE-CNST2*A2*( B2 / GAP2 )*B2 ) )       
            ELSE                                                        
               S = MAX( S, A2*( ONE-CNST2*B2 ) )                        
               TTYPE = -8                                               
            END IF                                                      
         ELSE                                                           
!                                                                       
!           Case 9.                                                     
!                                                                       
            S = QURTR*DMIN1                                             
            IF( DMIN1.EQ.DN1 )                                            &
               S = HALF*DMIN1                                           
            TTYPE = -9                                                  
         END IF                                                         
!                                                                       
      ELSE IF( N0IN.EQ.( N0+2 ) ) THEN                                  
!                                                                       
!        Two eigenvalues deflated. Use DMIN2, DN2 for DMIN and DN.      
!                                                                       
!        Cases 10 and 11.                                               
!                                                                       
         IF( DMIN2.EQ.DN2 .AND. TWO*Z( NN-5 ).LT.Z( NN-7 ) ) THEN       
            TTYPE = -10                                                 
            S = THIRD*DMIN2                                             
            IF( Z( NN-5 ).GT.Z( NN-7 ) )                                  &
               RETURN                                                   
            B1 = Z( NN-5 ) / Z( NN-7 )                                  
            B2 = B1                                                     
            IF( B2.EQ.ZERO )                                              &
               GO TO 80                                                 
            DO 70 I4 = 4*N0 - 9 + PP, 4*I0 - 1 + PP, -4                 
               IF( Z( I4 ).GT.Z( I4-2 ) )                                 &
                  RETURN                                                
               B1 = B1*( Z( I4 ) / Z( I4-2 ) )                          
               B2 = B2 + B1                                             
               IF( HUNDRD*B1.LT.B2 )                                      &
                  GO TO 80                                              
   70       CONTINUE                                                    
   80       CONTINUE                                                    
            B2 = SQRT( CNST3*B2 )                                       
            A2 = DMIN2 / ( ONE+B2**2 )                                  
            GAP2 = Z( NN-7 ) + Z( NN-9 ) -                                &
                   SQRT( Z( NN-11 ) )*SQRT( Z( NN-9 ) ) - A2            
            IF( GAP2.GT.ZERO .AND. GAP2.GT.B2*A2 ) THEN                 
               S = MAX( S, A2*( ONE-CNST2*A2*( B2 / GAP2 )*B2 ) )       
            ELSE                                                        
               S = MAX( S, A2*( ONE-CNST2*B2 ) )                        
            END IF                                                      
         ELSE                                                           
            S = QURTR*DMIN2                                             
            TTYPE = -11                                                 
         END IF                                                         
      ELSE IF( N0IN.GT.( N0+2 ) ) THEN                                  
!                                                                       
!        Case 12, more than two eigenvalues deflated. No information.   
!                                                                       
         S = ZERO                                                       
         TTYPE = -12                                                    
      END IF                                                            
!                                                                       
      TAU = S                                                           
      RETURN                                                            
!                                                                       
!     End of CSVD_SLASQ4                                                     
!                                                                       
      END SUBROUTINE CSVD_SLASQ4
                                                              
      SUBROUTINE CSVD_SLASQ5( I0, N0, Z, PP, TAU, DMIN, DMIN1, DMIN2, DN, & 
                         DNM1, DNM2, IEEE )                             
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     May 17, 2000                                                      
!                                                                       
!     .. Scalar Arguments ..                                            
      LOGICAL            IEEE                                           
      INTEGER            I0, N0, PP                                     
      REAL               DMIN, DMIN1, DMIN2, DN, DNM1, DNM2, TAU        
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               Z( * )                                         
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_SLASQ5 computes one dqds transform in ping-pong form, one            
!  version for IEEE machines another for non IEEE machines.             
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  I0    (input) INTEGER                                                
!        First index.                                                   
!                                                                       
!  N0    (input) INTEGER                                                
!        Last index.                                                    
!                                                                       
!  Z     (input) REAL array, dimension ( 4*N )                          
!        Z holds the qd array. EMIN is stored in Z(4*N0) to avoid       
!        an extra argument.                                             
!                                                                       
!  PP    (input) INTEGER                                                
!        PP=0 for ping, PP=1 for pong.                                  
!                                                                       
!  TAU   (input) REAL                                                   
!        This is the shift.                                             
!                                                                       
!  DMIN  (output) REAL                                                  
!        Minimum value of d.                                            
!                                                                       
!  DMIN1 (output) REAL                                                  
!        Minimum value of d, excluding D( N0 ).                         
!                                                                       
!  DMIN2 (output) REAL                                                  
!        Minimum value of d, excluding D( N0 ) and D( N0-1 ).           
!                                                                       
!  DN    (output) REAL                                                  
!        d(N0), the last value of d.                                    
!                                                                       
!  DNM1  (output) REAL                                                  
!        d(N0-1).                                                       
!                                                                       
!  DNM2  (output) REAL                                                  
!        d(N0-2).                                                       
!                                                                       
!  IEEE  (input) LOGICAL                                                
!        Flag for IEEE or non IEEE arithmetic.                          
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameter ..                                                   
      REAL               ZERO                                           
      PARAMETER          ( ZERO = 0.0E0 )                               
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            J4, J4P2                                       
      REAL               D, EMIN, TEMP                                  
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MIN                                            
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( ( N0-I0-1 ).LE.0 )                                              &
         RETURN                                                         
!                                                                       
      J4 = 4*I0 + PP - 3                                                
      EMIN = Z( J4+4 )                                                  
      D = Z( J4 ) - TAU                                                 
      DMIN = D                                                          
      DMIN1 = -Z( J4 )                                                  
!                                                                       
      IF( IEEE ) THEN                                                   
!                                                                       
!        Code for IEEE arithmetic.                                      
!                                                                       
         IF( PP.EQ.0 ) THEN                                             
            DO 10 J4 = 4*I0, 4*( N0-3 ), 4                              
               Z( J4-2 ) = D + Z( J4-1 )                                
               TEMP = Z( J4+1 ) / Z( J4-2 )                             
               D = D*TEMP - TAU                                         
               DMIN = MIN( DMIN, D )                                    
               Z( J4 ) = Z( J4-1 )*TEMP                                 
               EMIN = MIN( Z( J4 ), EMIN )                              
   10       CONTINUE                                                    
         ELSE                                                           
            DO 20 J4 = 4*I0, 4*( N0-3 ), 4                              
               Z( J4-3 ) = D + Z( J4 )                                  
               TEMP = Z( J4+2 ) / Z( J4-3 )                             
               D = D*TEMP - TAU                                         
               DMIN = MIN( DMIN, D )                                    
               Z( J4-1 ) = Z( J4 )*TEMP                                 
               EMIN = MIN( Z( J4-1 ), EMIN )                            
   20       CONTINUE                                                    
         END IF                                                         
!                                                                       
!        Unroll last two steps.                                         
!                                                                       
         DNM2 = D                                                       
         DMIN2 = DMIN                                                   
         J4 = 4*( N0-2 ) - PP                                           
         J4P2 = J4 + 2*PP - 1                                           
         Z( J4-2 ) = DNM2 + Z( J4P2 )                                   
         Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) )                
         DNM1 = Z( J4P2+2 )*( DNM2 / Z( J4-2 ) ) - TAU                  
         DMIN = MIN( DMIN, DNM1 )                                       
!                                                                       
         DMIN1 = DMIN                                                   
         J4 = J4 + 4                                                    
         J4P2 = J4 + 2*PP - 1                                           
         Z( J4-2 ) = DNM1 + Z( J4P2 )                                   
         Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) )                
         DN = Z( J4P2+2 )*( DNM1 / Z( J4-2 ) ) - TAU                    
         DMIN = MIN( DMIN, DN )                                         
!                                                                       
      ELSE                                                              
!                                                                       
!        Code for non IEEE arithmetic.                                  
!                                                                       
         IF( PP.EQ.0 ) THEN                                             
            DO 30 J4 = 4*I0, 4*( N0-3 ), 4                              
               Z( J4-2 ) = D + Z( J4-1 )                                
               IF( D.LT.ZERO ) THEN                                     
                  RETURN                                                
               ELSE                                                     
                  Z( J4 ) = Z( J4+1 )*( Z( J4-1 ) / Z( J4-2 ) )         
                  D = Z( J4+1 )*( D / Z( J4-2 ) ) - TAU                 
               END IF                                                   
               DMIN = MIN( DMIN, D )                                    
               EMIN = MIN( EMIN, Z( J4 ) )                              
   30       CONTINUE                                                    
         ELSE                                                           
            DO 40 J4 = 4*I0, 4*( N0-3 ), 4                              
               Z( J4-3 ) = D + Z( J4 )                                  
               IF( D.LT.ZERO ) THEN                                     
                  RETURN                                                
               ELSE                                                     
                  Z( J4-1 ) = Z( J4+2 )*( Z( J4 ) / Z( J4-3 ) )         
                  D = Z( J4+2 )*( D / Z( J4-3 ) ) - TAU                 
               END IF                                                   
               DMIN = MIN( DMIN, D )                                    
               EMIN = MIN( EMIN, Z( J4-1 ) )                            
   40       CONTINUE                                                    
         END IF                                                         
!                                                                       
!        Unroll last two steps.                                         
!                                                                       
         DNM2 = D                                                       
         DMIN2 = DMIN                                                   
         J4 = 4*( N0-2 ) - PP                                           
         J4P2 = J4 + 2*PP - 1                                           
         Z( J4-2 ) = DNM2 + Z( J4P2 )                                   
         IF( DNM2.LT.ZERO ) THEN                                        
            RETURN                                                      
         ELSE                                                           
            Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) )             
            DNM1 = Z( J4P2+2 )*( DNM2 / Z( J4-2 ) ) - TAU               
         END IF                                                         
         DMIN = MIN( DMIN, DNM1 )                                       
!                                                                       
         DMIN1 = DMIN                                                   
         J4 = J4 + 4                                                    
         J4P2 = J4 + 2*PP - 1                                           
         Z( J4-2 ) = DNM1 + Z( J4P2 )                                   
         IF( DNM1.LT.ZERO ) THEN                                        
            RETURN                                                      
         ELSE                                                           
            Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) )             
            DN = Z( J4P2+2 )*( DNM1 / Z( J4-2 ) ) - TAU                 
         END IF                                                         
         DMIN = MIN( DMIN, DN )                                         
!                                                                       
      END IF                                                            
!                                                                       
      Z( J4+2 ) = DN                                                    
      Z( 4*N0-PP ) = EMIN                                               
      RETURN                                                            
!                                                                       
!     End of CSVD_SLASQ5                                                     
!                                                                       
      END SUBROUTINE CSVD_SLASQ5
                                                              
      SUBROUTINE CSVD_SLASQ6( I0, N0, Z, PP, DMIN, DMIN1, DMIN2, DN, &
                         DNM1, DNM2 )                                   
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     October 31, 1999                                                  
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            I0, N0, PP                                     
      REAL               DMIN, DMIN1, DMIN2, DN, DNM1, DNM2             
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               Z( * )                                         
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  computes one dqd (shift equal to zero) transform in           
!  ping-pong form, with protection against underflow and overflow.      
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  I0    (input) INTEGER                                                
!        First index.                                                   
!                                                                       
!  N0    (input) INTEGER                                                
!        Last index.                                                    
!                                                                       
!  Z     (input) REAL array, dimension ( 4*N )                          
!        Z holds the qd array. EMIN is stored in Z(4*N0) to avoid       
!        an extra argument.                                             
!                                                                       
!  PP    (input) INTEGER                                                
!        PP=0 for ping, PP=1 for pong.                                  
!                                                                       
!  DMIN  (output) REAL                                                  
!        Minimum value of d.                                            
!                                                                       
!  DMIN1 (output) REAL                                                  
!        Minimum value of d, excluding D( N0 ).                         
!                                                                       
!  DMIN2 (output) REAL                                                  
!        Minimum value of d, excluding D( N0 ) and D( N0-1 ).           
!                                                                       
!  DN    (output) REAL                                                  
!        d(N0), the last value of d.                                    
!                                                                       
!  DNM1  (output) REAL                                                  
!        d(N0-1).                                                       
!                                                                       
!  DNM2  (output) REAL                                                  
!        d(N0-2).                                                       
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameter ..                                                   
      REAL               ZERO                                           
      PARAMETER          ( ZERO = 0.0E0 )                               
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            J4, J4P2                                       
      REAL               D, EMIN, SAFMIN, TEMP                          
!     ..                                                                
!     .. External Function ..                                           
!      REAL               csvd_slamch                                         
!      EXTERNAL           csvd_slamch                                         
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MIN                                            
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( ( N0-I0-1 ).LE.0 )                                              &
         RETURN                                                         
!                                                                       
      SAFMIN = csvd_slamch( 'Safe minimum' )                                 
      J4 = 4*I0 + PP - 3                                                
      EMIN = Z( J4+4 )                                                  
      D = Z( J4 )                                                       
      DMIN = D                                                          
!                                                                       
      IF( PP.EQ.0 ) THEN                                                
         DO 10 J4 = 4*I0, 4*( N0-3 ), 4                                 
            Z( J4-2 ) = D + Z( J4-1 )                                   
            IF( Z( J4-2 ).EQ.ZERO ) THEN                                
               Z( J4 ) = ZERO                                           
               D = Z( J4+1 )                                            
               DMIN = D                                                 
               EMIN = ZERO                                              
            ELSE IF( SAFMIN*Z( J4+1 ).LT.Z( J4-2 ) .AND.                  &
                     SAFMIN*Z( J4-2 ).LT.Z( J4+1 ) ) THEN               
               TEMP = Z( J4+1 ) / Z( J4-2 )                             
               Z( J4 ) = Z( J4-1 )*TEMP                                 
               D = D*TEMP                                               
            ELSE                                                        
               Z( J4 ) = Z( J4+1 )*( Z( J4-1 ) / Z( J4-2 ) )            
               D = Z( J4+1 )*( D / Z( J4-2 ) )                          
            END IF                                                      
            DMIN = MIN( DMIN, D )                                       
            EMIN = MIN( EMIN, Z( J4 ) )                                 
   10    CONTINUE                                                       
      ELSE                                                              
         DO 20 J4 = 4*I0, 4*( N0-3 ), 4                                 
            Z( J4-3 ) = D + Z( J4 )                                     
            IF( Z( J4-3 ).EQ.ZERO ) THEN                                
               Z( J4-1 ) = ZERO                                         
               D = Z( J4+2 )                                            
               DMIN = D                                                 
               EMIN = ZERO                                              
            ELSE IF( SAFMIN*Z( J4+2 ).LT.Z( J4-3 ) .AND.                  &
                     SAFMIN*Z( J4-3 ).LT.Z( J4+2 ) ) THEN               
               TEMP = Z( J4+2 ) / Z( J4-3 )                             
               Z( J4-1 ) = Z( J4 )*TEMP                                 
               D = D*TEMP                                               
            ELSE                                                        
               Z( J4-1 ) = Z( J4+2 )*( Z( J4 ) / Z( J4-3 ) )            
               D = Z( J4+2 )*( D / Z( J4-3 ) )                          
            END IF                                                      
            DMIN = MIN( DMIN, D )                                       
            EMIN = MIN( EMIN, Z( J4-1 ) )                               
   20    CONTINUE                                                       
      END IF                                                            
!                                                                       
!     Unroll last two steps.                                            
!                                                                       
      DNM2 = D                                                          
      DMIN2 = DMIN                                                      
      J4 = 4*( N0-2 ) - PP                                              
      J4P2 = J4 + 2*PP - 1                                              
      Z( J4-2 ) = DNM2 + Z( J4P2 )                                      
      IF( Z( J4-2 ).EQ.ZERO ) THEN                                      
         Z( J4 ) = ZERO                                                 
         DNM1 = Z( J4P2+2 )                                             
         DMIN = DNM1                                                    
         EMIN = ZERO                                                    
      ELSE IF( SAFMIN*Z( J4P2+2 ).LT.Z( J4-2 ) .AND.                      &
               SAFMIN*Z( J4-2 ).LT.Z( J4P2+2 ) ) THEN                   
         TEMP = Z( J4P2+2 ) / Z( J4-2 )                                 
         Z( J4 ) = Z( J4P2 )*TEMP                                       
         DNM1 = DNM2*TEMP                                               
      ELSE                                                              
         Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) )                
         DNM1 = Z( J4P2+2 )*( DNM2 / Z( J4-2 ) )                        
      END IF                                                            
      DMIN = MIN( DMIN, DNM1 )                                          
!                                                                       
      DMIN1 = DMIN                                                      
      J4 = J4 + 4                                                       
      J4P2 = J4 + 2*PP - 1                                              
      Z( J4-2 ) = DNM1 + Z( J4P2 )                                      
      IF( Z( J4-2 ).EQ.ZERO ) THEN                                      
         Z( J4 ) = ZERO                                                 
         DN = Z( J4P2+2 )                                               
         DMIN = DN                                                      
         EMIN = ZERO                                                    
      ELSE IF( SAFMIN*Z( J4P2+2 ).LT.Z( J4-2 ) .AND.                      &
               SAFMIN*Z( J4-2 ).LT.Z( J4P2+2 ) ) THEN                   
         TEMP = Z( J4P2+2 ) / Z( J4-2 )                                 
         Z( J4 ) = Z( J4P2 )*TEMP                                       
         DN = DNM1*TEMP                                                 
      ELSE                                                              
         Z( J4 ) = Z( J4P2+2 )*( Z( J4P2 ) / Z( J4-2 ) )                
         DN = Z( J4P2+2 )*( DNM1 / Z( J4-2 ) )                          
      END IF                                                            
      DMIN = MIN( DMIN, DN )                                            
!                                                                       
      Z( J4+2 ) = DN                                                    
      Z( 4*N0-PP ) = EMIN                                               
      RETURN                                                            
!                                                                       
!     End of CSVD_SLASQ6                                                     
!                                                                       
      END SUBROUTINE CSVD_SLASQ6
                                                              
      SUBROUTINE CSVD_SLASRT( ID, N, D, INFO )                               
!                                                                       
!  -- LAPACK routine (version 3.0) --                                   
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     September 30, 1994                                                
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          ID                                             
      INTEGER            INFO, N                                        
!     ..                                                                
!     .. Array Arguments ..                                             
      REAL               D( * )                                         
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  Sort the numbers in D in increasing order (if ID = 'I') or           
!  in decreasing order (if ID = 'D' ).                                  
!                                                                       
!  Use Quick Sort, reverting to Insertion sort on arrays of             
!  size &lt;= 20. Dimension of STACK limits N to about 2**32.           
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  ID      (input) CHARACTER*1                                          
!          = 'I': sort D in increasing order;                           
!          = 'D': sort D in decreasing order.                           
!                                                                       
!  N       (input) INTEGER                                              
!          The length of the array D.                                   
!                                                                       
!  D       (input/output) REAL array, dimension (N)                     
!          On entry, the array to be sorted.                            
!          On exit, D has been sorted into increasing order             
!          (D(1) &lt;= ... &lt;= D(N) ) or into decreasing order        
!          (D(1) &gt;= ... &gt;= D(N) ), depending on ID.               
!                                                                       
!  INFO    (output) INTEGER                                             
!          = 0:  successful exit                                        
!          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
!                                                                       
!  =====================================================================
!                                                                       
!     .. Parameters ..                                                  
      INTEGER            SELECT                                         
      PARAMETER          ( SELECT = 20 )                                
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            DIR, ENDD, I, J, START, STKPNT                 
      REAL               D1, D2, D3, DMNMX, TMP                         
!     ..                                                                
!     .. Local Arrays ..                                                
      INTEGER            STACK( 2, 32 )                                 
!     ..                                                                
!     .. External Functions ..                                          
!      LOGICAL            csvd_lsame                                          
!      EXTERNAL           csvd_lsame                                          
!     ..                                                                
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_XERBLA                                         
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input paramters.                                         
!                                                                       
      INFO = 0                                                          
      DIR = -1                                                          
      IF( csvd_lsame( ID, 'D' ) ) THEN                                       
         DIR = 0                                                        
      ELSE IF( csvd_lsame( ID, 'I' ) ) THEN                                  
         DIR = 1                                                        
      END IF                                                            
      IF( DIR.EQ.-1 ) THEN                                              
         INFO = -1                                                      
      ELSE IF( N.LT.0 ) THEN                                            
         INFO = -2                                                      
      END IF                                                            
      IF( INFO.NE.0 ) THEN                                              
         CALL CSVD_XERBLA( 'CSVD_SLASRT', -INFO )
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible                                          
!                                                                       
      IF( N.LE.1 )                                                        &
         RETURN                                                         
!                                                                       
      STKPNT = 1                                                        
      STACK( 1, 1 ) = 1                                                 
      STACK( 2, 1 ) = N                                                 
   10 CONTINUE                                                          
      START = STACK( 1, STKPNT )                                        
      ENDD = STACK( 2, STKPNT )                                         
      STKPNT = STKPNT - 1                                               
      IF( ENDD-START.LE.SELECT .AND. ENDD-START.GT.0 ) THEN             
!                                                                       
!        Do Insertion sort on D( START:ENDD )                           
!                                                                       
         IF( DIR.EQ.0 ) THEN                                            
!                                                                       
!           Sort into decreasing order                                  
!                                                                       
            DO 30 I = START + 1, ENDD                                   
               DO 20 J = I, START + 1, -1                               
                  IF( D( J ).GT.D( J-1 ) ) THEN                         
                     DMNMX = D( J )                                     
                     D( J ) = D( J-1 )                                  
                     D( J-1 ) = DMNMX                                   
                  ELSE                                                  
                     GO TO 30                                           
                  END IF                                                
   20          CONTINUE                                                 
   30       CONTINUE                                                    
!                                                                       
         ELSE                                                           
!                                                                       
!           Sort into increasing order                                  
!                                                                       
            DO 50 I = START + 1, ENDD                                   
               DO 40 J = I, START + 1, -1                               
                  IF( D( J ).LT.D( J-1 ) ) THEN                         
                     DMNMX = D( J )                                     
                     D( J ) = D( J-1 )                                  
                     D( J-1 ) = DMNMX                                   
                  ELSE                                                  
                     GO TO 50                                           
                  END IF                                                
   40          CONTINUE                                                 
   50       CONTINUE                                                    
!                                                                       
         END IF                                                         
!                                                                       
      ELSE IF( ENDD-START.GT.SELECT ) THEN                              
!                                                                       
!        Partition D( START:ENDD ) and stack parts, largest one first   
!                                                                       
!        Choose partition entry as median of 3                          
!                                                                       
         D1 = D( START )                                                
         D2 = D( ENDD )                                                 
         I = ( START+ENDD ) / 2                                         
         D3 = D( I )                                                    
         IF( D1.LT.D2 ) THEN                                            
            IF( D3.LT.D1 ) THEN                                         
               DMNMX = D1                                               
            ELSE IF( D3.LT.D2 ) THEN                                    
               DMNMX = D3                                               
            ELSE                                                        
               DMNMX = D2                                               
            END IF                                                      
         ELSE                                                           
            IF( D3.LT.D2 ) THEN                                         
               DMNMX = D2                                               
            ELSE IF( D3.LT.D1 ) THEN                                    
               DMNMX = D3                                               
            ELSE                                                        
               DMNMX = D1                                               
            END IF                                                      
         END IF                                                         
!                                                                       
         IF( DIR.EQ.0 ) THEN                                            
!                                                                       
!           Sort into decreasing order                                  
!                                                                       
            I = START - 1                                               
            J = ENDD + 1                                                
   60       CONTINUE                                                    
   70       CONTINUE                                                    
            J = J - 1                                                   
            IF( D( J ).LT.DMNMX )                                         &
               GO TO 70                                                 
   80       CONTINUE                                                    
            I = I + 1                                                   
            IF( D( I ).GT.DMNMX )                                         &
               GO TO 80                                                 
            IF( I.LT.J ) THEN                                           
               TMP = D( I )                                             
               D( I ) = D( J )                                          
               D( J ) = TMP                                             
               GO TO 60                                                 
            END IF                                                      
            IF( J-START.GT.ENDD-J-1 ) THEN                              
               STKPNT = STKPNT + 1                                      
               STACK( 1, STKPNT ) = START                               
               STACK( 2, STKPNT ) = J                                   
               STKPNT = STKPNT + 1                                      
               STACK( 1, STKPNT ) = J + 1                               
               STACK( 2, STKPNT ) = ENDD                                
            ELSE                                                        
               STKPNT = STKPNT + 1                                      
               STACK( 1, STKPNT ) = J + 1                               
               STACK( 2, STKPNT ) = ENDD                                
               STKPNT = STKPNT + 1                                      
               STACK( 1, STKPNT ) = START                               
               STACK( 2, STKPNT ) = J                                   
            END IF                                                      
         ELSE                                                           
!                                                                       
!           Sort into increasing order                                  
!                                                                       
            I = START - 1                                               
            J = ENDD + 1                                                
   90       CONTINUE                                                    
  100       CONTINUE                                                    
            J = J - 1                                                   
            IF( D( J ).GT.DMNMX )                                         &
               GO TO 100                                                
  110       CONTINUE                                                    
            I = I + 1                                                   
            IF( D( I ).LT.DMNMX )                                         &
               GO TO 110                                                
            IF( I.LT.J ) THEN                                           
               TMP = D( I )                                             
               D( I ) = D( J )                                          
               D( J ) = TMP                                             
               GO TO 90                                                 
            END IF                                                      
            IF( J-START.GT.ENDD-J-1 ) THEN                              
               STKPNT = STKPNT + 1                                      
               STACK( 1, STKPNT ) = START                               
               STACK( 2, STKPNT ) = J                                   
               STKPNT = STKPNT + 1                                      
               STACK( 1, STKPNT ) = J + 1                               
               STACK( 2, STKPNT ) = ENDD                                
            ELSE                                                        
               STKPNT = STKPNT + 1                                      
               STACK( 1, STKPNT ) = J + 1                               
               STACK( 2, STKPNT ) = ENDD                                
               STKPNT = STKPNT + 1                                      
               STACK( 1, STKPNT ) = START                               
               STACK( 2, STKPNT ) = J                                   
            END IF                                                      
         END IF                                                         
      END IF                                                            
      IF( STKPNT.GT.0 )                                                   &
         GO TO 10                                                       
      RETURN                                                            
!                                                                       
!     End of CSVD_SLASRT                                                     
!                                                                       
      END SUBROUTINE CSVD_SLASRT
                                                              
      SUBROUTINE CSVD_SLASV2( F, G, H, SSMIN, SSMAX, SNR, CSR, SNL, CSL )    
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     October 31, 1992                                                  
!                                                                       
!     .. Scalar Arguments ..                                            
      REAL               CSL, CSR, F, G, H, SNL, SNR, SSMAX, SSMIN      
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_SLASV2 computes the singular value decomposition of a 2-by-2         
!  triangular matrix                                                    
!     [  F   G  ]                                                       
!     [  0   H  ].                                                      
!  On return, abs(SSMAX) is the larger singular value, abs(SSMIN) is the
!  smaller singular value, and (CSL,SNL) and (CSR,SNR) are the left and 
!  right singular vectors for abs(SSMAX), giving the decomposition      
!                                                                       
!     [ CSL  SNL ] [  F   G  ] [ CSR -SNR ]  =  [ SSMAX   0   ]         
!     [-SNL  CSL ] [  0   H  ] [ SNR  CSR ]     [  0    SSMIN ].        
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  F       (input) REAL                                                 
!          The (1,1) element of the 2-by-2 matrix.                      
!                                                                       
!  G       (input) REAL                                                 
!          The (1,2) element of the 2-by-2 matrix.                      
!                                                                       
!  H       (input) REAL                                                 
!          The (2,2) element of the 2-by-2 matrix.                      
!                                                                       
!  SSMIN   (output) REAL                                                
!          abs(SSMIN) is the smaller singular value.                    
!                                                                       
!  SSMAX   (output) REAL                                                
!          abs(SSMAX) is the larger singular value.                     
!                                                                       
!  SNL     (output) REAL                                                
!  CSL     (output) REAL                                                
!          The vector (CSL, SNL) is a unit left singular vector for the 
!          singular value abs(SSMAX).                                   
!                                                                       
!  SNR     (output) REAL                                                
!  CSR     (output) REAL                                                
!          The vector (CSR, SNR) is a unit right singular vector for the
!          singular value abs(SSMAX).                                   
!                                                                       
!  Further Details                                                      
!  ===============                                                      
!                                                                       
!  Any input parameter may be aliased with any output parameter.        
!                                                                       
!  Barring over/underflow and assuming a guard digit in subtraction, all
!  output quantities are correct to within a few units in the last      
!  place (ulps).                                                        
!                                                                       
!  In IEEE arithmetic, the code works correctly if one matrix element is
!  infinite.                                                            
!                                                                       
!  Overflow will not occur unless the largest singular value itself     
!  overflows or is within a few ulps of overflow. (On machines with     
!  partial overflow, like the Cray, overflow may occur if the largest   
!  singular value is within a factor of 2 of overflow.)                 
!                                                                       
!  Underflow is harmless if underflow is gradual. Otherwise, results    
!  may correspond to a matrix modified by perturbations of size near    
!  the underflow threshold.                                             
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO                                           
      PARAMETER          ( ZERO = 0.0E0 )                               
      REAL               HALF                                           
      PARAMETER          ( HALF = 0.5E0 )                               
      REAL               ONE                                            
      PARAMETER          ( ONE = 1.0E0 )                                
      REAL               TWO                                            
      PARAMETER          ( TWO = 2.0E0 )                                
      REAL               FOUR                                           
      PARAMETER          ( FOUR = 4.0E0 )                               
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            GASMAL, SWAP                                   
      INTEGER            PMAX                                           
      REAL               A, CLT, CRT, D, FA, FT, GA, GT, HA, HT, L, M,    &
                         MM, R, S, SLT, SRT, T, TEMP, TSIGN, TT         
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, SIGN, SQRT                                
!     ..                                                                
!     .. External Functions ..                                          
!      REAL               csvd_slamch                                         
!      EXTERNAL           csvd_slamch                                         
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      FT = F                                                            
      FA = ABS( FT )                                                    
      HT = H                                                            
      HA = ABS( H )                                                     
!                                                                       
!     PMAX points to the maximum absolute element of matrix             
!       PMAX = 1 if F largest in absolute values                        
!       PMAX = 2 if G largest in absolute values                        
!       PMAX = 3 if H largest in absolute values                        
!                                                                       
      PMAX = 1                                                          
      SWAP = ( HA.GT.FA )                                               
      IF( SWAP ) THEN                                                   
         PMAX = 3                                                       
         TEMP = FT                                                      
         FT = HT                                                        
         HT = TEMP                                                      
         TEMP = FA                                                      
         FA = HA                                                        
         HA = TEMP                                                      
!                                                                       
!        Now FA .ge. HA                                                 
!                                                                       
      END IF                                                            
      GT = G                                                            
      GA = ABS( GT )                                                    
      IF( GA.EQ.ZERO ) THEN                                             
!                                                                       
!        Diagonal matrix                                                
!                                                                       
         SSMIN = HA                                                     
         SSMAX = FA                                                     
         CLT = ONE                                                      
         CRT = ONE                                                      
         SLT = ZERO                                                     
         SRT = ZERO                                                     
      ELSE                                                              
         GASMAL = .TRUE.                                                
         IF( GA.GT.FA ) THEN                                            
            PMAX = 2                                                    
            IF( ( FA / GA ).LT.csvd_slamch( 'EPS' ) ) THEN                   
!                                                                       
!              Case of very large GA                                    
!                                                                       
               GASMAL = .FALSE.                                         
               SSMAX = GA                                               
               IF( HA.GT.ONE ) THEN                                     
                  SSMIN = FA / ( GA / HA )                              
               ELSE                                                     
                  SSMIN = ( FA / GA )*HA                                
               END IF                                                   
               CLT = ONE                                                
               SLT = HT / GT                                            
               SRT = ONE                                                
               CRT = FT / GT                                            
            END IF                                                      
         END IF                                                         
         IF( GASMAL ) THEN                                              
!                                                                       
!           Normal case                                                 
!                                                                       
            D = FA - HA                                                 
            IF( D.EQ.FA ) THEN                                          
!                                                                       
!              Copes with infinite F or H                               
!                                                                       
               L = ONE                                                  
            ELSE                                                        
               L = D / FA                                               
            END IF                                                      
!                                                                       
!           Note that 0 .le. L .le. 1                                   
!                                                                       
            M = GT / FT                                                 
!                                                                       
!           Note that abs(M) .le. 1/macheps                             
!                                                                       
            T = TWO - L                                                 
!                                                                       
!           Note that T .ge. 1                                          
!                                                                       
            MM = M*M                                                    
            TT = T*T                                                    
            S = SQRT( TT+MM )                                           
!                                                                       
!           Note that 1 .le. S .le. 1 + 1/macheps                       
!                                                                       
            IF( L.EQ.ZERO ) THEN                                        
               R = ABS( M )                                             
            ELSE                                                        
               R = SQRT( L*L+MM )                                       
            END IF                                                      
!                                                                       
!           Note that 0 .le. R .le. 1 + 1/macheps                       
!                                                                       
            A = HALF*( S+R )                                            
!                                                                       
!           Note that 1 .le. A .le. 1 + abs(M)                          
!                                                                       
            SSMIN = HA / A                                              
            SSMAX = FA*A                                                
            IF( MM.EQ.ZERO ) THEN                                       
!                                                                       
!              Note that M is very tiny                                 
!                                                                       
               IF( L.EQ.ZERO ) THEN                                     
                  T = SIGN( TWO, FT )*SIGN( ONE, GT )                   
               ELSE                                                     
                  T = GT / SIGN( D, FT ) + M / T                        
               END IF                                                   
            ELSE                                                        
               T = ( M / ( S+T )+M / ( R+L ) )*( ONE+A )                
            END IF                                                      
            L = SQRT( T*T+FOUR )                                        
            CRT = TWO / L                                               
            SRT = T / L                                                 
            CLT = ( CRT+SRT*M ) / A                                     
            SLT = ( HT / FT )*SRT / A                                   
         END IF                                                         
      END IF                                                            
      IF( SWAP ) THEN                                                   
         CSL = SRT                                                      
         SNL = CRT                                                      
         CSR = SLT                                                      
         SNR = CLT                                                      
      ELSE                                                              
         CSL = CLT                                                      
         SNL = SLT                                                      
         CSR = CRT                                                      
         SNR = SRT                                                      
      END IF                                                            
!                                                                       
!     Correct signs of SSMAX and SSMIN                                  
!                                                                       
      IF( PMAX.EQ.1 )                                                     &
         TSIGN = SIGN( ONE, CSR )*SIGN( ONE, CSL )*SIGN( ONE, F )       
      IF( PMAX.EQ.2 )                                                     &
         TSIGN = SIGN( ONE, SNR )*SIGN( ONE, CSL )*SIGN( ONE, G )       
      IF( PMAX.EQ.3 )                                                     &
         TSIGN = SIGN( ONE, SNR )*SIGN( ONE, SNL )*SIGN( ONE, H )       
      SSMAX = SIGN( SSMAX, TSIGN )                                      
      SSMIN = SIGN( SSMIN, TSIGN*SIGN( ONE, F )*SIGN( ONE, H ) )        
      RETURN                                                            
!                                                                       
!     End of CSVD_SLASV2                                                     
!                                                                       
      END SUBROUTINE CSVD_SLASV2
                                                              
      INTEGER          FUNCTION csvd_ieeeck( ISPEC, ZERO, ONE )              
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     June 30, 1998                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            ISPEC                                          
      REAL               ONE, ZERO                                      
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  csvd_ieeeck is called from the csvd_ilaenv to verify that Infinity and
!  possibly NaN arithmetic is safe (i.e. will not trap).                
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  ISPEC   (input) INTEGER                                              
!          Specifies whether to test just for inifinity arithmetic      
!          or whether to test for infinity and NaN arithmetic.          
!          = 0: Verify infinity arithmetic only.                        
!          = 1: Verify infinity and NaN arithmetic.                     
!                                                                       
!  ZERO    (input) REAL                                                 
!          Must contain the value 0.0                                   
!          This is passed to prevent the compiler from optimizing       
!          away this code.                                              
!                                                                       
!  ONE     (input) REAL                                                 
!          Must contain the value 1.0                                   
!          This is passed to prevent the compiler from optimizing       
!          away this code.                                              
!                                                                       
!  RETURN VALUE:  INTEGER                                               
!          = 0:  Arithmetic failed to produce the correct answers       
!          = 1:  Arithmetic produced the correct answers                
!                                                                       
!     .. Local Scalars ..                                               
      REAL               NAN1, NAN2, NAN3, NAN4, NAN5, NAN6, NEGINF,      &
                         NEGZRO, NEWZRO, POSINF                         
!     ..                                                                
!     .. Executable Statements ..                                       
      csvd_ieeeck = 1                                                        
!                                                                       
      POSINF = ONE / ZERO                                               
      IF( POSINF.LE.ONE ) THEN                                          
         csvd_ieeeck = 0                                                     
         RETURN                                                         
      END IF                                                            
!                                                                       
      NEGINF = -ONE / ZERO                                              
      IF( NEGINF.GE.ZERO ) THEN                                         
         csvd_ieeeck = 0                                                     
         RETURN                                                         
      END IF                                                            
!                                                                       
      NEGZRO = ONE / ( NEGINF+ONE )                                     
      IF( NEGZRO.NE.ZERO ) THEN                                         
         csvd_ieeeck = 0                                                     
         RETURN                                                         
      END IF                                                            
!                                                                       
      NEGINF = ONE / NEGZRO                                             
      IF( NEGINF.GE.ZERO ) THEN                                         
         csvd_ieeeck = 0                                                     
         RETURN                                                         
      END IF                                                            
!                                                                       
      NEWZRO = NEGZRO + ZERO                                            
      IF( NEWZRO.NE.ZERO ) THEN                                         
         csvd_ieeeck = 0                                                     
         RETURN                                                         
      END IF                                                            
!                                                                       
      POSINF = ONE / NEWZRO                                             
      IF( POSINF.LE.ONE ) THEN                                          
         csvd_ieeeck = 0                                                     
         RETURN                                                         
      END IF                                                            
!                                                                       
      NEGINF = NEGINF*POSINF                                            
      IF( NEGINF.GE.ZERO ) THEN                                         
         csvd_ieeeck = 0                                                     
         RETURN                                                         
      END IF                                                            
!                                                                       
      POSINF = POSINF*POSINF                                            
      IF( POSINF.LE.ONE ) THEN                                          
         csvd_ieeeck = 0                                                     
         RETURN                                                         
      END IF                                                            
!                                                                       
!                                                                       
!                                                                       
!                                                                       
!     Return if we were only asked to check infinity arithmetic         
!                                                                       
      IF( ISPEC.EQ.0 )                                                    &
         RETURN                                                         
!                                                                       
      NAN1 = POSINF + NEGINF                                            
!                                                                       
      NAN2 = POSINF / NEGINF                                            
!                                                                       
      NAN3 = POSINF / POSINF                                            
!                                                                       
      NAN4 = POSINF*ZERO                                                
!                                                                       
      NAN5 = NEGINF*NEGZRO                                              
!                                                                       
      NAN6 = NAN5*0.0                                                   
!                                                                       
      IF( NAN1.EQ.NAN1 ) THEN                                           
         csvd_ieeeck = 0                                                     
         RETURN                                                         
      END IF                                                            
!                                                                       
      IF( NAN2.EQ.NAN2 ) THEN                                           
         csvd_ieeeck = 0                                                     
         RETURN                                                         
      END IF                                                            
!                                                                       
      IF( NAN3.EQ.NAN3 ) THEN                                           
         csvd_ieeeck = 0                                                     
         RETURN                                                         
      END IF                                                            
!                                                                       
      IF( NAN4.EQ.NAN4 ) THEN                                           
         csvd_ieeeck = 0                                                     
         RETURN                                                         
      END IF                                                            
!                                                                       
      IF( NAN5.EQ.NAN5 ) THEN                                           
         csvd_ieeeck = 0                                                     
         RETURN                                                         
      END IF                                                            
!                                                                       
      IF( NAN6.EQ.NAN6 ) THEN                                           
         csvd_ieeeck = 0                                                     
         RETURN                                                         
      END IF                                                            
!                                                                       
      RETURN                                                            
      END FUNCTION csvd_ieeeck 
                                                             

      INTEGER          FUNCTION csvd_ilaenv( ISPEC, NAME, OPTS, N1, N2, N3, &
                       N4 )                                             
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     June 30, 1999                                                     
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER*( * )    NAME, OPTS                                     
      INTEGER            ISPEC, N1, N2, N3, N4                          
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  csvd_ilaenv is called from the LAPACK routines to choose problem-dependent
!  parameters for the local environment.  See ISPEC for a description of
!  the parameters.                                                      
!                                                                       
!  This version provides a set of parameters which should give good,    
!  but not optimal, performance on many of the currently available      
!  computers.  Users are encouraged to modify this subroutine to set    
!  the tuning parameters for their particular machine using the option  
!  and problem size information in the arguments.                       
!                                                                       
!  This routine will not function correctly if it is converted to all   
!  lower case.  Converting it to all upper case is allowed.             
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  ISPEC   (input) INTEGER                                              
!          Specifies the parameter to be returned as the value of       
!          csvd_ilaenv.                                                      
!          = 1: the optimal blocksize; if this value is 1, an unblocked 
!               algorithm will give the best performance.               
!          = 2: the minimum block size for which the block routine      
!               should be used; if the usable block size is less than   
!               this value, an unblocked routine should be used.        
!          = 3: the crossover point (in a block routine, for N less     
!               than this value, an unblocked routine should be used)   
!          = 4: the number of shifts, used in the nonsymmetric          
!               eigenvalue routines                                     
!          = 5: the minimum column dimension for blocking to be used;   
!               rectangular blocks must have dimension at least k by m, 
!               where k is given by csvd_ilaenv(2,...) 
!               and m by csvd_ilaenv(5,...)
!          = 6: the crossover point for the SVD (when reducing an m by n
!               matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds 
!               this value, a QR factorization is used first to reduce  
!               the matrix to a triangular form.)                       
!          = 7: the number of processors                                
!          = 8: the crossover point for the multishift QR and QZ methods
!               for nonsymmetric eigenvalue problems.                   
!          = 9: maximum size of the subproblems at the bottom of the    
!               computation tree in the divide-and-conquer algorithm    
!               (used by xGELSD and xGESDD)                             
!          =10: ieee NaN arithmetic can be trusted not to trap          
!          =11: infinity arithmetic can be trusted not to trap          
!                                                                       
!  NAME    (input) CHARACTER*(*)                                        
!          The name of the calling subroutine, in either upper case or  
!          lower case.                                                  
!                                                                       
!  OPTS    (input) CHARACTER*(*)                                        
!          The character options to the subroutine NAME, concatenated   
!          into a single character string.  For example, UPLO = 'U',    
!          TRANS = 'T', and DIAG = 'N' for a triangular routine would   
!          be specified as OPTS = 'UTN'.                                
!                                                                       
!  N1      (input) INTEGER                                              
!  N2      (input) INTEGER                                              
!  N3      (input) INTEGER                                              
!  N4      (input) INTEGER                                              
!          Problem dimensions for the subroutine NAME; these may not all
!          be required.                                                 
!                                                                       
! (csvd_ilaenv) (output) INTEGER                                             
!          &gt;= 0: the value of the parameter specified by ISPEC       
!          &lt; 0:  if csvd_ilaenv = -k, the k-th argument had an illegal val
!                                                                       
!  Further Details                                                      
!  ===============                                                      
!                                                                       
!  The following conventions have been used when calling csvd_ilaenv from the
!  LAPACK routines:                                                     
!  1)  OPTS is a concatenation of all of the character options to       
!      subroutine NAME, in the same order that they appear in the       
!      argument list for NAME, even if they are not used in determining 
!      the value of the parameter specified by ISPEC.                   
!  2)  The problem dimensions N1, N2, N3, N4 are specified in the order 
!      that they appear in the argument list for NAME.  N1 is used      
!      first, N2 second, and so on, and unused problem dimensions are   
!      passed a value of -1.                                            
!  3)  The parameter value returned by csvd_ilaenv is checked for validity in
!      the calling subroutine.  For example, csvd_ilaenv is used to retrieve 
!      the optimal blocksize for STRTRI as follows:                     
!                                                                       
!      NB = csvd_ilaenv( 1, 'STRTRI', UPLO // DIAG, N, -1, -1, -1 )          
!      IF( NB.LE.1 ) NB = MAX( 1, N )                                   
!                                                                       
!  =====================================================================
!                                                                       
!     .. Local Scalars ..                                               
      LOGICAL            CNAME, SNAME                                   
      CHARACTER*1        C1                                             
      CHARACTER*2        C2, C4                                         
      CHARACTER*3        C3                                             
      CHARACTER*6        SUBNAM                                         
      INTEGER            I, IC, IZ, NB, NBMIN, NX                       
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          CHAR, ICHAR, INT, MIN, REAL                    
!     ..                                                                
!     .. External Functions ..                                          
!      INTEGER            csvd_ieeeck                                         
!      EXTERNAL           csvd_ieeeck                                         
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      GO TO ( 100, 100, 100, 400, 500, 600, 700, 800, 900, 1000,          &
              1100 ) ISPEC                                              
!                                                                       
!     Invalid value for ISPEC                                           
!                                                                       
      csvd_ilaenv = -1                                                       
      RETURN                                                            
!                                                                       
  100 CONTINUE                                                          
!                                                                       
!     Convert NAME to upper case if the first character is lower case.  
!                                                                       
      csvd_ilaenv = 1                                                        
      SUBNAM = NAME                                                     
      IC = ICHAR( SUBNAM( 1:1 ) )                                       
      IZ = ICHAR( 'Z' )                                                 
      IF( IZ.EQ.90 .OR. IZ.EQ.122 ) THEN                                
!                                                                       
!        ASCII character set                                            
!                                                                       
         IF( IC.GE.97 .AND. IC.LE.122 ) THEN                            
            SUBNAM( 1:1 ) = CHAR( IC-32 )                               
            DO 10 I = 2, 6                                              
               IC = ICHAR( SUBNAM( I:I ) )                              
               IF( IC.GE.97 .AND. IC.LE.122 )                             &
                  SUBNAM( I:I ) = CHAR( IC-32 )                         
   10       CONTINUE                                                    
         END IF                                                         
!                                                                       
      ELSE IF( IZ.EQ.233 .OR. IZ.EQ.169 ) THEN                          
!                                                                       
!        EBCDIC character set                                           
!                                                                       
         IF( ( IC.GE.129 .AND. IC.LE.137 ) .OR.                           &
             ( IC.GE.145 .AND. IC.LE.153 ) .OR.                           &
             ( IC.GE.162 .AND. IC.LE.169 ) ) THEN                       
            SUBNAM( 1:1 ) = CHAR( IC+64 )                               
            DO 20 I = 2, 6                                              
               IC = ICHAR( SUBNAM( I:I ) )                              
               IF( ( IC.GE.129 .AND. IC.LE.137 ) .OR.                     &
                   ( IC.GE.145 .AND. IC.LE.153 ) .OR.                     &
                   ( IC.GE.162 .AND. IC.LE.169 ) )                        &
                  SUBNAM( I:I ) = CHAR( IC+64 )                         
   20       CONTINUE                                                    
         END IF                                                         
!                                                                       
      ELSE IF( IZ.EQ.218 .OR. IZ.EQ.250 ) THEN                          
!                                                                       
!        Prime machines:  ASCII+128                                     
!                                                                       
         IF( IC.GE.225 .AND. IC.LE.250 ) THEN                           
            SUBNAM( 1:1 ) = CHAR( IC-32 )                               
            DO 30 I = 2, 6                                              
               IC = ICHAR( SUBNAM( I:I ) )                              
               IF( IC.GE.225 .AND. IC.LE.250 )                            &
                  SUBNAM( I:I ) = CHAR( IC-32 )                         
   30       CONTINUE                                                    
         END IF                                                         
      END IF                                                            
!                                                                       
      C1 = SUBNAM( 1:1 )                                                
      SNAME = C1.EQ.'S' .OR. C1.EQ.'D'                                  
      CNAME = C1.EQ.'C' .OR. C1.EQ.'Z'                                  
      IF( .NOT.( CNAME .OR. SNAME ) )                                     &
         RETURN                                                         
      C2 = SUBNAM( 2:3 )                                                
      C3 = SUBNAM( 4:6 )                                                
      C4 = C3( 2:3 )                                                    
!                                                                       
      GO TO ( 110, 200, 300 ) ISPEC                                     
!                                                                       
  110 CONTINUE                                                          
!                                                                       
!     ISPEC = 1:  block size                                            
!                                                                       
!     In these examples, separate code is provided for setting NB for   
!     real and complex.  We assume that NB will take the same value in  
!     single or double precision.                                       
!                                                                       
      NB = 1                                                            
!                                                                       
      IF( C2.EQ.'GE' ) THEN                                             
         IF( C3.EQ.'TRF' ) THEN                                         
            IF( SNAME ) THEN                                            
               NB = 64                                                  
            ELSE                                                        
               NB = 64                                                  
            END IF                                                      
         ELSE IF( C3.EQ.'QRF' .OR. C3.EQ.'RQF' .OR. C3.EQ.'LQF' .OR.      &
                  C3.EQ.'QLF' ) THEN                                    
            IF( SNAME ) THEN                                            
               NB = 32                                                  
            ELSE                                                        
               NB = 32                                                  
            END IF                                                      
         ELSE IF( C3.EQ.'HRD' ) THEN                                    
            IF( SNAME ) THEN                                            
               NB = 32                                                  
            ELSE                                                        
               NB = 32                                                  
            END IF                                                      
         ELSE IF( C3.EQ.'BRD' ) THEN                                    
            IF( SNAME ) THEN                                            
               NB = 32                                                  
            ELSE                                                        
               NB = 32                                                  
            END IF                                                      
         ELSE IF( C3.EQ.'TRI' ) THEN                                    
            IF( SNAME ) THEN                                            
               NB = 64                                                  
            ELSE                                                        
               NB = 64                                                  
            END IF                                                      
         END IF                                                         
      ELSE IF( C2.EQ.'PO' ) THEN                                        
         IF( C3.EQ.'TRF' ) THEN                                         
            IF( SNAME ) THEN                                            
               NB = 64                                                  
            ELSE                                                        
               NB = 64                                                  
            END IF                                                      
         END IF                                                         
      ELSE IF( C2.EQ.'SY' ) THEN                                        
         IF( C3.EQ.'TRF' ) THEN                                         
            IF( SNAME ) THEN                                            
               NB = 64                                                  
            ELSE                                                        
               NB = 64                                                  
            END IF                                                      
         ELSE IF( SNAME .AND. C3.EQ.'TRD' ) THEN                        
            NB = 32                                                     
         ELSE IF( SNAME .AND. C3.EQ.'GST' ) THEN                        
            NB = 64                                                     
         END IF                                                         
      ELSE IF( CNAME .AND. C2.EQ.'HE' ) THEN                            
         IF( C3.EQ.'TRF' ) THEN                                         
            NB = 64                                                     
         ELSE IF( C3.EQ.'TRD' ) THEN                                    
            NB = 32                                                     
         ELSE IF( C3.EQ.'GST' ) THEN                                    
            NB = 64                                                     
         END IF                                                         
      ELSE IF( SNAME .AND. C2.EQ.'OR' ) THEN                            
         IF( C3( 1:1 ).EQ.'G' ) THEN                                    
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.           &
                C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.           &
                C4.EQ.'BR' ) THEN                                       
               NB = 32                                                  
            END IF                                                      
         ELSE IF( C3( 1:1 ).EQ.'M' ) THEN                               
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.           &
                C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.           &
                C4.EQ.'BR' ) THEN                                       
               NB = 32                                                  
            END IF                                                      
         END IF                                                         
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN                            
         IF( C3( 1:1 ).EQ.'G' ) THEN                                    
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.           &
                C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.           &
                C4.EQ.'BR' ) THEN                                       
               NB = 32                                                  
            END IF                                                      
         ELSE IF( C3( 1:1 ).EQ.'M' ) THEN                               
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.           &
                C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.           &
                C4.EQ.'BR' ) THEN                                       
               NB = 32                                                  
            END IF                                                      
         END IF                                                         
      ELSE IF( C2.EQ.'GB' ) THEN                                        
         IF( C3.EQ.'TRF' ) THEN                                         
            IF( SNAME ) THEN                                            
               IF( N4.LE.64 ) THEN                                      
                  NB = 1                                                
               ELSE                                                     
                  NB = 32                                               
               END IF                                                   
            ELSE                                                        
               IF( N4.LE.64 ) THEN                                      
                  NB = 1                                                
               ELSE                                                     
                  NB = 32                                               
               END IF                                                   
            END IF                                                      
         END IF                                                         
      ELSE IF( C2.EQ.'PB' ) THEN                                        
         IF( C3.EQ.'TRF' ) THEN                                         
            IF( SNAME ) THEN                                            
               IF( N2.LE.64 ) THEN                                      
                  NB = 1                                                
               ELSE                                                     
                  NB = 32                                               
               END IF                                                   
            ELSE                                                        
               IF( N2.LE.64 ) THEN                                      
                  NB = 1                                                
               ELSE                                                     
                  NB = 32                                               
               END IF                                                   
            END IF                                                      
         END IF                                                         
      ELSE IF( C2.EQ.'TR' ) THEN                                        
         IF( C3.EQ.'TRI' ) THEN                                         
            IF( SNAME ) THEN                                            
               NB = 64                                                  
            ELSE                                                        
               NB = 64                                                  
            END IF                                                      
         END IF                                                         
      ELSE IF( C2.EQ.'LA' ) THEN                                        
         IF( C3.EQ.'UUM' ) THEN                                         
            IF( SNAME ) THEN                                            
               NB = 64                                                  
            ELSE                                                        
               NB = 64                                                  
            END IF                                                      
         END IF                                                         
      ELSE IF( SNAME .AND. C2.EQ.'ST' ) THEN                            
         IF( C3.EQ.'EBZ' ) THEN                                         
            NB = 1                                                      
         END IF                                                         
      END IF                                                            
      csvd_ilaenv = NB                                                       
      RETURN                                                            
!                                                                       
  200 CONTINUE                                                          
!                                                                       
!     ISPEC = 2:  minimum block size                                    
!                                                                       
      NBMIN = 2                                                         
      IF( C2.EQ.'GE' ) THEN                                             
         IF( C3.EQ.'QRF' .OR. C3.EQ.'RQF' .OR. C3.EQ.'LQF' .OR.           &
             C3.EQ.'QLF' ) THEN                                         
            IF( SNAME ) THEN                                            
               NBMIN = 2                                                
            ELSE                                                        
               NBMIN = 2                                                
            END IF                                                      
         ELSE IF( C3.EQ.'HRD' ) THEN                                    
            IF( SNAME ) THEN                                            
               NBMIN = 2                                                
            ELSE                                                        
               NBMIN = 2                                                
            END IF                                                      
         ELSE IF( C3.EQ.'BRD' ) THEN                                    
            IF( SNAME ) THEN                                            
               NBMIN = 2                                                
            ELSE                                                        
               NBMIN = 2                                                
            END IF                                                      
         ELSE IF( C3.EQ.'TRI' ) THEN                                    
            IF( SNAME ) THEN                                            
               NBMIN = 2                                                
            ELSE                                                        
               NBMIN = 2                                                
            END IF                                                      
         END IF                                                         
      ELSE IF( C2.EQ.'SY' ) THEN                                        
         IF( C3.EQ.'TRF' ) THEN                                         
            IF( SNAME ) THEN                                            
               NBMIN = 8                                                
            ELSE                                                        
               NBMIN = 8                                                
            END IF                                                      
         ELSE IF( SNAME .AND. C3.EQ.'TRD' ) THEN                        
            NBMIN = 2                                                   
         END IF                                                         
      ELSE IF( CNAME .AND. C2.EQ.'HE' ) THEN                            
         IF( C3.EQ.'TRD' ) THEN                                         
            NBMIN = 2                                                   
         END IF                                                         
      ELSE IF( SNAME .AND. C2.EQ.'OR' ) THEN                            
         IF( C3( 1:1 ).EQ.'G' ) THEN                                    
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.           &
                C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.           &
                C4.EQ.'BR' ) THEN                                       
               NBMIN = 2                                                
            END IF                                                      
         ELSE IF( C3( 1:1 ).EQ.'M' ) THEN                               
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.           &
                C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.           &
                C4.EQ.'BR' ) THEN                                       
               NBMIN = 2                                                
            END IF                                                      
         END IF                                                         
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN                            
         IF( C3( 1:1 ).EQ.'G' ) THEN                                    
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.           &
                C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.           &
                C4.EQ.'BR' ) THEN                                       
               NBMIN = 2                                                
            END IF                                                      
         ELSE IF( C3( 1:1 ).EQ.'M' ) THEN                               
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.           &
                C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.           &
                C4.EQ.'BR' ) THEN                                       
               NBMIN = 2                                                
            END IF                                                      
         END IF                                                         
      END IF                                                            
      csvd_ilaenv = NBMIN                                                    
      RETURN                                                            
!                                                                       
  300 CONTINUE                                                          
!                                                                       
!     ISPEC = 3:  crossover point                                       
!                                                                       
      NX = 0                                                            
      IF( C2.EQ.'GE' ) THEN                                             
         IF( C3.EQ.'QRF' .OR. C3.EQ.'RQF' .OR. C3.EQ.'LQF' .OR.           &
             C3.EQ.'QLF' ) THEN                                         
            IF( SNAME ) THEN                                            
               NX = 128                                                 
            ELSE                                                        
               NX = 128                                                 
            END IF                                                      
         ELSE IF( C3.EQ.'HRD' ) THEN                                    
            IF( SNAME ) THEN                                            
               NX = 128                                                 
            ELSE                                                        
               NX = 128                                                 
            END IF                                                      
         ELSE IF( C3.EQ.'BRD' ) THEN                                    
            IF( SNAME ) THEN                                            
               NX = 128                                                 
            ELSE                                                        
               NX = 128                                                 
            END IF                                                      
         END IF                                                         
      ELSE IF( C2.EQ.'SY' ) THEN                                        
         IF( SNAME .AND. C3.EQ.'TRD' ) THEN                             
            NX = 32                                                     
         END IF                                                         
      ELSE IF( CNAME .AND. C2.EQ.'HE' ) THEN                            
         IF( C3.EQ.'TRD' ) THEN                                         
            NX = 32                                                     
         END IF                                                         
      ELSE IF( SNAME .AND. C2.EQ.'OR' ) THEN                            
         IF( C3( 1:1 ).EQ.'G' ) THEN                                    
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.           &
                C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.           &
                C4.EQ.'BR' ) THEN                                       
               NX = 128                                                 
            END IF                                                      
         END IF                                                         
      ELSE IF( CNAME .AND. C2.EQ.'UN' ) THEN                            
         IF( C3( 1:1 ).EQ.'G' ) THEN                                    
            IF( C4.EQ.'QR' .OR. C4.EQ.'RQ' .OR. C4.EQ.'LQ' .OR.           &
                C4.EQ.'QL' .OR. C4.EQ.'HR' .OR. C4.EQ.'TR' .OR.           &
                C4.EQ.'BR' ) THEN                                       
               NX = 128                                                 
            END IF                                                      
         END IF                                                         
      END IF                                                            
      csvd_ilaenv = NX                                                       
      RETURN                                                            
!                                                                       
  400 CONTINUE                                                          
!                                                                       
!     ISPEC = 4:  number of shifts (used by xHSEQR)                     
!                                                                       
      csvd_ilaenv = 6                                                        
      RETURN                                                            
!                                                                       
  500 CONTINUE                                                          
!                                                                       
!     ISPEC = 5:  minimum column dimension (not used)                   
!                                                                       
      csvd_ilaenv = 2                                                        
      RETURN                                                            
!                                                                       
  600 CONTINUE                                                          
!                                                                       
!     ISPEC = 6:  crossover point for SVD (used by xGELSS and xGESVD)   
!                                                                       
      csvd_ilaenv = INT( REAL( MIN( N1, N2 ) )*1.6E0 )                       
      RETURN                                                            
!                                                                       
  700 CONTINUE                                                          
!                                                                       
!     ISPEC = 7:  number of processors (not used)                       
!                                                                       
      csvd_ilaenv = 1                                                        
      RETURN                                                            
!                                                                       
  800 CONTINUE                                                          
!                                                                       
!     ISPEC = 8:  crossover point for multishift (used by xHSEQR)       
!                                                                       
      csvd_ilaenv = 50                                                       
      RETURN                                                            
!                                                                       
  900 CONTINUE                                                          
!                                                                       
!     ISPEC = 9:  maximum size of the subproblems at the bottom of the  
!                 computation tree in the divide-and-conquer algorithm  
!                 (used by xGELSD and xGESDD)                           
!                                                                       
      csvd_ilaenv = 25                                                       
      RETURN                                                            
!                                                                       
 1000 CONTINUE                                                          
!                                                                       
!     ISPEC = 10: ieee NaN arithmetic can be trusted not to trap        
!                                                                       
!     csvd_ilaenv = 0                                                        
      csvd_ilaenv = 1                                                        
      IF( csvd_ilaenv.EQ.1 ) THEN                                            
         csvd_ilaenv = csvd_ieeeck( 0, 0.0, 1.0 )
      END IF                                                            
      RETURN                                                            
!                                                                       
 1100 CONTINUE                                                          
!                                                                       
!     ISPEC = 11: infinity arithmetic can be trusted not to trap        
!                                                                       
!     csvd_ilaenv = 0                                                        
      csvd_ilaenv = 1                                                        
      IF( csvd_ilaenv.EQ.1 ) THEN                                            
         csvd_ilaenv = csvd_ieeeck( 1, 0.0, 1.0 )
      END IF                                                            
      RETURN                                                            
!                                                                       
!     End of csvd_ilaenv                                                     
!                                                                       
      END FUNCTION csvd_ilaenv
                                                              
      LOGICAL          FUNCTION csvd_lsame( CA, CB )                         
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     September 30, 1994                                                
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          CA, CB                                         
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  csvd_lsame returns .TRUE. if CA is the same letter as CB regardless of    
!  case.                                                                
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  CA      (input) CHARACTER*1                                          
!  CB      (input) CHARACTER*1                                          
!          CA and CB specify the single characters to be compared.      
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ICHAR                                          
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            INTA, INTB, ZCODE                              
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test if the characters are equal                                  
!                                                                       
      csvd_lsame = CA.EQ.CB                                                  
      IF( csvd_lsame )                                                 &
         RETURN                                                         
!                                                                       
!     Now test for equivalence if both characters are alphabetic.       
!                                                                       
      ZCODE = ICHAR( 'Z' )                                              
!                                                                       
!     Use 'Z' rather than 'A' so that ASCII can be detected on Prime    
!     machines, on which ICHAR returns a value with bit 8 set.          
!     ICHAR('A') on Prime machines returns 193 which is the same as     
!     ICHAR('A') on an EBCDIC machine.                                  
!                                                                       
      INTA = ICHAR( CA )                                                
      INTB = ICHAR( CB )                                                
!                                                                       
      IF( ZCODE.EQ.90 .OR. ZCODE.EQ.122 ) THEN                          
!                                                                       
!        ASCII is assumed - ZCODE is the ASCII code of either lower or  
!        upper case 'Z'.                                                
!                                                                       
         IF( INTA.GE.97 .AND. INTA.LE.122 ) INTA = INTA - 32            
         IF( INTB.GE.97 .AND. INTB.LE.122 ) INTB = INTB - 32            
!                                                                       
      ELSE IF( ZCODE.EQ.233 .OR. ZCODE.EQ.169 ) THEN                    
!                                                                       
!        EBCDIC is assumed - ZCODE is the EBCDIC code of either lower or
!        upper case 'Z'.                                                
!                                                                       
         IF( INTA.GE.129 .AND. INTA.LE.137 .OR.                           &
             INTA.GE.145 .AND. INTA.LE.153 .OR.                           &
             INTA.GE.162 .AND. INTA.LE.169 ) INTA = INTA + 64           
         IF( INTB.GE.129 .AND. INTB.LE.137 .OR.                           &
             INTB.GE.145 .AND. INTB.LE.153 .OR.                           &
             INTB.GE.162 .AND. INTB.LE.169 ) INTB = INTB + 64           
!                                                                       
      ELSE IF( ZCODE.EQ.218 .OR. ZCODE.EQ.250 ) THEN                    
!                                                                       
!        ASCII is assumed, on Prime machines - ZCODE is the ASCII code  
!        plus 128 of either lower or upper case 'Z'.                    
!                                                                       
         IF( INTA.GE.225 .AND. INTA.LE.250 ) INTA = INTA - 32           
         IF( INTB.GE.225 .AND. INTB.LE.250 ) INTB = INTB - 32           
      END IF                                                            
      csvd_lsame = INTA.EQ.INTB                                              
!                                                                       
!     RETURN                                                            
!                                                                       
!     End of csvd_lsame                                                      
!                                                                       
      END FUNCTION csvd_lsame
                                                              
      REAL             FUNCTION csvd_slamch( CMACH )                         
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     October 31, 1992                                                  
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER          CMACH                                          
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  csvd_slamch determines single precision machine parameters.               
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  CMACH   (input) CHARACTER*1                                          
!          Specifies the value to be returned by csvd_slamch:                
!          = 'E' or 'e',   csvd_slamch := eps                                
!          = 'S' or 's ,   csvd_slamch := sfmin                              
!          = 'B' or 'b',   csvd_slamch := base                               
!          = 'P' or 'p',   csvd_slamch := eps*base                           
!          = 'N' or 'n',   csvd_slamch := t                                  
!          = 'R' or 'r',   csvd_slamch := rnd                                
!          = 'M' or 'm',   csvd_slamch := emin                               
!          = 'U' or 'u',   csvd_slamch := rmin                               
!          = 'L' or 'l',   csvd_slamch := emax                               
!          = 'O' or 'o',   csvd_slamch := rmax                               
!                                                                       
!          where                                                        
!                                                                       
!          eps   = relative machine precision                           
!          sfmin = safe minimum, such that 1/sfmin does not overflow    
!          base  = base of the machine                                  
!          prec  = eps*base                                             
!          t     = number of (base) digits in the mantissa              
!          rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise  
!          emin  = minimum exponent before (gradual) underflow          
!          rmin  = underflow threshold - base**(emin-1)                 
!          emax  = largest exponent before overflow                     
!          rmax  = overflow threshold  - (base**emax)*(1-eps)           
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      REAL               ONE, ZERO                                      
      PARAMETER          ( ONE = 1.0E+0, ZERO = 0.0E+0 )                
!     ..                                                                
!     .. Local Scalars ..                                               
      LOGICAL            FIRST, LRND                                    
      INTEGER            BETA, IMAX, IMIN, IT                           
      REAL               BASE, EMAX, EMIN, EPS, PREC, RMACH, RMAX, RMIN,  &
                         RND, SFMIN, SMALL, T                           
!     ..                                                                
!     .. External Functions ..                                          
!      LOGICAL            csvd_lsame                                          
!      EXTERNAL           csvd_lsame                                          
!     ..                                                                
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_SLAMC2                                         
!     ..                                                                
!     .. Save statement ..                                              
      SAVE               FIRST, EPS, SFMIN, BASE, T, RND, EMIN, RMIN,     &
                         EMAX, RMAX, PREC                               
!     ..                                                                
!     .. Data statements ..                                             
      DATA               FIRST / .TRUE. /                               
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( FIRST ) THEN                                                  
         FIRST = .FALSE.                                                
         CALL CSVD_SLAMC2( BETA, IT, LRND, EPS, IMIN, RMIN, IMAX, RMAX )     
         BASE = BETA                                                    
         T = IT                                                         
         IF( LRND ) THEN                                                
            RND = ONE                                                   
            EPS = ( BASE**( 1-IT ) ) / 2                                
         ELSE                                                           
            RND = ZERO                                                  
            EPS = BASE**( 1-IT )                                        
         END IF                                                         
         PREC = EPS*BASE                                                
         EMIN = IMIN                                                    
         EMAX = IMAX                                                    
         SFMIN = RMIN                                                   
         SMALL = ONE / RMAX                                             
         IF( SMALL.GE.SFMIN ) THEN                                      
!                                                                       
!           Use SMALL plus a bit, to avoid the possibility of rounding  
!           causing overflow when computing  1/sfmin.                   
!                                                                       
            SFMIN = SMALL*( ONE+EPS )                                   
         END IF                                                         
      END IF                                                            
!                                                                       
      IF( csvd_lsame( CMACH, 'E' ) ) THEN                                    
         RMACH = EPS                                                    
      ELSE IF( csvd_lsame( CMACH, 'S' ) ) THEN                               
         RMACH = SFMIN                                                  
      ELSE IF( csvd_lsame( CMACH, 'B' ) ) THEN                               
         RMACH = BASE                                                   
      ELSE IF( csvd_lsame( CMACH, 'P' ) ) THEN                               
         RMACH = PREC                                                   
      ELSE IF( csvd_lsame( CMACH, 'N' ) ) THEN                               
         RMACH = T                                                      
      ELSE IF( csvd_lsame( CMACH, 'R' ) ) THEN                               
         RMACH = RND                                                    
      ELSE IF( csvd_lsame( CMACH, 'M' ) ) THEN                               
         RMACH = EMIN                                                   
      ELSE IF( csvd_lsame( CMACH, 'U' ) ) THEN                               
         RMACH = RMIN                                                   
      ELSE IF( csvd_lsame( CMACH, 'L' ) ) THEN                               
         RMACH = EMAX                                                   
      ELSE IF( csvd_lsame( CMACH, 'O' ) ) THEN                               
         RMACH = RMAX                                                   
      END IF                                                            
!                                                                       
      csvd_slamch = RMACH 
      RETURN                                                            
!                                                                       
!     End of csvd_slamch
!                                                                       
      END FUNCTION csvd_slamch
!                                                                       
!***********************************************************************
!                                                                       
      SUBROUTINE CSVD_SLAMC1( BETA, T, RND, IEEE1 )                          
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     October 31, 1992                                                  
!                                                                       
!     .. Scalar Arguments ..                                            
      LOGICAL            IEEE1, RND                                     
      INTEGER            BETA, T                                        
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_SLAMC1 determines the machine parameters given by BETA, T, RND, and  
!  IEEE1.                                                               
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  BETA    (output) INTEGER                                             
!          The base of the machine.                                     
!                                                                       
!  T       (output) INTEGER                                             
!          The number of ( BETA ) digits in the mantissa.               
!                                                                       
!  RND     (output) LOGICAL                                             
!          Specifies whether proper rounding  ( RND = .TRUE. )  or      
!          chopping  ( RND = .FALSE. )  occurs in addition. This may not
!          be a reliable guide to the way in which the machine performs 
!          its arithmetic.                                              
!                                                                       
!  IEEE1   (output) LOGICAL                                             
!          Specifies whether rounding appears to be done in the IEEE    
!          'round to nearest' style.                                    
!                                                                       
!  Further Details                                                      
!  ===============                                                      
!                                                                       
!  The routine is based on the routine  ENVRON  by Malcolm and          
!  incorporates suggestions by Gentleman and Marovich. See              
!                                                                       
!     Malcolm M. A. (1972) Algorithms to reveal properties of           
!        floating-point arithmetic. Comms. of the ACM, 15, 949-951.     
!                                                                       
!     Gentleman W. M. and Marovich S. B. (1974) More on algorithms      
!        that reveal properties of floating point arithmetic units.     
!        Comms. of the ACM, 17, 276-277.                                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Local Scalars ..                                               
      LOGICAL            FIRST, LIEEE1, LRND                            
      INTEGER            LBETA, LT                                      
      REAL               A, B, C, F, ONE, QTR, SAVEC, T1, T2            
!     ..                                                                
!     .. External Functions ..                                          
!      REAL               csvd_slamc3                                         
!      EXTERNAL           csvd_slamc3                                         
!     ..                                                                
!     .. Save statement ..                                              
      SAVE               FIRST, LIEEE1, LBETA, LRND, LT                 
!     ..                                                                
!     .. Data statements ..                                             
      DATA               FIRST / .TRUE. /                               
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( FIRST ) THEN                                                  
         FIRST = .FALSE.                                                
         ONE = 1                                                        
!                                                                       
!        LBETA,  LIEEE1,  LT and  LRND  are the  local values  of  BETA,
!        IEEE1, T and RND.                                              
!                                                                       
!        Throughout this routine  we use the function  csvd_slamc3  to ensure
!        that relevant values are  stored and not held in registers,  or
!        are not affected by optimizers.                                
!                                                                       
!        Compute  a = 2.0**m  with the  smallest positive integer m such
!        that                                                           
!                                                                       
!           fl( a + 1.0 ) = a.                                          
!                                                                       
         A = 1                                                          
         C = 1                                                          
!                                                                       
!+       WHILE( C.EQ.ONE )LOOP                                          
   10    CONTINUE                                                       
         IF( C.EQ.ONE ) THEN                                            
            A = 2*A                                                     
            C = csvd_slamc3( A, ONE )                                        
            C = csvd_slamc3( C, -A )                                         
            GO TO 10                                                    
         END IF                                                         
!+       END WHILE                                                      
!                                                                       
!        Now compute  b = 2.0**m  with the smallest positive integer m  
!        such that                                                      
!                                                                       
!           fl( a + b ) .gt. a.                                         
!                                                                       
         B = 1                                                          
         C = csvd_slamc3( A, B )                                             
!                                                                       
!+       WHILE( C.EQ.A )LOOP                                            
   20    CONTINUE                                                       
         IF( C.EQ.A ) THEN                                              
            B = 2*B                                                     
            C = csvd_slamc3( A, B )                                          
            GO TO 20                                                    
         END IF                                                         
!+       END WHILE                                                      
!                                                                       
!        Now compute the base.  a and c  are neighbouring floating point
!        numbers  in the  interval  ( beta**t, beta**( t + 1 ) )  and so
!        their difference is beta. Adding 0.25 to c is to ensure that it
!        is truncated to beta and not ( beta - 1 ).                     
!                                                                       
         QTR = ONE / 4                                                  
         SAVEC = C                                                      
         C = csvd_slamc3( C, -A )                                            
         LBETA = C + QTR                                                
!                                                                       
!        Now determine whether rounding or chopping occurs,  by adding a
!        bit  less  than  beta/2  and a  bit  more  than  beta/2  to  a.
!                                                                       
         B = LBETA                                                      
         F = csvd_slamc3( B / 2, -B / 100 )                                  
         C = csvd_slamc3( F, A )                                             
         IF( C.EQ.A ) THEN                                              
            LRND = .TRUE.                                               
         ELSE                                                           
            LRND = .FALSE.                                              
         END IF                                                         
         F = csvd_slamc3( B / 2, B / 100 )                                   
         C = csvd_slamc3( F, A )                                             
         IF( ( LRND ) .AND. ( C.EQ.A ) )                                  &
            LRND = .FALSE.                                              
!                                                                       
!        Try and decide whether rounding is done in the  IEEE  'round to
!        nearest' style. B/2 is half a unit in the last place of the two
!        numbers A and SAVEC. Furthermore, A is even, i.e. has last  bit
!        zero, and SAVEC is odd. Thus adding B/2 to A should not  change
!        A, but adding B/2 to SAVEC should change SAVEC.                
!                                                                       
         T1 = csvd_slamc3( B / 2, A )                                        
         T2 = csvd_slamc3( B / 2, SAVEC )                                    
         LIEEE1 = ( T1.EQ.A ) .AND. ( T2.GT.SAVEC ) .AND. LRND          
!                                                                       
!        Now find  the  mantissa, t.  It should  be the  integer part of
!        log to the base beta of a,  however it is safer to determine  t
!        by powering.  So we find t as the smallest positive integer for
!        which                                                          
!                                                                       
!           fl( beta**t + 1.0 ) = 1.0.                                  
!                                                                       
         LT = 0                                                         
         A = 1                                                          
         C = 1                                                          
!                                                                       
!+       WHILE( C.EQ.ONE )LOOP                                          
   30    CONTINUE                                                       
         IF( C.EQ.ONE ) THEN                                            
            LT = LT + 1                                                 
            A = A*LBETA                                                 
            C = csvd_slamc3( A, ONE )                                        
            C = csvd_slamc3( C, -A )                                         
            GO TO 30                                                    
         END IF                                                         
!+       END WHILE                                                      
!                                                                       
      END IF                                                            
!                                                                       
      BETA = LBETA                                                      
      T = LT                                                            
      RND = LRND                                                        
      IEEE1 = LIEEE1                                                    
      RETURN                                                            
!                                                                       
!     End of CSVD_SLAMC1                                                     
!                                                                       
      END SUBROUTINE CSVD_SLAMC1 
!                                                                       
!***********************************************************************
!                                                                       
      SUBROUTINE CSVD_SLAMC2( BETA, T, RND, EPS, EMIN, RMIN, EMAX, RMAX )    
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     October 31, 1992                                                  
!                                                                       
!     .. Scalar Arguments ..                                            
      LOGICAL            RND                                            
      INTEGER            BETA, EMAX, EMIN, T                            
      REAL               EPS, RMAX, RMIN                                
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_SLAMC2 determines the machine parameters specified in its argument   
!  list.                                                                
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  BETA    (output) INTEGER                                             
!          The base of the machine.                                     
!                                                                       
!  T       (output) INTEGER                                             
!          The number of ( BETA ) digits in the mantissa.               
!                                                                       
!  RND     (output) LOGICAL                                             
!          Specifies whether proper rounding  ( RND = .TRUE. )  or      
!          chopping  ( RND = .FALSE. )  occurs in addition. This may not
!          be a reliable guide to the way in which the machine performs 
!          its arithmetic.                                              
!                                                                       
!  EPS     (output) REAL                                                
!          The smallest positive number such that                       
!                                                                       
!             fl( 1.0 - EPS ) .LT. 1.0,                                 
!                                                                       
!          where fl denotes the computed value.                         
!                                                                       
!  EMIN    (output) INTEGER                                             
!          The minimum exponent before (gradual) underflow occurs.      
!                                                                       
!  RMIN    (output) REAL                                                
!          The smallest normalized number for the machine, given by     
!          BASE**( EMIN - 1 ), where  BASE  is the floating point value 
!          of BETA.                                                     
!                                                                       
!  EMAX    (output) INTEGER                                             
!          The maximum exponent before overflow occurs.                 
!                                                                       
!  RMAX    (output) REAL                                                
!          The largest positive number for the machine, given by        
!          BASE**EMAX * ( 1 - EPS ), where  BASE  is the floating point 
!          value of BETA.                                               
!                                                                       
!  Further Details                                                      
!  ===============                                                      
!                                                                       
!  The computation of  EPS  is based on a routine PARANOIA by           
!  W. Kahan of the University of California at Berkeley.                
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Local Scalars ..                                               
      LOGICAL            FIRST, IEEE, IWARN, LIEEE1, LRND               
      INTEGER            GNMIN, GPMIN, I, LBETA, LEMAX, LEMIN, LT,        &
                         NGNMIN, NGPMIN                                 
      REAL               A, B, C, HALF, LEPS, LRMAX, LRMIN, ONE, RBASE,   &
                         SIXTH, SMALL, THIRD, TWO, ZERO                 
!     ..                                                                
!     .. External Functions ..                                          
!      REAL               csvd_slamc3                                         
!      EXTERNAL           csvd_slamc3                                         
!     ..                                                                
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_SLAMC1, CSVD_SLAMC4, CSVD_SLAMC5
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          ABS, MAX, MIN                                  
!     ..                                                                
!     .. Save statement ..                                              
      SAVE               FIRST, IWARN, LBETA, LEMAX, LEMIN, LEPS, LRMAX,  &
                         LRMIN, LT                                      
!     ..                                                                
!     .. Data statements ..                                             
      DATA               FIRST / .TRUE. / , IWARN / .FALSE. /           
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      IF( FIRST ) THEN                                                  
         FIRST = .FALSE.                                                
         ZERO = 0                                                       
         ONE = 1                                                        
         TWO = 2                                                        
!                                                                       
!        LBETA, LT, LRND, LEPS, LEMIN and LRMIN  are the local values of
!        BETA, T, RND, EPS, EMIN and RMIN.                              
!                                                                       
!        Throughout this routine  we use the function  csvd_slamc3  to ensure
!        that relevant values are stored  and not held in registers,  or
!        are not affected by optimizers.                                
!                                                                       
!        CSVD_SLAMC1 returns the parameters  LBETA, LT, LRND and LIEEE1.     
!                                                                       
         CALL CSVD_SLAMC1( LBETA, LT, LRND, LIEEE1 )                         
!                                                                       
!        Start to find EPS.                                             
!                                                                       
         B = LBETA                                                      
         A = B**( -LT )                                                 
         LEPS = A                                                       
!                                                                       
!        Try some tricks to see whether or not this is the correct  EPS.
!                                                                       
         B = TWO / 3                                                    
         HALF = ONE / 2                                                 
         SIXTH = csvd_slamc3( B, -HALF )                                     
         THIRD = csvd_slamc3( SIXTH, SIXTH )                                 
         B = csvd_slamc3( THIRD, -HALF )                                     
         B = csvd_slamc3( B, SIXTH )                                         
         B = ABS( B )                                                   
         IF( B.LT.LEPS )                                                  &
            B = LEPS                                                    
!                                                                       
         LEPS = 1                                                       
!                                                                       
!+       WHILE( ( LEPS.GT.B ).AND.( B.GT.ZERO ) )LOOP                   
   10    CONTINUE                                                       
         IF( ( LEPS.GT.B ) .AND. ( B.GT.ZERO ) ) THEN                   
            LEPS = B                                                    
            C = csvd_slamc3( HALF*LEPS, ( TWO**5 )*( LEPS**2 ) )             
            C = csvd_slamc3( HALF, -C )                                      
            B = csvd_slamc3( HALF, C )                                       
            C = csvd_slamc3( HALF, -B )                                      
            B = csvd_slamc3( HALF, C )                                       
            GO TO 10                                                    
         END IF                                                         
!+       END WHILE                                                      
!                                                                       
         IF( A.LT.LEPS )                                                  &
            LEPS = A                                                    
!                                                                       
!        Computation of EPS complete.                                   
!                                                                       
!        Now find  EMIN.  Let A = + or - 1, and + or - (1 + BASE**(-3)).
!        Keep dividing  A by BETA until (gradual) underflow occurs. This
!        is detected when we cannot recover the previous A.             
!                                                                       
         RBASE = ONE / LBETA                                            
         SMALL = ONE                                                    
         DO 20 I = 1, 3                                                 
            SMALL = csvd_slamc3( SMALL*RBASE, ZERO )                         
   20    CONTINUE                                                       
         A = csvd_slamc3( ONE, SMALL )                                       
         CALL CSVD_SLAMC4( NGPMIN, ONE, LBETA )                              
         CALL CSVD_SLAMC4( NGNMIN, -ONE, LBETA )                             
         CALL CSVD_SLAMC4( GPMIN, A, LBETA )                                 
         CALL CSVD_SLAMC4( GNMIN, -A, LBETA )                                
         IEEE = .FALSE.                                                 
!                                                                       
         IF( ( NGPMIN.EQ.NGNMIN ) .AND. ( GPMIN.EQ.GNMIN ) ) THEN       
            IF( NGPMIN.EQ.GPMIN ) THEN                                  
               LEMIN = NGPMIN                                           
!            ( Non twos-complement machines, no gradual underflow;      
!              e.g.,  VAX )                                             
            ELSE IF( ( GPMIN-NGPMIN ).EQ.3 ) THEN                       
               LEMIN = NGPMIN - 1 + LT                                  
               IEEE = .TRUE.                                            
!            ( Non twos-complement machines, with gradual underflow;    
!              e.g., IEEE standard followers )                          
            ELSE                                                        
               LEMIN = MIN( NGPMIN, GPMIN )                             
!            ( A guess; no known machine )                              
               IWARN = .TRUE.                                           
            END IF                                                      
!                                                                       
         ELSE IF( ( NGPMIN.EQ.GPMIN ) .AND. ( NGNMIN.EQ.GNMIN ) ) THEN  
            IF( ABS( NGPMIN-NGNMIN ).EQ.1 ) THEN                        
               LEMIN = MAX( NGPMIN, NGNMIN )                            
!            ( Twos-complement machines, no gradual underflow;          
!              e.g., CYBER 205 )                                        
            ELSE                                                        
               LEMIN = MIN( NGPMIN, NGNMIN )                            
!            ( A guess; no known machine )                              
               IWARN = .TRUE.                                           
            END IF                                                      
!                                                                       
         ELSE IF( ( ABS( NGPMIN-NGNMIN ).EQ.1 ) .AND.                     &
                  ( GPMIN.EQ.GNMIN ) ) THEN                             
            IF( ( GPMIN-MIN( NGPMIN, NGNMIN ) ).EQ.3 ) THEN             
               LEMIN = MAX( NGPMIN, NGNMIN ) - 1 + LT                   
!            ( Twos-complement machines with gradual underflow;         
!              no known machine )                                       
            ELSE                                                        
               LEMIN = MIN( NGPMIN, NGNMIN )                            
!            ( A guess; no known machine )                              
               IWARN = .TRUE.                                           
            END IF                                                      
!                                                                       
         ELSE                                                           
            LEMIN = MIN( NGPMIN, NGNMIN, GPMIN, GNMIN )                 
!         ( A guess; no known machine )                                 
            IWARN = .TRUE.                                              
         END IF                                                         
!**                                                                     
! Comment out this if block if EMIN is ok                               
         IF( IWARN ) THEN                                               
            FIRST = .TRUE.                                              
            WRITE( 6, FMT = 9999 )LEMIN                                 
         END IF                                                         
!**                                                                     
!                                                                       
!        Assume IEEE arithmetic if we found denormalised  numbers above,
!        or if arithmetic seems to round in the  IEEE style,  determined
!        in routine CSVD_SLAMC1. A true IEEE machine should have both  things
!        true; however, faulty machines may have one or the other.      
!                                                                       
         IEEE = IEEE .OR. LIEEE1                                        
!                                                                       
!        Compute  RMIN by successive division by  BETA. We could compute
!        RMIN as BASE**( EMIN - 1 ),  but some machines underflow during
!        this computation.                                              
!                                                                       
         LRMIN = 1                                                      
         DO 30 I = 1, 1 - LEMIN                                         
            LRMIN = csvd_slamc3( LRMIN*RBASE, ZERO )                         
   30    CONTINUE                                                       
!                                                                       
!        Finally, call CSVD_SLAMC5 to compute EMAX and RMAX.                 
!                                                                       
         CALL CSVD_SLAMC5( LBETA, LT, LEMIN, IEEE, LEMAX, LRMAX )            
      END IF                                                            
!                                                                       
      BETA = LBETA                                                      
      T = LT                                                            
      RND = LRND                                                        
      EPS = LEPS                                                        
      EMIN = LEMIN                                                      
      RMIN = LRMIN                                                      
      EMAX = LEMAX                                                      
      RMAX = LRMAX                                                      
!                                                                       
      RETURN                                                            
!                                                                       
 9999 FORMAT( / / ' WARNING. The value EMIN may be incorrect:-',          &
            '  EMIN = ', I8, /                                            &
            ' If, after inspection, the value EMIN looks',                &
            ' acceptable please comment out ',                            &
            / ' the IF block as marked within the code of routine',       &
            ' CSVD_SLAMC2,', / ' otherwise supply EMIN explicitly.', / )     
!                                                                       
!     End of CSVD_SLAMC2                                                     
!                                                                       
      END SUBROUTINE CSVD_SLAMC2 
!                                                                       
!***********************************************************************
!                                                                       
      REAL             FUNCTION csvd_slamc3( A, B )                          
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     October 31, 1992                                                  
!                                                                       
!     .. Scalar Arguments ..                                            
      REAL               A, B                                           
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  csvd_slamc3  is intended to force  A  and  B  to be stored prior to doing 
!  the addition of  A  and  B ,  for use in situations where optimizers 
!  might hold one of these in a register.                               
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  A, B    (input) REAL                                                 
!          The values A and B.                                          
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Executable Statements ..                                       
!                                                                       
      csvd_slamc3 = A + B                                                    
!                                                                       
      RETURN                                                            
!                                                                       
!     End of csvd_slamc3                                                     
!                                                                       
      END FUNCTION csvd_slamc3
!                                                                       
!***********************************************************************
!                                                                       
      SUBROUTINE CSVD_SLAMC4( EMIN, START, BASE )                            
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     October 31, 1992                                                  
!                                                                       
!     .. Scalar Arguments ..                                            
      INTEGER            BASE, EMIN                                     
      REAL               START                                          
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_SLAMC4 is a service routine for CSVD_SLAMC2.
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  EMIN    (output) EMIN                                                
!          The minimum exponent before (gradual) underflow, computed by 
!          setting A = START and dividing by BASE until the previous A  
!          can not be recovered.                                        
!                                                                       
!  START   (input) REAL                                                 
!          The starting point for determining EMIN.                     
!                                                                       
!  BASE    (input) INTEGER                                              
!          The base of the machine.                                     
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Local Scalars ..                                               
      INTEGER            I                                              
      REAL               A, B1, B2, C1, C2, D1, D2, ONE, RBASE, ZERO    
!     ..                                                                
!     .. External Functions ..                                          
!     REAL               csvd_slamc3                                         
!     EXTERNAL           csvd_slamc3                                         
!      ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
      A = START                                                         
      ONE = 1                                                           
      RBASE = ONE / BASE                                                
      ZERO = 0                                                          
      EMIN = 1                                                          
      B1 = csvd_slamc3( A*RBASE, ZERO )                                      
      C1 = A                                                            
      C2 = A                                                            
      D1 = A                                                            
      D2 = A                                                            
!+    WHILE( ( C1.EQ.A ).AND.( C2.EQ.A ).AND.                           
!    $       ( D1.EQ.A ).AND.( D2.EQ.A )      )LOOP                     
   10 CONTINUE                                                          
      IF( ( C1.EQ.A ) .AND. ( C2.EQ.A ) .AND. ( D1.EQ.A ) .AND.           &
          ( D2.EQ.A ) ) THEN                                            
         EMIN = EMIN - 1                                                
         A = B1                                                         
         B1 = csvd_slamc3( A / BASE, ZERO )                                  
         C1 = csvd_slamc3( B1*BASE, ZERO )                                   
         D1 = ZERO                                                      
         DO 20 I = 1, BASE                                              
            D1 = D1 + B1                                                
   20    CONTINUE                                                       
         B2 = csvd_slamc3( A*RBASE, ZERO )                                   
         C2 = csvd_slamc3( B2 / RBASE, ZERO )                                
         D2 = ZERO                                                      
         DO 30 I = 1, BASE                                              
            D2 = D2 + B2                                                
   30    CONTINUE                                                       
         GO TO 10                                                       
      END IF                                                            
!+    END WHILE                                                         
!                                                                       
      RETURN                                                            
!                                                                       
!     End of CSVD_SLAMC4                                                     
!                                                                       
      END SUBROUTINE CSVD_SLAMC4
!                                                                       
!***********************************************************************
!                                                                       
      SUBROUTINE CSVD_SLAMC5( BETA, P, EMIN, IEEE, EMAX, RMAX )              
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     October 31, 1992                                                  
!                                                                       
!     .. Scalar Arguments ..                                            
      LOGICAL            IEEE                                           
      INTEGER            BETA, EMAX, EMIN, P                            
      REAL               RMAX                                           
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_SLAMC5 attempts to compute RMAX, the largest machine floating-point  
!  number, without overflow.  It assumes that EMAX + abs(EMIN) sum      
!  approximately to a power of 2.  It will fail on machines where this  
!  assumption does not hold, for example, the Cyber 205 (EMIN = -28625, 
!  EMAX = 28718).  It will also fail if the value supplied for EMIN is  
!  too large (i.e. too close to zero), probably with overflow.          
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  BETA    (input) INTEGER                                              
!          The base of floating-point arithmetic.                       
!                                                                       
!  P       (input) INTEGER                                              
!          The number of base BETA digits in the mantissa of a          
!          floating-point value.                                        
!                                                                       
!  EMIN    (input) INTEGER                                              
!          The minimum exponent before (gradual) underflow.             
!                                                                       
!  IEEE    (input) LOGICAL                                              
!          A logical flag specifying whether or not the arithmetic      
!          system is thought to comply with the IEEE standard.          
!                                                                       
!  EMAX    (output) INTEGER                                             
!          The largest exponent before overflow                         
!                                                                       
!  RMAX    (output) REAL                                                
!          The largest machine floating-point number.                   
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Parameters ..                                                  
      REAL               ZERO, ONE                                      
      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0 )                  
!     ..                                                                
!     .. Local Scalars ..                                               
      INTEGER            EXBITS, EXPSUM, I, LEXP, NBITS, TRY, UEXP      
      REAL               OLDY, RECBAS, Y, Z                             
!     ..                                                                
!     .. External Functions ..                                          
!      REAL               csvd_slamc3                                         
!      EXTERNAL           csvd_slamc3                                         
!     ..                                                                
!     .. Intrinsic Functions ..                                         
      INTRINSIC          MOD                                            
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     First compute LEXP and UEXP, two powers of 2 that bound           
!     abs(EMIN). We then assume that EMAX + abs(EMIN) will sum          
!     approximately to the bound that is closest to abs(EMIN).          
!     (EMAX is the exponent of the required number RMAX).               
!                                                                       
      LEXP = 1                                                          
      EXBITS = 1                                                        
   10 CONTINUE                                                          
      TRY = LEXP*2                                                      
      IF( TRY.LE.( -EMIN ) ) THEN                                       
         LEXP = TRY                                                     
         EXBITS = EXBITS + 1                                            
         GO TO 10                                                       
      END IF                                                            
      IF( LEXP.EQ.-EMIN ) THEN                                          
         UEXP = LEXP                                                    
      ELSE                                                              
         UEXP = TRY                                                     
         EXBITS = EXBITS + 1                                            
      END IF                                                            
!                                                                       
!     Now -LEXP is less than or equal to EMIN, and -UEXP is greater     
!     than or equal to EMIN. EXBITS is the number of bits needed to     
!     store the exponent.                                               
!                                                                       
      IF( ( UEXP+EMIN ).GT.( -LEXP-EMIN ) ) THEN                        
         EXPSUM = 2*LEXP                                                
      ELSE                                                              
         EXPSUM = 2*UEXP                                                
      END IF                                                            
!                                                                       
!     EXPSUM is the exponent range, approximately equal to              
!     EMAX - EMIN + 1 .                                                 
!                                                                       
      EMAX = EXPSUM + EMIN - 1                                          
      NBITS = 1 + EXBITS + P                                            
!                                                                       
!     NBITS is the total number of bits needed to store a               
!     floating-point number.                                            
!                                                                       
      IF( ( MOD( NBITS, 2 ).EQ.1 ) .AND. ( BETA.EQ.2 ) ) THEN           
!                                                                       
!        Either there are an odd number of bits used to store a         
!        floating-point number, which is unlikely, or some bits are     
!        not used in the representation of numbers, which is possible,  
!        (e.g. Cray machines) or the mantissa has an implicit bit,      
!        (e.g. IEEE machines, Dec Vax machines), which is perhaps the   
!        most likely. We have to assume the last alternative.           
!        If this is true, then we need to reduce EMAX by one because    
!        there must be some way of representing zero in an implicit-bit 
!        system. On machines like Cray, we are reducing EMAX by one     
!        unnecessarily.                                                 
!                                                                       
         EMAX = EMAX - 1                                                
      END IF                                                            
!                                                                       
      IF( IEEE ) THEN                                                   
!                                                                       
!        Assume we are on an IEEE machine which reserves one exponent   
!        for infinity and NaN.                                          
!                                                                       
         EMAX = EMAX - 1                                                
      END IF                                                            
!                                                                       
!     Now create RMAX, the largest machine number, which should         
!     be equal to (1.0 - BETA**(-P)) * BETA**EMAX .                     
!                                                                       
!     First compute 1.0 - BETA**(-P), being careful that the            
!     result is less than 1.0 .                                         
!                                                                       
      RECBAS = ONE / BETA                                               
      Z = BETA - ONE                                                    
      Y = ZERO                                                          
      DO 20 I = 1, P                                                    
         Z = Z*RECBAS                                                   
         IF( Y.LT.ONE )                                                   &
            OLDY = Y                                                    
         Y = csvd_slamc3( Y, Z )                                             
   20 CONTINUE                                                          
      IF( Y.GE.ONE )                                                      &
         Y = OLDY                                                       
!                                                                       
!     Now multiply by BETA**EMAX to get RMAX.                           
!                                                                       
      DO 30 I = 1, EMAX                                                 
         Y = csvd_slamc3( Y*BETA, ZERO )                                     
   30 CONTINUE                                                          
!                                                                       
      RMAX = Y                                                          
      RETURN                                                            
!                                                                       
!     End of CSVD_SLAMC5                                                     
!                                                                       
      END  SUBROUTINE CSVD_SLAMC5
                                                             
      SUBROUTINE CSVD_XERBLA( SRNAME, INFO )                                 
!                                                                       
!  -- LAPACK auxiliary routine (version 3.0) --                         
!     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,       
!     Courant Institute, Argonne National Lab, and Rice University      
!     September 30, 1994                                                
!                                                                       
!     .. Scalar Arguments ..                                            
      CHARACTER*11       SRNAME                                         
      INTEGER            INFO                                           
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_XERBLA  is an error handler for the LAPACK routines.                 
!  It is called by an LAPACK routine if an input parameter has an       
!  invalid value.  A message is printed and execution stops.            
!                                                                       
!  Installers may consider modifying the STOP statement in order to     
!  call system-specific exception-handling facilities.                  
!                                                                       
!  Arguments                                                            
!  =========                                                            
!                                                                       
!  SRNAME  (input) CHARACTER*11                                          
!          The name of the routine which called CSVD_XERBLA.                 
!                                                                       
!  INFO    (input) INTEGER                                              
!          The position of the invalid parameter in the parameter list  
!          of the calling routine.                                      
!                                                                       
! ===================================================================== 
!                                                                       
!     .. Executable Statements ..                                       
!                                                                       
      WRITE( *, FMT = 9999 )SRNAME, INFO                                
!                                                                       
      STOP                                                              
!                                                                       
 9999 FORMAT( ' ** On enter to ', A11, ' parameter number ', I2, ' had ', &
            'an illegal value' )                                        
!                                                                       
!     End of CSVD_XERBLA                                                     
!                                                                       
      END SUBROUTINE CSVD_XERBLA 
                                                                        
                                                                        
! BLAS REQUIRED BY LAPACK ROUTINE: csvd                              
! -----------------------------------------------------------           
! Note: Link to BLAS optimized for your system, if available.           
! -----------------------------------------------------------           
                                                                        
      SUBROUTINE CSVD_scopy(n,sx,incx,sy,incy)                               
!                                                                       
!     copies a vector, x, to a vector, y.                               
!     uses unrolled loops for increments equal to 1.                    
!     jack dongarra, linpack, 3/11/78.                                  
!     modified 12/3/93, array(1) declarations changed to array(*)       
!                                                                       
      real sx(*),sy(*)                                                  
      integer i,incx,incy,ix,iy,m,mp1,n                                 
!                                                                       
      if(n.le.0)return                                                  
      if(incx.eq.1.and.incy.eq.1)go to 20                               
!                                                                       
!        code for unequal increments or equal increments                
!          not equal to 1                                               
!                                                                       
      ix = 1                                                            
      iy = 1                                                            
      if(incx.lt.0)ix = (-n+1)*incx + 1                                 
      if(incy.lt.0)iy = (-n+1)*incy + 1                                 
      do 10 i = 1,n                                                     
        sy(iy) = sx(ix)                                                 
        ix = ix + incx                                                  
        iy = iy + incy                                                  
   10 continue                                                          
      return                                                            
!                                                                       
!        code for both increments equal to 1                            
!                                                                       
!                                                                       
!        clean-up loop                                                  
!                                                                       
   20 m = mod(n,7)                                                      
      if( m .eq. 0 ) go to 40                                           
      do 30 i = 1,m                                                     
        sy(i) = sx(i)                                                   
   30 continue                                                          
      if( n .lt. 7 ) return                                             
   40 mp1 = m + 1                                                       
      do 50 i = mp1,n,7                                                 
        sy(i) = sx(i)                                                   
        sy(i + 1) = sx(i + 1)                                           
        sy(i + 2) = sx(i + 2)                                           
        sy(i + 3) = sx(i + 3)                                           
        sy(i + 4) = sx(i + 4)                                           
        sy(i + 5) = sx(i + 5)                                           
        sy(i + 6) = sx(i + 6)                                           
   50 continue                                                          
      return                                                            
      end SUBROUTINE CSVD_scopy
                                                              

      REAL             FUNCTION csvd_scnrm2( N, X, INCX )                    
!     .. Scalar Arguments ..                                            
      INTEGER                           INCX, N                         
!     .. Array Arguments ..                                             
      COMPLEX                           X( * )                          
!     ..                                                                
!                                                                       
!  csvd_scnrm2 returns the euclidean norm of a vector via the function       
!  name, so that                                                        
!                                                                       
!     csvd_scnrm2 := sqrt( conjg( x' )*x )                                   
!                                                                       
!                                                                       
!                                                                       
!  -- This version written on 25-October-1982.                          
!     Modified on 14-October-1993 to inline the call to CSVD_CLASSQ.         
!     Sven Hammarling, Nag Ltd.                                         
!                                                                       
!                                                                       
!     .. Parameters ..                                                  
      REAL                  ONE         , ZERO                          
      PARAMETER           ( ONE = 1.0E+0, ZERO = 0.0E+0 )               
!     .. Local Scalars ..                                               
      INTEGER               IX                                          
      REAL                  NORM, SCALE, SSQ, TEMP                      
!     .. Intrinsic Functions ..                                         
      INTRINSIC             ABS, AIMAG, REAL, SQRT                      
!     ..                                                                
!     .. Executable Statements ..                                       
      IF( N.LT.1 .OR. INCX.LT.1 )THEN                                   
         NORM  = ZERO                                                   
      ELSE                                                              
         SCALE = ZERO                                                   
         SSQ   = ONE                                                    
!        The following loop is equivalent to this call to the LAPACK    
!        auxiliary routine:                                             
!        CALL CSVD_CLASSQ( N, X, INCX, SCALE, SSQ )                          
!                                                                       
         DO 10, IX = 1, 1 + ( N - 1 )*INCX, INCX                        
            IF( REAL( X( IX ) ).NE.ZERO )THEN                           
               TEMP = ABS( REAL( X( IX ) ) )                            
               IF( SCALE.LT.TEMP )THEN                                  
                  SSQ   = ONE   + SSQ*( SCALE/TEMP )**2                 
                  SCALE = TEMP                                          
               ELSE                                                     
                  SSQ   = SSQ   +     ( TEMP/SCALE )**2                 
               END IF                                                   
            END IF                                                      
            IF( AIMAG( X( IX ) ).NE.ZERO )THEN                          
               TEMP = ABS( AIMAG( X( IX ) ) )                           
               IF( SCALE.LT.TEMP )THEN                                  
                  SSQ   = ONE   + SSQ*( SCALE/TEMP )**2                 
                  SCALE = TEMP                                          
               ELSE                                                     
                  SSQ   = SSQ   +     ( TEMP/SCALE )**2                 
               END IF                                                   
            END IF                                                      
   10    CONTINUE                                                       
         NORM  = SCALE * SQRT( SSQ )                                    
      END IF                                                            
!                                                                       
      csvd_scnrm2 = NORM                                                     
      RETURN                                                            
!                                                                       
!     End of csvd_scnrm2.                                                    
!                                                                       
      END FUNCTION csvd_scnrm2
                                                              
      SUBROUTINE CSVD_ccopy(n,cx,incx,cy,incy)                              
!                                                                       
!     copies a vector, x, to a vector, y.                               
!     jack dongarra, linpack, 3/11/78.                                  
!     modified 12/3/93, array(1) declarations changed to array(*)       
!                                                                       
      complex cx(*),cy(*)                                               
      integer i,incx,incy,ix,iy,n                                       
!                                                                       
      if(n.le.0)return                                                  
      if(incx.eq.1.and.incy.eq.1)go to 20                               
!                                                                       
!        code for unequal increments or equal increments                
!          not equal to 1                                               
!                                                                       
      ix = 1                                                            
      iy = 1                                                            
      if(incx.lt.0)ix = (-n+1)*incx + 1                                 
      if(incy.lt.0)iy = (-n+1)*incy + 1                                 
      do 10 i = 1,n                                                     
        cy(iy) = cx(ix)                                                 
        ix = ix + incx                                                  
        iy = iy + incy                                                  
   10 continue                                                          
      return                                                            
!                                                                       
!        code for both increments equal to 1                            
!                                                                       
   20 do 30 i = 1,n                                                     
        cy(i) = cx(i)                                                   
   30 continue                                                          
      return                                                            
      end SUBROUTINE CSVD_ccopy
                                                              
      SUBROUTINE CSVD_csscal(n,sa,cx,incx)                                  
!                                                                       
!     scales a complex vector by a real constant.                       
!     jack dongarra, linpack, 3/11/78.                                  
!     modified 3/93 to return if incx .le. 0.                           
!     modified 12/3/93, array(1) declarations changed to array(*)       
!                                                                       
      complex cx(*)                                                     
      real sa                                                           
      integer i,incx,n,nincx                                            
!                                                                       
      if( n.le.0 .or. incx.le.0 )return                                 
      if(incx.eq.1)go to 20                                             
!                                                                       
!        code for increment not equal to 1                              
!                                                                       
      nincx = n*incx                                                    
      do 10 i = 1,nincx,incx                                            
        cx(i) = cmplx(sa*real(cx(i)),sa*aimag(cx(i)))                   
   10 continue                                                          
      return                                                            
!                                                                       
!        code for increment equal to 1                                  
!                                                                       
   20 do 30 i = 1,n                                                     
        cx(i) = cmplx(sa*real(cx(i)),sa*aimag(cx(i)))                   
   30 continue                                                          
      return                                                            
      end SUBROUTINE CSVD_csscal
                                                               
      subroutine CSVD_cscal(n,ca,cx,incx)                                   
!                                                                       
!     scales a vector by a constant.                                    
!     jack dongarra, linpack,  3/11/78.                                 
!     modified 3/93 to return if incx .le. 0.                           
!     modified 12/3/93, array(1) declarations changed to array(*)       
!                                                                       
      complex ca,cx(*)                                                  
      integer i,incx,n,nincx                                            
!                                                                       
      if( n.le.0 .or. incx.le.0 )return                                 
      if(incx.eq.1)go to 20                                             
!                                                                       
!        code for increment not equal to 1                              
!                                                                       
      nincx = n*incx                                                    
      do 10 i = 1,nincx,incx                                            
        cx(i) = ca*cx(i)                                                
   10 continue                                                          
      return                                                            
!                                                                       
!        code for increment equal to 1                                  
!                                                                       
   20 do 30 i = 1,n                                                     
        cx(i) = ca*cx(i)                                                
   30 continue                                                          
      return                                                            
      end SUBROUTINE CSVD_cscal
                                                              
      subroutine CSVD_cswap (n,cx,incx,cy,incy)                             
!                                                                       
!     interchanges two vectors.                                         
!     jack dongarra, linpack, 3/11/78.                                  
!     modified 12/3/93, array(1) declarations changed to array(*)       
!                                                                       
      complex cx(*),cy(*),ctemp                                         
      integer i,incx,incy,ix,iy,n                                       
!                                                                       
      if(n.le.0)return                                                  
      if(incx.eq.1.and.incy.eq.1)go to 20                               
!                                                                       
!       code for unequal increments or equal increments not equal       
!         to 1                                                          
!                                                                       
      ix = 1                                                            
      iy = 1                                                            
      if(incx.lt.0)ix = (-n+1)*incx + 1                                 
      if(incy.lt.0)iy = (-n+1)*incy + 1                                 
      do 10 i = 1,n                                                     
        ctemp = cx(ix)                                                  
        cx(ix) = cy(iy)                                                 
        cy(iy) = ctemp                                                  
        ix = ix + incx                                                  
        iy = iy + incy                                                  
   10 continue                                                          
      return                                                            
!                                                                       
!       code for both increments equal to 1                             
   20 do 30 i = 1,n                                                     
        ctemp = cx(i)                                                   
        cx(i) = cy(i)                                                   
        cy(i) = ctemp                                                   
   30 continue                                                          
      return                                                            
      end  SUBROUTINE CSVD_cswap
                                                             
      SUBROUTINE CSVD_CGEMV ( TRANS, M, N, ALPHA, A, LDA, X, INCX,  &
                         BETA, Y, INCY )                                
!     .. Scalar Arguments ..                                            
      COMPLEX            ALPHA, BETA                                    
      INTEGER            INCX, INCY, LDA, M, N                          
      CHARACTER*1        TRANS                                          
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * ), X( * ), Y( * )                    
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CGEMV  performs one of the matrix-vector operations                  
!                                                                       
!     y := alpha*A*x + beta*y,   or   y := alpha*A'*x + beta*y,   or    
!                                                                       
!     y := alpha*conjg( A' )*x + beta*y,                                
!                                                                       
!  where alpha and beta are scalars, x and y are vectors and A is an    
!  m by n matrix.                                                       
!                                                                       
!  Parameters                                                           
!  ==========                                                           
!                                                                       
!  TRANS  - CHARACTER*1.                                                
!           On entry, TRANS specifies the operation to be performed as  
!           follows:                                                    
!                                                                       
!              TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.            
!                                                                       
!              TRANS = 'T' or 't'   y := alpha*A'*x + beta*y.           
!                                                                       
!              TRANS = 'C' or 'c'   y := alpha*conjg( A' )*x + beta*y.  
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  M      - INTEGER.                                                    
!           On entry, M specifies the number of rows of the matrix A.   
!           M must be at least zero.                                    
!           Unchanged on exit.                                          
!                                                                       
!  N      - INTEGER.                                                    
!           On entry, N specifies the number of columns of the matrix A.
!           N must be at least zero.                                    
!           Unchanged on exit.                                          
!                                                                       
!  ALPHA  - COMPLEX         .                                           
!           On entry, ALPHA specifies the scalar alpha.                 
!           Unchanged on exit.                                          
!                                                                       
!  A      - COMPLEX          array of DIMENSION ( LDA, n ).             
!           Before entry, the leading m by n part of the array A must   
!           contain the matrix of coefficients.                         
!           Unchanged on exit.                                          
!                                                                       
!  LDA    - INTEGER.                                                    
!           On entry, LDA specifies the first dimension of A as declared
!           in the calling (sub) program. LDA must be at least          
!           max( 1, m ).                                                
!           Unchanged on exit.                                          
!                                                                       
!  X      - COMPLEX          array of DIMENSION at least                
!           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'       
!           and at least                                                
!           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.                    
!           Before entry, the incremented array X must contain the      
!           vector x.                                                   
!           Unchanged on exit.                                          
!                                                                       
!  INCX   - INTEGER.                                                    
!           On entry, INCX specifies the increment for the elements of  
!           X. INCX must not be zero.                                   
!           Unchanged on exit.                                          
!                                                                       
!  BETA   - COMPLEX         .                                           
!           On entry, BETA specifies the scalar beta. When BETA is      
!           supplied as zero then Y need not be set on input.           
!           Unchanged on exit.                                          
!                                                                       
!  Y      - COMPLEX          array of DIMENSION at least                
!           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'       
!           and at least                                                
!           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.                    
!           Before entry with BETA non-zero, the incremented array Y    
!           must contain the vector y. On exit, Y is overwritten by the 
!           updated vector y.                                           
!                                                                       
!  INCY   - INTEGER.                                                    
!           On entry, INCY specifies the increment for the elements of  
!           Y. INCY must not be zero.                                   
!           Unchanged on exit.                                          
!                                                                       
!                                                                       
!  Level 2 Blas routine.                                                
!                                                                       
!  -- Written on 22-October-1986.                                       
!     Jack Dongarra, Argonne National Lab.                              
!     Jeremy Du Croz, Nag Central Office.                               
!     Sven Hammarling, Nag Central Office.                              
!     Richard Hanson, Sandia National Labs.                             
!                                                                       
!                                                                       
!     .. Parameters ..                                                  
      COMPLEX            ONE                                            
!      PARAMETER        ( ONE  = CMPLX( 1.0E+0, 0.0E+0 ) )
      COMPLEX            ZERO                                           
!      PARAMETER        ( ZERO = CMPLX( 0.0E+0, 0.0E+0 ) )
!     .. Local Scalars ..                                               
      COMPLEX            TEMP                                           
      INTEGER            I, INFO, IX, IY, J, JX, JY, KX, KY, LENX, LENY 
      LOGICAL            NOCONJ                                         
!     .. External Functions ..                                          
!      LOGICAL            csvd_lsame                                          
!      EXTERNAL           csvd_lsame                                          
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_XERBLA                                         
!     .. Intrinsic Functions ..                                         
      INTRINSIC          CONJG, MAX                                     
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      ONE  = CMPLX( 1.0E+0, 0.0E+0 )               
      ZERO = CMPLX( 0.0E+0, 0.0E+0 ) 

      INFO = 0                                                          
      IF     ( .NOT.csvd_lsame( TRANS, 'N' ).AND.                    &
               .NOT.csvd_lsame( TRANS, 'T' ).AND.                    &
               .NOT.csvd_lsame( TRANS, 'C' )      )THEN                      
         INFO = 1                                                       
      ELSE IF( M.LT.0 )THEN                                             
         INFO = 2                                                       
      ELSE IF( N.LT.0 )THEN                                             
         INFO = 3                                                       
      ELSE IF( LDA.LT.MAX( 1, M ) )THEN                                 
         INFO = 6                                                       
      ELSE IF( INCX.EQ.0 )THEN                                          
         INFO = 8                                                       
      ELSE IF( INCY.EQ.0 )THEN                                          
         INFO = 11                                                      
      END IF                                                            
      IF( INFO.NE.0 )THEN                                               
         CALL CSVD_XERBLA( 'CSVD_CGEMV ', INFO )
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.                                    &
          ( ( ALPHA.EQ.ZERO ).AND.( BETA.EQ.ONE ) ) )                     &
         RETURN                                                         
!                                                                       
      NOCONJ = csvd_lsame( TRANS, 'T' )                                      
!                                                                       
!     Set  LENX  and  LENY, the lengths of the vectors x and y, and set 
!     up the start points in  X  and  Y.                                
!                                                                       
      IF( csvd_lsame( TRANS, 'N' ) )THEN                                     
         LENX = N                                                       
         LENY = M                                                       
      ELSE                                                              
         LENX = M                                                       
         LENY = N                                                       
      END IF                                                            
      IF( INCX.GT.0 )THEN                                               
         KX = 1                                                         
      ELSE                                                              
         KX = 1 - ( LENX - 1 )*INCX                                     
      END IF                                                            
      IF( INCY.GT.0 )THEN                                               
         KY = 1                                                         
      ELSE                                                              
         KY = 1 - ( LENY - 1 )*INCY                                     
      END IF                                                            
!                                                                       
!     Start the operations. In this version the elements of A are       
!     accessed sequentially with one pass through A.                    
!                                                                       
!     First form  y := beta*y.                                          
!                                                                       
      IF( BETA.NE.ONE )THEN                                             
         IF( INCY.EQ.1 )THEN                                            
            IF( BETA.EQ.ZERO )THEN                                      
               DO 10, I = 1, LENY                                       
                  Y( I ) = ZERO                                         
   10          CONTINUE                                                 
            ELSE                                                        
               DO 20, I = 1, LENY                                       
                  Y( I ) = BETA*Y( I )                                  
   20          CONTINUE                                                 
            END IF                                                      
         ELSE                                                           
            IY = KY                                                     
            IF( BETA.EQ.ZERO )THEN                                      
               DO 30, I = 1, LENY                                       
                  Y( IY ) = ZERO                                        
                  IY      = IY   + INCY                                 
   30          CONTINUE                                                 
            ELSE                                                        
               DO 40, I = 1, LENY                                       
                  Y( IY ) = BETA*Y( IY )                                
                  IY      = IY           + INCY                         
   40          CONTINUE                                                 
            END IF                                                      
         END IF                                                         
      END IF                                                            
      IF( ALPHA.EQ.ZERO )                                                 &
         RETURN                                                         
      IF( csvd_lsame( TRANS, 'N' ) )THEN                                     
!                                                                       
!        Form  y := alpha*A*x + y.                                      
!                                                                       
         JX = KX                                                        
         IF( INCY.EQ.1 )THEN                                            
            DO 60, J = 1, N                                             
               IF( X( JX ).NE.ZERO )THEN                                
                  TEMP = ALPHA*X( JX )                                  
                  DO 50, I = 1, M                                       
                     Y( I ) = Y( I ) + TEMP*A( I, J )                   
   50             CONTINUE                                              
               END IF                                                   
               JX = JX + INCX                                           
   60       CONTINUE                                                    
         ELSE                                                           
            DO 80, J = 1, N                                             
               IF( X( JX ).NE.ZERO )THEN                                
                  TEMP = ALPHA*X( JX )                                  
                  IY   = KY                                             
                  DO 70, I = 1, M                                       
                     Y( IY ) = Y( IY ) + TEMP*A( I, J )                 
                     IY      = IY      + INCY                           
   70             CONTINUE                                              
               END IF                                                   
               JX = JX + INCX                                           
   80       CONTINUE                                                    
         END IF                                                         
      ELSE                                                              
!                                                                       
!        Form  y := alpha*A'*x + y  or  y := alpha*conjg( A' )*x + y.   
!                                                                       
         JY = KY                                                        
         IF( INCX.EQ.1 )THEN                                            
            DO 110, J = 1, N                                            
               TEMP = ZERO                                              
               IF( NOCONJ )THEN                                         
                  DO 90, I = 1, M                                       
                     TEMP = TEMP + A( I, J )*X( I )                     
   90             CONTINUE                                              
               ELSE                                                     
                  DO 100, I = 1, M                                      
                     TEMP = TEMP + CONJG( A( I, J ) )*X( I )            
  100             CONTINUE                                              
               END IF                                                   
               Y( JY ) = Y( JY ) + ALPHA*TEMP                           
               JY      = JY      + INCY                                 
  110       CONTINUE                                                    
         ELSE                                                           
            DO 140, J = 1, N                                            
               TEMP = ZERO                                              
               IX   = KX                                                
               IF( NOCONJ )THEN                                         
                  DO 120, I = 1, M                                      
                     TEMP = TEMP + A( I, J )*X( IX )                    
                     IX   = IX   + INCX                                 
  120             CONTINUE                                              
               ELSE                                                     
                  DO 130, I = 1, M                                      
                     TEMP = TEMP + CONJG( A( I, J ) )*X( IX )           
                     IX   = IX   + INCX                                 
  130             CONTINUE                                              
               END IF                                                   
               Y( JY ) = Y( JY ) + ALPHA*TEMP                           
               JY      = JY      + INCY                                 
  140       CONTINUE                                                    
         END IF                                                         
      END IF                                                            
!                                                                       
      RETURN                                                            
!                                                                       
!     End of CSVD_CGEMV .                                                    
!                                                                       
      END SUBROUTINE CSVD_CGEMV
                                                              
      SUBROUTINE CSVD_CTRMV ( UPLO, TRANS, DIAG, N, A, LDA, X, INCX )        
!     .. Scalar Arguments ..                                            
      INTEGER            INCX, LDA, N                                   
      CHARACTER*1        DIAG, TRANS, UPLO                              
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * ), X( * )                            
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CTRMV  performs one of the matrix-vector operations                  
!                                                                       
!     x := A*x,   or   x := A'*x,   or   x := conjg( A' )*x,            
!                                                                       
!  where x is an n element vector and  A is an n by n unit, or non-unit,
!  upper or lower triangular matrix.                                    
!                                                                       
!  Parameters                                                           
!  ==========                                                           
!                                                                       
!  UPLO   - CHARACTER*1.                                                
!           On entry, UPLO specifies whether the matrix is an upper or  
!           lower triangular matrix as follows:                         
!                                                                       
!              UPLO = 'U' or 'u'   A is an upper triangular matrix.     
!                                                                       
!              UPLO = 'L' or 'l'   A is a lower triangular matrix.      
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  TRANS  - CHARACTER*1.                                                
!           On entry, TRANS specifies the operation to be performed as  
!           follows:                                                    
!                                                                       
!              TRANS = 'N' or 'n'   x := A*x.                           
!                                                                       
!              TRANS = 'T' or 't'   x := A'*x.                          
!                                                                       
!              TRANS = 'C' or 'c'   x := conjg( A' )*x.                 
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  DIAG   - CHARACTER*1.                                                
!           On entry, DIAG specifies whether or not A is unit           
!           triangular as follows:                                      
!                                                                       
!              DIAG = 'U' or 'u'   A is assumed to be unit triangular.  
!                                                                       
!              DIAG = 'N' or 'n'   A is not assumed to be unit          
!                                  triangular.                          
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  N      - INTEGER.                                                    
!           On entry, N specifies the order of the matrix A.            
!           N must be at least zero.                                    
!           Unchanged on exit.                                          
!                                                                       
!  A      - COMPLEX          array of DIMENSION ( LDA, n ).             
!           Before entry with  UPLO = 'U' or 'u', the leading n by n    
!           upper triangular part of the array A must contain the upper 
!           triangular matrix and the strictly lower triangular part of 
!           A is not referenced.                                        
!           Before entry with UPLO = 'L' or 'l', the leading n by n     
!           lower triangular part of the array A must contain the lower 
!           triangular matrix and the strictly upper triangular part of 
!           A is not referenced.                                        
!           Note that when  DIAG = 'U' or 'u', the diagonal elements of 
!           A are not referenced either, but are assumed to be unity.   
!           Unchanged on exit.                                          
!                                                                       
!  LDA    - INTEGER.                                                    
!           On entry, LDA specifies the first dimension of A as declared
!           in the calling (sub) program. LDA must be at least          
!           max( 1, n ).                                                
!           Unchanged on exit.                                          
!                                                                       
!  X      - COMPLEX          array of dimension at least                
!           ( 1 + ( n - 1 )*abs( INCX ) ).                              
!           Before entry, the incremented array X must contain the n    
!           element vector x. On exit, X is overwritten with the        
!           tranformed vector x.                                        
!                                                                       
!  INCX   - INTEGER.                                                    
!           On entry, INCX specifies the increment for the elements of  
!           X. INCX must not be zero.                                   
!           Unchanged on exit.                                          
!                                                                       
!                                                                       
!  Level 2 Blas routine.                                                
!                                                                       
!  -- Written on 22-October-1986.                                       
!     Jack Dongarra, Argonne National Lab.                              
!     Jeremy Du Croz, Nag Central Office.                               
!     Sven Hammarling, Nag Central Office.                              
!     Richard Hanson, Sandia National Labs.                             
!                                                                       
!                                                                       
!     .. Parameters ..                                                  
      COMPLEX            ZERO                                           
!      PARAMETER        ( ZERO = CMPLX( 0.0E+0, 0.0E+0 ) )
!     .. Local Scalars ..                                               
      COMPLEX            TEMP                                           
      INTEGER            I, INFO, IX, J, JX, KX                         
      LOGICAL            NOCONJ, NOUNIT                                 
!     .. External Functions ..                                          
!      LOGICAL            csvd_lsame                                          
!      EXTERNAL           csvd_lsame                                          
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_XERBLA                                         
!     .. Intrinsic Functions ..                                         
      INTRINSIC          CONJG, MAX                                     
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      ZERO = CMPLX( 0.0E+0, 0.0E+0 ) 

      INFO = 0                                                          
      IF     ( .NOT.csvd_lsame( UPLO , 'U' ).AND.                     &
               .NOT.csvd_lsame( UPLO , 'L' )      )THEN                      
         INFO = 1                                                       
      ELSE IF( .NOT.csvd_lsame( TRANS, 'N' ).AND.                     &
               .NOT.csvd_lsame( TRANS, 'T' ).AND.                     & 
               .NOT.csvd_lsame( TRANS, 'C' )      )THEN                      
         INFO = 2                                                       
      ELSE IF( .NOT.csvd_lsame( DIAG , 'U' ).AND.                     &
               .NOT.csvd_lsame( DIAG , 'N' )      )THEN                      
         INFO = 3                                                       
      ELSE IF( N.LT.0 )THEN                                             
         INFO = 4                                                       
      ELSE IF( LDA.LT.MAX( 1, N ) )THEN                                 
         INFO = 6                                                       
      ELSE IF( INCX.EQ.0 )THEN                                          
         INFO = 8                                                       
      END IF                                                            
      IF( INFO.NE.0 )THEN                                               
         CALL CSVD_XERBLA( 'CSVD_CTRMV ', INFO )
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF( N.EQ.0 )                                                     & 
         RETURN                                                         
!                                                                       
      NOCONJ = csvd_lsame( TRANS, 'T' )
      NOUNIT = csvd_lsame( DIAG , 'N' )
!                                                                       
!     Set up the start point in X if the increment is not unity. This   
!     will be  ( N - 1 )*INCX  too small for descending loops.          
!                                                                       
      IF( INCX.LE.0 )THEN                                               
         KX = 1 - ( N - 1 )*INCX                                        
      ELSE IF( INCX.NE.1 )THEN                                          
         KX = 1                                                         
      END IF                                                            
!                                                                       
!     Start the operations. In this version the elements of A are       
!     accessed sequentially with one pass through A.                    
!                                                                       
      IF( csvd_lsame( TRANS, 'N' ) )THEN                                     
!                                                                       
!        Form  x := A*x.                                                
!                                                                       
         IF( csvd_lsame( UPLO, 'U' ) )THEN                                   
            IF( INCX.EQ.1 )THEN                                         
               DO 20, J = 1, N                                          
                  IF( X( J ).NE.ZERO )THEN                              
                     TEMP = X( J )                                      
                     DO 10, I = 1, J - 1                                
                        X( I ) = X( I ) + TEMP*A( I, J )                
   10                CONTINUE                                           
                     IF( NOUNIT )                                         &
                        X( J ) = X( J )*A( J, J )                       
                  END IF                                                
   20          CONTINUE                                                 
            ELSE                                                        
               JX = KX                                                  
               DO 40, J = 1, N                                          
                  IF( X( JX ).NE.ZERO )THEN                             
                     TEMP = X( JX )                                     
                     IX   = KX                                          
                     DO 30, I = 1, J - 1                                
                        X( IX ) = X( IX ) + TEMP*A( I, J )              
                        IX      = IX      + INCX                        
   30                CONTINUE                                           
                     IF( NOUNIT )                                     &
                        X( JX ) = X( JX )*A( J, J )                     
                  END IF                                                
                  JX = JX + INCX                                        
   40          CONTINUE                                                 
            END IF                                                      
         ELSE                                                           
            IF( INCX.EQ.1 )THEN                                         
               DO 60, J = N, 1, -1                                      
                  IF( X( J ).NE.ZERO )THEN                              
                     TEMP = X( J )                                      
                     DO 50, I = N, J + 1, -1                            
                        X( I ) = X( I ) + TEMP*A( I, J )                
   50                CONTINUE                                           
                     IF( NOUNIT )                                      &
                        X( J ) = X( J )*A( J, J )                       
                  END IF                                                
   60          CONTINUE                                                 
            ELSE                                                        
               KX = KX + ( N - 1 )*INCX                                 
               JX = KX                                                  
               DO 80, J = N, 1, -1                                      
                  IF( X( JX ).NE.ZERO )THEN                             
                     TEMP = X( JX )                                     
                     IX   = KX                                          
                     DO 70, I = N, J + 1, -1                            
                        X( IX ) = X( IX ) + TEMP*A( I, J )              
                        IX      = IX      - INCX                        
   70                CONTINUE                                           
                     IF( NOUNIT )                                       &
                        X( JX ) = X( JX )*A( J, J )                     
                  END IF                                                
                  JX = JX - INCX                                        
   80          CONTINUE                                                 
            END IF                                                      
         END IF                                                         
      ELSE                                                              
!                                                                       
!        Form  x := A'*x  or  x := conjg( A' )*x.                       
!                                                                       
         IF( csvd_lsame( UPLO, 'U' ) )THEN                                   
            IF( INCX.EQ.1 )THEN                                         
               DO 110, J = N, 1, -1                                     
                  TEMP = X( J )                                         
                  IF( NOCONJ )THEN                                      
                     IF( NOUNIT )                                         &
                        TEMP = TEMP*A( J, J )                           
                     DO 90, I = J - 1, 1, -1                            
                        TEMP = TEMP + A( I, J )*X( I )                  
   90                CONTINUE                                           
                  ELSE                                                  
                     IF( NOUNIT )                                         &
                        TEMP = TEMP*CONJG( A( J, J ) )                  
                     DO 100, I = J - 1, 1, -1                           
                        TEMP = TEMP + CONJG( A( I, J ) )*X( I )         
  100                CONTINUE                                           
                  END IF                                                
                  X( J ) = TEMP                                         
  110          CONTINUE                                                 
            ELSE                                                        
               JX = KX + ( N - 1 )*INCX                                 
               DO 140, J = N, 1, -1                                     
                  TEMP = X( JX )                                        
                  IX   = JX                                             
                  IF( NOCONJ )THEN                                      
                     IF( NOUNIT )                                         &
                        TEMP = TEMP*A( J, J )                           
                     DO 120, I = J - 1, 1, -1                           
                        IX   = IX   - INCX                              
                        TEMP = TEMP + A( I, J )*X( IX )                 
  120                CONTINUE                                           
                  ELSE                                                  
                     IF( NOUNIT )                                         &
                        TEMP = TEMP*CONJG( A( J, J ) )                  
                     DO 130, I = J - 1, 1, -1                           
                        IX   = IX   - INCX                              
                        TEMP = TEMP + CONJG( A( I, J ) )*X( IX )        
  130                CONTINUE                                           
                  END IF                                                
                  X( JX ) = TEMP                                        
                  JX      = JX   - INCX                                 
  140          CONTINUE                                                 
            END IF                                                      
         ELSE                                                           
            IF( INCX.EQ.1 )THEN                                         
               DO 170, J = 1, N                                         
                  TEMP = X( J )                                         
                  IF( NOCONJ )THEN                                      
                     IF( NOUNIT )                                         &
                        TEMP = TEMP*A( J, J )                           
                     DO 150, I = J + 1, N                               
                        TEMP = TEMP + A( I, J )*X( I )                  
  150                CONTINUE                                           
                  ELSE                                                  
                     IF( NOUNIT )                                         &
                        TEMP = TEMP*CONJG( A( J, J ) )                  
                     DO 160, I = J + 1, N                               
                        TEMP = TEMP + CONJG( A( I, J ) )*X( I )         
  160                CONTINUE                                           
                  END IF                                                
                  X( J ) = TEMP                                         
  170          CONTINUE                                                 
            ELSE                                                        
               JX = KX                                                  
               DO 200, J = 1, N                                         
                  TEMP = X( JX )                                        
                  IX   = JX                                             
                  IF( NOCONJ )THEN                                      
                     IF( NOUNIT )                                         &
                        TEMP = TEMP*A( J, J )                           
                     DO 180, I = J + 1, N                               
                        IX   = IX   + INCX                              
                        TEMP = TEMP + A( I, J )*X( IX )                 
  180                CONTINUE                                           
                  ELSE                                                  
                     IF( NOUNIT )                                         &
                        TEMP = TEMP*CONJG( A( J, J ) )                  
                     DO 190, I = J + 1, N                               
                        IX   = IX   + INCX                              
                        TEMP = TEMP + CONJG( A( I, J ) )*X( IX )        
  190                CONTINUE                                           
                  END IF                                                
                  X( JX ) = TEMP                                        
                  JX      = JX   + INCX                                 
  200          CONTINUE                                                 
            END IF                                                      
         END IF                                                         
      END IF                                                            
!                                                                       
      RETURN                                                            
!                                                                       
!     End of CSVD_CTRMV .                                                    
!                                                                       
      END  SUBROUTINE CSVD_CTRMV
                                                             
      SUBROUTINE CSVD_CGERC ( M, N, ALPHA, X, INCX, Y, INCY, A, LDA )        
!     .. Scalar Arguments ..                                            
      COMPLEX            ALPHA                                          
      INTEGER            INCX, INCY, LDA, M, N                          
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * ), X( * ), Y( * )                    
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CGERC  performs the rank 1 operation                                 
!                                                                       
!     A := alpha*x*conjg( y' ) + A,                                     
!                                                                       
!  where alpha is a scalar, x is an m element vector, y is an n element 
!  vector and A is an m by n matrix.                                    
!                                                                       
!  Parameters                                                           
!  ==========                                                           
!                                                                       
!  M      - INTEGER.                                                    
!           On entry, M specifies the number of rows of the matrix A.   
!           M must be at least zero.                                    
!           Unchanged on exit.                                          
!                                                                       
!  N      - INTEGER.                                                    
!           On entry, N specifies the number of columns of the matrix A.
!           N must be at least zero.                                    
!           Unchanged on exit.                                          
!                                                                       
!  ALPHA  - COMPLEX         .                                           
!           On entry, ALPHA specifies the scalar alpha.                 
!           Unchanged on exit.                                          
!                                                                       
!  X      - COMPLEX          array of dimension at least                
!           ( 1 + ( m - 1 )*abs( INCX ) ).                              
!           Before entry, the incremented array X must contain the m    
!           element vector x.                                           
!           Unchanged on exit.                                          
!                                                                       
!  INCX   - INTEGER.                                                    
!           On entry, INCX specifies the increment for the elements of  
!           X. INCX must not be zero.                                   
!           Unchanged on exit.                                          
!                                                                       
!  Y      - COMPLEX          array of dimension at least                
!           ( 1 + ( n - 1 )*abs( INCY ) ).                              
!           Before entry, the incremented array Y must contain the n    
!           element vector y.                                           
!           Unchanged on exit.                                          
!                                                                       
!  INCY   - INTEGER.                                                    
!           On entry, INCY specifies the increment for the elements of  
!           Y. INCY must not be zero.                                   
!           Unchanged on exit.                                          
!                                                                       
!  A      - COMPLEX          array of DIMENSION ( LDA, n ).             
!           Before entry, the leading m by n part of the array A must   
!           contain the matrix of coefficients. On exit, A is           
!           overwritten by the updated matrix.                          
!                                                                       
!  LDA    - INTEGER.                                                    
!           On entry, LDA specifies the first dimension of A as declared
!           in the calling (sub) program. LDA must be at least          
!           max( 1, m ).                                                
!           Unchanged on exit.                                          
!                                                                       
!                                                                       
!  Level 2 Blas routine.                                                
!                                                                       
!  -- Written on 22-October-1986.                                       
!     Jack Dongarra, Argonne National Lab.                              
!     Jeremy Du Croz, Nag Central Office.                               
!     Sven Hammarling, Nag Central Office.                              
!     Richard Hanson, Sandia National Labs.                             
!                                                                       
!                                                                       
!     .. Parameters ..                                                  
      COMPLEX            ZERO                                           
!      PARAMETER        ( ZERO = CMPLX( 0.0E+0, 0.0E+0 ) )
!     .. Local Scalars ..                                               
      COMPLEX            TEMP                                           
      INTEGER            I, INFO, IX, J, JY, KX                         
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_XERBLA                                         
!     .. Intrinsic Functions ..                                         
      INTRINSIC          CONJG, MAX                                     
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       

      ZERO = CMPLX( 0.0E+0, 0.0E+0 ) 

      INFO = 0                                                          
      IF     ( M.LT.0 )THEN                                             
         INFO = 1                                                       
      ELSE IF( N.LT.0 )THEN                                             
         INFO = 2                                                       
      ELSE IF( INCX.EQ.0 )THEN                                          
         INFO = 5                                                       
      ELSE IF( INCY.EQ.0 )THEN                                          
         INFO = 7                                                       
      ELSE IF( LDA.LT.MAX( 1, M ) )THEN                                 
         INFO = 9                                                       
      END IF                                                            
      IF( INFO.NE.0 )THEN                                               
         CALL CSVD_XERBLA( 'CSVD_CGERC ', INFO )
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.( ALPHA.EQ.ZERO ) )                 &
         RETURN                                                         
!                                                                       
!     Start the operations. In this version the elements of A are       
!     accessed sequentially with one pass through A.                    
!                                                                       
      IF( INCY.GT.0 )THEN                                               
         JY = 1                                                         
      ELSE                                                              
         JY = 1 - ( N - 1 )*INCY                                        
      END IF                                                            
      IF( INCX.EQ.1 )THEN                                               
         DO 20, J = 1, N                                                
            IF( Y( JY ).NE.ZERO )THEN                                   
               TEMP = ALPHA*CONJG( Y( JY ) )                            
               DO 10, I = 1, M                                          
                  A( I, J ) = A( I, J ) + X( I )*TEMP                   
   10          CONTINUE                                                 
            END IF                                                      
            JY = JY + INCY                                              
   20    CONTINUE                                                       
      ELSE                                                              
         IF( INCX.GT.0 )THEN                                            
            KX = 1                                                      
         ELSE                                                           
            KX = 1 - ( M - 1 )*INCX                                     
         END IF                                                         
         DO 40, J = 1, N                                                
            IF( Y( JY ).NE.ZERO )THEN                                   
               TEMP = ALPHA*CONJG( Y( JY ) )                            
               IX   = KX                                                
               DO 30, I = 1, M                                          
                  A( I, J ) = A( I, J ) + X( IX )*TEMP                  
                  IX        = IX        + INCX                          
   30          CONTINUE                                                 
            END IF                                                      
            JY = JY + INCY                                              
   40    CONTINUE
      END IF                                                            
!                                                                       
      RETURN                                                            
!                                                                       
!     End of CSVD_CGERC .                                                    
!                                                                       
      END  SUBROUTINE CSVD_CGERC
                                                             
      SUBROUTINE CSVD_CGEMM ( TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, &
                         BETA, C, LDC )                                 
!     .. Scalar Arguments ..                                            
      CHARACTER*1        TRANSA, TRANSB                                 
      INTEGER            M, N, K, LDA, LDB, LDC                         
      COMPLEX            ALPHA, BETA                                    
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * ), B( LDB, * ), C( LDC, * )          
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CGEMM  performs one of the matrix-matrix operations                  
!                                                                       
!     C := alpha*op( A )*op( B ) + beta*C,                              
!                                                                       
!  where  op( X ) is one of                                             
!                                                                       
!     op( X ) = X   or   op( X ) = X'   or   op( X ) = conjg( X' ),     
!                                                                       
!  alpha and beta are scalars, and A, B and C are matrices, with op( A )
!  an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.
!                                                                       
!  Parameters                                                           
!  ==========                                                           
!                                                                       
!  TRANSA - CHARACTER*1.                                                
!           On entry, TRANSA specifies the form of op( A ) to be used in
!           the matrix multiplication as follows:                       
!                                                                       
!              TRANSA = 'N' or 'n',  op( A ) = A.                       
!                                                                       
!              TRANSA = 'T' or 't',  op( A ) = A'.                      
!                                                                       
!              TRANSA = 'C' or 'c',  op( A ) = conjg( A' ).             
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  TRANSB - CHARACTER*1.                                                
!           On entry, TRANSB specifies the form of op( B ) to be used in
!           the matrix multiplication as follows:                       
!                                                                       
!              TRANSB = 'N' or 'n',  op( B ) = B.                       
!                                                                       
!              TRANSB = 'T' or 't',  op( B ) = B'.                      
!                                                                       
!              TRANSB = 'C' or 'c',  op( B ) = conjg( B' ).             
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  M      - INTEGER.                                                    
!           On entry,  M  specifies  the number  of rows  of the  matrix
!           op( A )  and of the  matrix  C.  M  must  be at least  zero.
!           Unchanged on exit.                                          
!                                                                       
!  N      - INTEGER.                                                    
!           On entry,  N  specifies the number  of columns of the matrix
!           op( B ) and the number of columns of the matrix C. N must be
!           at least zero.                                              
!           Unchanged on exit.                                          
!                                                                       
!  K      - INTEGER.                                                    
!           On entry,  K  specifies  the number of columns of the matrix
!           op( A ) and the number of rows of the matrix op( B ). K must
!           be at least  zero.                                          
!           Unchanged on exit.                                          
!                                                                       
!  ALPHA  - COMPLEX         .                                           
!           On entry, ALPHA specifies the scalar alpha.                 
!           Unchanged on exit.                                          
!                                                                       
!  A      - COMPLEX          array of DIMENSION ( LDA, ka ), where ka is
!           k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.        
!           Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
!           part of the array  A  must contain the matrix  A,  otherwise
!           the leading  k by m  part of the array  A  must contain  the
!           matrix A.                                                   
!           Unchanged on exit.                                          
!                                                                       
!  LDA    - INTEGER.                                                    
!           On entry, LDA specifies the first dimension of A as declared
!           in the calling (sub) program. When  TRANSA = 'N' or 'n' then
!           LDA must be at least  max( 1, m ), otherwise  LDA must be at
!           least  max( 1, k ).                                         
!           Unchanged on exit.                                          
!                                                                       
!  B      - COMPLEX          array of DIMENSION ( LDB, kb ), where kb is
!           n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.        
!           Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
!           part of the array  B  must contain the matrix  B,  otherwise
!           the leading  n by k  part of the array  B  must contain  the
!           matrix B.                                                   
!           Unchanged on exit.                                          
!                                                                       
!  LDB    - INTEGER.                                                    
!           On entry, LDB specifies the first dimension of B as declared
!           in the calling (sub) program. When  TRANSB = 'N' or 'n' then
!           LDB must be at least  max( 1, k ), otherwise  LDB must be at
!           least  max( 1, n ).                                         
!           Unchanged on exit.                                          
!                                                                       
!  BETA   - COMPLEX         .                                           
!           On entry,  BETA  specifies the scalar  beta.  When  BETA  is
!           supplied as zero then C need not be set on input.           
!           Unchanged on exit.                                          
!                                                                       
!  C      - COMPLEX          array of DIMENSION ( LDC, n ).             
!           Before entry, the leading  m by n  part of the array  C must
!           contain the matrix  C,  except when  beta  is zero, in which
!           case C need not be set on entry.                            
!           On exit, the array  C  is overwritten by the  m by n  matrix
!           ( alpha*op( A )*op( B ) + beta*C ).                         
!                                                                       
!  LDC    - INTEGER.                                                    
!           On entry, LDC specifies the first dimension of C as declared
!           in  the  calling  (sub)  program.   LDC  must  be  at  least
!           max( 1, m ).                                                
!           Unchanged on exit.                                          
!                                                                       
!                                                                       
!  Level 3 Blas routine.                                                
!                                                                       
!  -- Written on 8-February-1989.                                       
!     Jack Dongarra, Argonne National Laboratory.                       
!     Iain Duff, AERE Harwell.                                          
!     Jeremy Du Croz, Numerical Algorithms Group Ltd.                   
!     Sven Hammarling, Numerical Algorithms Group Ltd.                  
!                                                                       
!                                                                       
!     .. External Functions ..                                          
!      LOGICAL            csvd_lsame                                          
!      EXTERNAL           csvd_lsame                                          
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_XERBLA                                         
!     .. Intrinsic Functions ..                                         
      INTRINSIC          CONJG, MAX                                     
!     .. Local Scalars ..                                               
      LOGICAL            CONJA, CONJB, NOTA, NOTB                       
      INTEGER            I, INFO, J, L, NCOLA, NROWA, NROWB             
      COMPLEX            TEMP                                           
!     .. Parameters ..                                                  
      COMPLEX            ONE                                            
!      PARAMETER        ( ONE  = CMPLX( 1.0E+0, 0.0E+0 ) )
      COMPLEX            ZERO                                           
!      PARAMETER        ( ZERO = CMPLX( 0.0E+0, 0.0E+0 ) )
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not
!     conjugated or transposed, set  CONJA and CONJB  as true if  A  and
!     B  respectively are to be  transposed but  not conjugated  and set
!     NROWA, NCOLA and  NROWB  as the number of rows and  columns  of  A
!     and the number of rows of  B  respectively.                       
!                                                                       

      ONE  = CMPLX( 1.0E+0, 0.0E+0 )               
      ZERO = CMPLX( 0.0E+0, 0.0E+0 ) 

      NOTA  = csvd_lsame( TRANSA, 'N' )                                      
      NOTB  = csvd_lsame( TRANSB, 'N' )                                      
      CONJA = csvd_lsame( TRANSA, 'C' )                                      
      CONJB = csvd_lsame( TRANSB, 'C' )                                      
      IF( NOTA )THEN                                                    
         NROWA = M                                                      
         NCOLA = K                                                      
      ELSE                                                              
         NROWA = K                                                      
         NCOLA = M                                                      
      END IF                                                            
      IF( NOTB )THEN                                                    
         NROWB = K                                                      
      ELSE                                                              
         NROWB = N                                                      
      END IF                                                            
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      INFO = 0                                                          
      IF(      ( .NOT.NOTA                 ).AND.                         &
               ( .NOT.CONJA                ).AND.                         &
               ( .NOT.csvd_lsame( TRANSA, 'T' ) )      )THEN                 
         INFO = 1                                                       
      ELSE IF( ( .NOT.NOTB                 ).AND.                         &
               ( .NOT.CONJB                ).AND.                         &
               ( .NOT.csvd_lsame( TRANSB, 'T' ) )      )THEN                 
         INFO = 2                                                       
      ELSE IF( M  .LT.0               )THEN                             
         INFO = 3                                                       
      ELSE IF( N  .LT.0               )THEN                             
         INFO = 4                                                       
      ELSE IF( K  .LT.0               )THEN                             
         INFO = 5                                                       
      ELSE IF( LDA.LT.MAX( 1, NROWA ) )THEN                             
         INFO = 8                                                       
      ELSE IF( LDB.LT.MAX( 1, NROWB ) )THEN                             
         INFO = 10                                                      
      ELSE IF( LDC.LT.MAX( 1, M     ) )THEN                             
         INFO = 13                                                      
      END IF                                                            
      IF( INFO.NE.0 )THEN                                               
         CALL CSVD_XERBLA( 'CSVD_CGEMM ', INFO )
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF( ( M.EQ.0 ).OR.( N.EQ.0 ).OR.                                    &
          ( ( ( ALPHA.EQ.ZERO ).OR.( K.EQ.0 ) ).AND.( BETA.EQ.ONE ) ) )   &
         RETURN                                                         
!                                                                       
!     And when  alpha.eq.zero.                                          
!                                                                       
      IF( ALPHA.EQ.ZERO )THEN                                           
         IF( BETA.EQ.ZERO )THEN                                         
            DO 20, J = 1, N                                             
               DO 10, I = 1, M                                          
                  C( I, J ) = ZERO                                      
   10          CONTINUE                                                 
   20       CONTINUE                                                    
         ELSE                                                           
            DO 40, J = 1, N                                             
               DO 30, I = 1, M                                          
                  C( I, J ) = BETA*C( I, J )                            
   30          CONTINUE                                                 
   40       CONTINUE                                                    
         END IF                                                         
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Start the operations.                                             
!                                                                       
      IF( NOTB )THEN                                                    
         IF( NOTA )THEN                                                 
!                                                                       
!           Form  C := alpha*A*B + beta*C.                              
!                                                                       
            DO 90, J = 1, N                                             
               IF( BETA.EQ.ZERO )THEN                                   
                  DO 50, I = 1, M                                       
                     C( I, J ) = ZERO                                   
   50             CONTINUE                                              
               ELSE IF( BETA.NE.ONE )THEN                               
                  DO 60, I = 1, M                                       
                     C( I, J ) = BETA*C( I, J )                         
   60             CONTINUE                                              
               END IF                                                   
               DO 80, L = 1, K                                          
                  IF( B( L, J ).NE.ZERO )THEN                           
                     TEMP = ALPHA*B( L, J )                             
                     DO 70, I = 1, M                                    
                        C( I, J ) = C( I, J ) + TEMP*A( I, L )          
   70                CONTINUE                                           
                  END IF                                                
   80          CONTINUE                                                 
   90       CONTINUE                                                    
         ELSE IF( CONJA )THEN                                           
!                                                                       
!           Form  C := alpha*conjg( A' )*B + beta*C.                    
!                                                                       
            DO 120, J = 1, N                                            
               DO 110, I = 1, M                                         
                  TEMP = ZERO                                           
                  DO 100, L = 1, K                                      
                     TEMP = TEMP + CONJG( A( L, I ) )*B( L, J )         
  100             CONTINUE                                              
                  IF( BETA.EQ.ZERO )THEN                                
                     C( I, J ) = ALPHA*TEMP                             
                  ELSE                                                  
                     C( I, J ) = ALPHA*TEMP + BETA*C( I, J )            
                  END IF                                                
  110          CONTINUE                                                 
  120       CONTINUE                                                    
         ELSE                                                           
!                                                                       
!           Form  C := alpha*A'*B + beta*C                              
!                                                                       
            DO 150, J = 1, N                                            
               DO 140, I = 1, M                                         
                  TEMP = ZERO                                           
                  DO 130, L = 1, K                                      
                     TEMP = TEMP + A( L, I )*B( L, J )                  
  130             CONTINUE                                              
                  IF( BETA.EQ.ZERO )THEN                                
                     C( I, J ) = ALPHA*TEMP                             
                  ELSE                                                  
                     C( I, J ) = ALPHA*TEMP + BETA*C( I, J )            
                  END IF                                                
  140          CONTINUE                                                 
  150       CONTINUE                                                    
         END IF                                                         
      ELSE IF( NOTA )THEN                                               
         IF( CONJB )THEN                                                
!                                                                       
!           Form  C := alpha*A*conjg( B' ) + beta*C.                    
!                                                                       
            DO 200, J = 1, N                                            
               IF( BETA.EQ.ZERO )THEN                                   
                  DO 160, I = 1, M                                      
                     C( I, J ) = ZERO                                   
  160             CONTINUE                                              
               ELSE IF( BETA.NE.ONE )THEN                               
                  DO 170, I = 1, M                                      
                     C( I, J ) = BETA*C( I, J )                         
  170             CONTINUE                                              
               END IF                                                   
               DO 190, L = 1, K                                         
                  IF( B( J, L ).NE.ZERO )THEN                           
                     TEMP = ALPHA*CONJG( B( J, L ) )                    
                     DO 180, I = 1, M                                   
                        C( I, J ) = C( I, J ) + TEMP*A( I, L )          
  180                CONTINUE                                           
                  END IF                                                
  190          CONTINUE                                                 
  200       CONTINUE                                                    
         ELSE                                                           
!                                                                       
!           Form  C := alpha*A*B'          + beta*C                     
!                                                                       
            DO 250, J = 1, N                                            
               IF( BETA.EQ.ZERO )THEN                                   
                  DO 210, I = 1, M                                      
                     C( I, J ) = ZERO                                   
  210             CONTINUE                                              
               ELSE IF( BETA.NE.ONE )THEN                               
                  DO 220, I = 1, M                                      
                     C( I, J ) = BETA*C( I, J )                         
  220             CONTINUE                                              
               END IF                                                   
               DO 240, L = 1, K                                         
                  IF( B( J, L ).NE.ZERO )THEN                           
                     TEMP = ALPHA*B( J, L )                             
                     DO 230, I = 1, M                                   
                        C( I, J ) = C( I, J ) + TEMP*A( I, L )          
  230                CONTINUE                                           
                  END IF                                                
  240          CONTINUE                                                 
  250       CONTINUE                                                    
         END IF                                                         
      ELSE IF( CONJA )THEN                                              
         IF( CONJB )THEN                                                
!                                                                       
!           Form  C := alpha*conjg( A' )*conjg( B' ) + beta*C.          
!                                                                       
            DO 280, J = 1, N                                            
               DO 270, I = 1, M                                         
                  TEMP = ZERO                                           
                  DO 260, L = 1, K                                      
                     TEMP = TEMP + CONJG( A( L, I ) )*CONJG( B( J, L ) )
  260             CONTINUE                                              
                  IF( BETA.EQ.ZERO )THEN                                
                     C( I, J ) = ALPHA*TEMP                             
                  ELSE                                                  
                     C( I, J ) = ALPHA*TEMP + BETA*C( I, J )            
                  END IF                                                
  270          CONTINUE                                                 
  280       CONTINUE                                                    
         ELSE                                                           
!                                                                       
!           Form  C := alpha*conjg( A' )*B' + beta*C                    
!                                                                       
            DO 310, J = 1, N                                            
               DO 300, I = 1, M                                         
                  TEMP = ZERO                                           
                  DO 290, L = 1, K                                      
                     TEMP = TEMP + CONJG( A( L, I ) )*B( J, L )         
  290             CONTINUE                                              
                  IF( BETA.EQ.ZERO )THEN                                
                     C( I, J ) = ALPHA*TEMP                             
                  ELSE                                                  
                     C( I, J ) = ALPHA*TEMP + BETA*C( I, J )            
                  END IF                                                
  300          CONTINUE                                                 
  310       CONTINUE                                                    
         END IF                                                         
      ELSE                                                              
         IF( CONJB )THEN                                                
!                                                                       
!           Form  C := alpha*A'*conjg( B' ) + beta*C                    
!                                                                       
            DO 340, J = 1, N                                            
               DO 330, I = 1, M                                         
                  TEMP = ZERO                                           
                  DO 320, L = 1, K                                      
                     TEMP = TEMP + A( L, I )*CONJG( B( J, L ) )         
  320             CONTINUE                                              
                  IF( BETA.EQ.ZERO )THEN                                
                     C( I, J ) = ALPHA*TEMP                             
                  ELSE                                                  
                     C( I, J ) = ALPHA*TEMP + BETA*C( I, J )            
                  END IF                                                
  330          CONTINUE                                                 
  340       CONTINUE                                                    
         ELSE                                                           
!                                                                       
!           Form  C := alpha*A'*B' + beta*C                             
!                                                                       
            DO 370, J = 1, N                                            
               DO 360, I = 1, M                                         
                  TEMP = ZERO                                           
                  DO 350, L = 1, K                                      
                     TEMP = TEMP + A( L, I )*B( J, L )                  
  350             CONTINUE                                              
                  IF( BETA.EQ.ZERO )THEN                                
                     C( I, J ) = ALPHA*TEMP                             
                  ELSE                                                  
                     C( I, J ) = ALPHA*TEMP + BETA*C( I, J )            
                  END IF                                                
  360          CONTINUE                                                 
  370       CONTINUE                                                    
         END IF                                                         
      END IF                                                            
!                                                                       
      RETURN                                                            
!                                                                       
!     End of CSVD_CGEMM .                                                    
!                                                                       
      END SUBROUTINE CSVD_CGEMM
                                                              
      SUBROUTINE CSVD_CTRMM ( SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, &
                         B, LDB )                                       
!     .. Scalar Arguments ..                                            
      CHARACTER*1        SIDE, UPLO, TRANSA, DIAG                       
      INTEGER            M, N, LDA, LDB                                 
      COMPLEX            ALPHA                                          
!     .. Array Arguments ..                                             
      COMPLEX            A( LDA, * ), B( LDB, * )                       
!     ..                                                                
!                                                                       
!  Purpose                                                              
!  =======                                                              
!                                                                       
!  CSVD_CTRMM  performs one of the matrix-matrix operations                  
!                                                                       
!     B := alpha*op( A )*B,   or   B := alpha*B*op( A )                 
!                                                                       
!  where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
!  non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
!                                                                       
!     op( A ) = A   or   op( A ) = A'   or   op( A ) = conjg( A' ).     
!                                                                       
!  Parameters                                                           
!  ==========                                                           
!                                                                       
!  SIDE   - CHARACTER*1.                                                
!           On entry,  SIDE specifies whether  op( A ) multiplies B from
!           the left or right as follows:                               
!                                                                       
!              SIDE = 'L' or 'l'   B := alpha*op( A )*B.                
!                                                                       
!              SIDE = 'R' or 'r'   B := alpha*B*op( A ).                
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  UPLO   - CHARACTER*1.                                                
!           On entry, UPLO specifies whether the matrix A is an upper or
!           lower triangular matrix as follows:                         
!                                                                       
!              UPLO = 'U' or 'u'   A is an upper triangular matrix.     
!                                                                       
!              UPLO = 'L' or 'l'   A is a lower triangular matrix.      
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  TRANSA - CHARACTER*1.                                                
!           On entry, TRANSA specifies the form of op( A ) to be used in
!           the matrix multiplication as follows:                       
!                                                                       
!              TRANSA = 'N' or 'n'   op( A ) = A.                       
!                                                                       
!              TRANSA = 'T' or 't'   op( A ) = A'.                      
!                                                                       
!              TRANSA = 'C' or 'c'   op( A ) = conjg( A' ).             
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  DIAG   - CHARACTER*1.                                                
!           On entry, DIAG specifies whether or not A is unit triangular
!           as follows:                                                 
!                                                                       
!              DIAG = 'U' or 'u'   A is assumed to be unit triangular.  
!                                                                       
!              DIAG = 'N' or 'n'   A is not assumed to be unit          
!                                  triangular.                          
!                                                                       
!           Unchanged on exit.                                          
!                                                                       
!  M      - INTEGER.                                                    
!           On entry, M specifies the number of rows of B. M must be at 
!           least zero.                                                 
!           Unchanged on exit.                                          
!                                                                       
!  N      - INTEGER.                                                    
!           On entry, N specifies the number of columns of B.  N must be
!           at least zero.                                              
!           Unchanged on exit.                                          
!                                                                       
!  ALPHA  - COMPLEX         .                                           
!           On entry,  ALPHA specifies the scalar  alpha. When  alpha is
!           zero then  A is not referenced and  B need not be set before
!           entry.                                                      
!           Unchanged on exit.                                          
!                                                                       
!  A      - COMPLEX          array of DIMENSION ( LDA, k ), where k is m
!           when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
!           Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
!           upper triangular part of the array  A must contain the upper
!           triangular matrix  and the strictly lower triangular part of
!           A is not referenced.                                        
!           Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
!           lower triangular part of the array  A must contain the lower
!           triangular matrix  and the strictly upper triangular part of
!           A is not referenced.                                        
!           Note that when  DIAG = 'U' or 'u',  the diagonal elements of
!           A  are not referenced either,  but are assumed to be  unity.
!           Unchanged on exit.                                          
!                                                                       
!  LDA    - INTEGER.                                                    
!           On entry, LDA specifies the first dimension of A as declared
!           in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
!           LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
!           then LDA must be at least max( 1, n ).                      
!           Unchanged on exit.                                          
!                                                                       
!  B      - COMPLEX          array of DIMENSION ( LDB, n ).             
!           Before entry,  the leading  m by n part of the array  B must
!           contain the matrix  B,  and  on exit  is overwritten  by the
!           transformed matrix.                                         
!                                                                       
!  LDB    - INTEGER.                                                    
!           On entry, LDB specifies the first dimension of B as declared
!           in  the  calling  (sub)  program.   LDB  must  be  at  least
!           max( 1, m ).                                                
!           Unchanged on exit.                                          
!                                                                       
!                                                                       
!  Level 3 Blas routine.                                                
!                                                                       
!  -- Written on 8-February-1989.                                       
!     Jack Dongarra, Argonne National Laboratory.                       
!     Iain Duff, AERE Harwell.                                          
!     Jeremy Du Croz, Numerical Algorithms Group Ltd.                   
!     Sven Hammarling, Numerical Algorithms Group Ltd.                  
!                                                                       
!                                                                       
!     .. External Functions ..                                          
!      LOGICAL            csvd_lsame                                          
!      EXTERNAL           csvd_lsame                                          
!     .. External Subroutines ..                                        
!      EXTERNAL           CSVD_XERBLA                                         
!     .. Intrinsic Functions ..                                         
      INTRINSIC          CONJG, MAX                                     
!     .. Local Scalars ..                                               
      LOGICAL            LSIDE, NOCONJ, NOUNIT, UPPER                   
      INTEGER            I, INFO, J, K, NROWA                           
      COMPLEX            TEMP                                           
!     .. Parameters ..                                                  
      COMPLEX            ONE                                            
!      PARAMETER        ( ONE  = CMPLX( 1.0E+0, 0.0E+0 ) )
      COMPLEX            ZERO                                           
!      PARAMETER        ( ZERO = CMPLX( 0.0E+0, 0.0E+0 ) )
!     ..                                                                
!     .. Executable Statements ..                                       
!                                                                       
!     Test the input parameters.                                        
!                                                                       
      ONE  = CMPLX( 1.0E+0, 0.0E+0 )               
      ZERO = CMPLX( 0.0E+0, 0.0E+0 ) 

      LSIDE  = csvd_lsame( SIDE  , 'L' )                                     
      IF( LSIDE )THEN                                                   
         NROWA = M                                                      
      ELSE                                                              
         NROWA = N                                                      
      END IF                                                            
      NOCONJ = csvd_lsame( TRANSA, 'T' )                                     
      NOUNIT = csvd_lsame( DIAG  , 'N' )                                     
      UPPER  = csvd_lsame( UPLO  , 'U' )                                     
!                                                                       
      INFO   = 0                                                        
      IF(      ( .NOT.LSIDE                ).AND.                         &
               ( .NOT.csvd_lsame( SIDE  , 'R' ) )      )THEN                 
         INFO = 1                                                       
      ELSE IF( ( .NOT.UPPER                ).AND.                         &
               ( .NOT.csvd_lsame( UPLO  , 'L' ) )      )THEN                 
         INFO = 2                                                       
      ELSE IF( ( .NOT.csvd_lsame( TRANSA, 'N' ) ).AND.                    &
               ( .NOT.csvd_lsame( TRANSA, 'T' ) ).AND.                    &
               ( .NOT.csvd_lsame( TRANSA, 'C' ) )      )THEN                 
         INFO = 3                                                       
      ELSE IF( ( .NOT.csvd_lsame( DIAG  , 'U' ) ).AND.                    &
               ( .NOT.csvd_lsame( DIAG  , 'N' ) )      )THEN                 
         INFO = 4                                                       
      ELSE IF( M  .LT.0               )THEN                             
         INFO = 5                                                       
      ELSE IF( N  .LT.0               )THEN                             
         INFO = 6                                                       
      ELSE IF( LDA.LT.MAX( 1, NROWA ) )THEN                             
         INFO = 9                                                       
      ELSE IF( LDB.LT.MAX( 1, M     ) )THEN                             
         INFO = 11                                                      
      END IF                                                            
      IF( INFO.NE.0 )THEN                                               
         CALL CSVD_XERBLA( 'CSVD_CTRMM ', INFO )
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Quick return if possible.                                         
!                                                                       
      IF( N.EQ.0 )                                                        &
         RETURN                                                         
!                                                                       
!     And when  alpha.eq.zero.                                          
!                                                                       
      IF( ALPHA.EQ.ZERO )THEN                                           
         DO 20, J = 1, N                                                
            DO 10, I = 1, M                                             
               B( I, J ) = ZERO                                         
   10       CONTINUE                                                    
   20    CONTINUE                                                       
         RETURN                                                         
      END IF                                                            
!                                                                       
!     Start the operations.                                             
!                                                                       
      IF( LSIDE )THEN                                                   
         IF( csvd_lsame( TRANSA, 'N' ) )THEN                                 
!                                                                       
!           Form  B := alpha*A*B.                                       
!                                                                       
            IF( UPPER )THEN                                             
               DO 50, J = 1, N                                          
                  DO 40, K = 1, M                                       
                     IF( B( K, J ).NE.ZERO )THEN                        
                        TEMP = ALPHA*B( K, J )                          
                        DO 30, I = 1, K - 1                             
                           B( I, J ) = B( I, J ) + TEMP*A( I, K )       
   30                   CONTINUE                                        
                        IF( NOUNIT )                                      &
                           TEMP = TEMP*A( K, K )                        
                        B( K, J ) = TEMP                                
                     END IF                                             
   40             CONTINUE                                              
   50          CONTINUE                                                 
            ELSE                                                        
               DO 80, J = 1, N                                          
                  DO 70 K = M, 1, -1                                    
                     IF( B( K, J ).NE.ZERO )THEN                        
                        TEMP      = ALPHA*B( K, J )                     
                        B( K, J ) = TEMP                                
                        IF( NOUNIT )                                      &
                           B( K, J ) = B( K, J )*A( K, K )              
                        DO 60, I = K + 1, M                             
                           B( I, J ) = B( I, J ) + TEMP*A( I, K )       
   60                   CONTINUE                                        
                     END IF                                             
   70             CONTINUE                                              
   80          CONTINUE                                                 
            END IF                                                      
         ELSE                                                           
!                                                                       
!           Form  B := alpha*A'*B   or   B := alpha*conjg( A' )*B.      
!                                                                       
            IF( UPPER )THEN                                             
               DO 120, J = 1, N                                         
                  DO 110, I = M, 1, -1                                  
                     TEMP = B( I, J )                                   
                     IF( NOCONJ )THEN                                   
                        IF( NOUNIT )                                      &
                           TEMP = TEMP*A( I, I )                        
                        DO 90, K = 1, I - 1                             
                           TEMP = TEMP + A( K, I )*B( K, J )            
   90                   CONTINUE                                        
                     ELSE                                               
                        IF( NOUNIT )                                      &
                           TEMP = TEMP*CONJG( A( I, I ) )               
                        DO 100, K = 1, I - 1                            
                           TEMP = TEMP + CONJG( A( K, I ) )*B( K, J )   
  100                   CONTINUE                                        
                     END IF                                             
                     B( I, J ) = ALPHA*TEMP                             
  110             CONTINUE                                              
  120          CONTINUE                                                 
            ELSE                                                        
               DO 160, J = 1, N                                         
                  DO 150, I = 1, M                                      
                     TEMP = B( I, J )                                   
                     IF( NOCONJ )THEN                                   
                        IF( NOUNIT )                                      &
                           TEMP = TEMP*A( I, I )                        
                        DO 130, K = I + 1, M                            
                           TEMP = TEMP + A( K, I )*B( K, J )            
  130                   CONTINUE                                        
                     ELSE                                               
                        IF( NOUNIT )                                      &
                           TEMP = TEMP*CONJG( A( I, I ) )               
                        DO 140, K = I + 1, M                            
                           TEMP = TEMP + CONJG( A( K, I ) )*B( K, J )   
  140                   CONTINUE                                        
                     END IF                                             
                     B( I, J ) = ALPHA*TEMP                             
  150             CONTINUE                                              
  160          CONTINUE                                                 
            END IF                                                      
         END IF                                                         
      ELSE                                                              
         IF( csvd_lsame( TRANSA, 'N' ) )THEN                                 
!                                                                       
!           Form  B := alpha*B*A.                                       
!                                                                       
            IF( UPPER )THEN                                             
               DO 200, J = N, 1, -1                                     
                  TEMP = ALPHA                                          
                  IF( NOUNIT )                                            &
                     TEMP = TEMP*A( J, J )                              
                  DO 170, I = 1, M                                      
                     B( I, J ) = TEMP*B( I, J )                         
  170             CONTINUE                                              
                  DO 190, K = 1, J - 1                                  
                     IF( A( K, J ).NE.ZERO )THEN                        
                        TEMP = ALPHA*A( K, J )                          
                        DO 180, I = 1, M                                
                           B( I, J ) = B( I, J ) + TEMP*B( I, K )       
  180                   CONTINUE                                        
                     END IF                                             
  190             CONTINUE                                              
  200          CONTINUE                                                 
            ELSE                                                        
               DO 240, J = 1, N                                         
                  TEMP = ALPHA                                          
                  IF( NOUNIT )                                            &
                     TEMP = TEMP*A( J, J )                              
                  DO 210, I = 1, M                                      
                     B( I, J ) = TEMP*B( I, J )                         
  210             CONTINUE                                              
                  DO 230, K = J + 1, N                                  
                     IF( A( K, J ).NE.ZERO )THEN                        
                        TEMP = ALPHA*A( K, J )                          
                        DO 220, I = 1, M                                
                           B( I, J ) = B( I, J ) + TEMP*B( I, K )       
  220                   CONTINUE                                        
                     END IF                                             
  230             CONTINUE                                              
  240          CONTINUE                                                 
            END IF                                                      
         ELSE                                                           
!                                                                       
!           Form  B := alpha*B*A'   or   B := alpha*B*conjg( A' ).      
!                                                                       
            IF( UPPER )THEN                                             
               DO 280, K = 1, N                                         
                  DO 260, J = 1, K - 1                                  
                     IF( A( J, K ).NE.ZERO )THEN                        
                        IF( NOCONJ )THEN                                
                           TEMP = ALPHA*A( J, K )                       
                        ELSE                                            
                           TEMP = ALPHA*CONJG( A( J, K ) )              
                        END IF                                          
                        DO 250, I = 1, M                                
                           B( I, J ) = B( I, J ) + TEMP*B( I, K )       
  250                   CONTINUE                                        
                     END IF                                             
  260             CONTINUE                                              
                  TEMP = ALPHA                                          
                  IF( NOUNIT )THEN                                      
                     IF( NOCONJ )THEN                                   
                        TEMP = TEMP*A( K, K )                           
                     ELSE                                               
                        TEMP = TEMP*CONJG( A( K, K ) )                  
                     END IF                                             
                  END IF                                                
                  IF( TEMP.NE.ONE )THEN                                 
                     DO 270, I = 1, M                                   
                        B( I, K ) = TEMP*B( I, K )                      
  270                CONTINUE                                           
                  END IF                                                
  280          CONTINUE                                                 
            ELSE                                                        
               DO 320, K = N, 1, -1                                     
                  DO 300, J = K + 1, N                                  
                     IF( A( J, K ).NE.ZERO )THEN                        
                        IF( NOCONJ )THEN                                
                           TEMP = ALPHA*A( J, K )                       
                        ELSE                                            
                           TEMP = ALPHA*CONJG( A( J, K ) )              
                        END IF                                          
                        DO 290, I = 1, M                                
                           B( I, J ) = B( I, J ) + TEMP*B( I, K )       
  290                   CONTINUE                                        
                     END IF                                             
  300             CONTINUE                                              
                  TEMP = ALPHA                                          
                  IF( NOUNIT )THEN                                      
                     IF( NOCONJ )THEN                                   
                        TEMP = TEMP*A( K, K )                           
                     ELSE                                               
                        TEMP = TEMP*CONJG( A( K, K ) )                  
                     END IF                                             
                  END IF                                                
                  IF( TEMP.NE.ONE )THEN                                 
                     DO 310, I = 1, M                                   
                        B( I, K ) = TEMP*B( I, K )                      
  310                CONTINUE                                           
                  END IF                                                
  320          CONTINUE                                                 
            END IF                                                      
         END IF                                                         
      END IF                                                            
!                                                                       
      RETURN                                                            
!                                                                       
!     End of CSVD_CTRMM .                                                    
!                                                                       
      END SUBROUTINE CSVD_CTRMM
                                                                        
!!----------------------------- end of module -----------------------------!!
!!----------------------------- end of module -----------------------------!!
!!----------------------------- end of module -----------------------------!!


       end module csvd_module
!

!!--------------------------------- end -----------------------------------!!
!!--------------------------------- end -----------------------------------!!
!!--------------------------------- end -----------------------------------!!



