!<CPS_v1 type="AUXILIARY_FILE"/>
!!--------------------- XXXX_superwrap.f90 ----------------------!!
!!--------------------- XXXX_superwrap.f90 ----------------------!!
!!--------------------- XXXX_superwrap.f90 ----------------------!!


!<copyright>
!*******************************************************************************
!***********                    COPYRIGHT NOTICE                     ***********
!*********** CONFIDENTIAL AND PROPRIETARY INFORMATION OF CONOCO INC. ***********
!***********  PROTECTED BY THE COPYRIGHT LAW AS AN UNPUBLISHED WORK  ***********
!*******************************************************************************
!</copyright>


!<brief_doc>
!-------------------------------------------------------------------------------
!                           C P S   P R O C E S S     
!
! Name       : XXXX_superwrap
! Category   : cfe
! Written    : 2003-11-03   by: Tom Stoeckley
! Revised    : 2006-06-27   by: Tom Stoeckley
! Maturity   : MMMM
! Purpose    : Fortran wrapper around CPS process (for superproc).
! Portability: No known limitations.
!
! Automatically generated by program SPS_BUILD_SUPERPROC.
! Automatically generated using FPROC_SUPERWRAP_TEMPLATE.
! Dates and revision history refer to revisions of FPROC_SUPERWRAP_TEMPLATE.
!
!-------------------------------------------------------------------------------
!</brief_doc>


!<history_doc>
!-------------------------------------------------------------------------------
!                     AUXILIARY FILE REVISION HISTORY 
!
!     Date        Author     Description
!     ----        ------     -----------
!  3. 2006-06-27  Stoeckley  Add nullify statement for intel compiler.
!  2. 2003-11-04  Stoeckley  Add MATURITY key.
!  1. 2003-11-03  Stoeckley  Initial version of FPROC_SUPERWRAP_TEMPLATE.
!
!-------------------------------------------------------------------------------
!</history_doc>


!!------------------------------ module -----------------------------------!!
!!------------------------------ module -----------------------------------!!
!!------------------------------ module -----------------------------------!!


      module XXXX_superwrap_module
      use XXXX_module
      use string_module
      implicit none
      public

      character(len=100),public,save :: XXXX_superwrap_ident = &
'$Id: fproc_superwrap_template,v 1.3 2006/06/23 18:41:47 Stoeckley prod sps $'

      type :: XXXX_superwrap_struct
        type(XXXX_struct),pointer :: obj
      end type XXXX_superwrap_struct

      end module XXXX_superwrap_module


!!------------------------------ rcs --------------------------------------!!
!!------------------------------ rcs --------------------------------------!!
!!------------------------------ rcs --------------------------------------!!


      subroutine XXXX_superwrap_rcs (ident)           ! called from fortran
      use XXXX_superwrap_module
      implicit none
      character(len=*),intent(out) :: ident           ! argument

      ident = XXXX_ident

      end subroutine XXXX_superwrap_rcs


!!---------------------------- create ------------------------------------!!
!!---------------------------- create ------------------------------------!!
!!---------------------------- create ------------------------------------!!


      subroutine XXXX_superwrap_create (fpoint)  
      use XXXX_superwrap_module
      implicit none
      type(XXXX_superwrap_struct),intent(out)   :: fpoint
      type(XXXX_struct)          ,pointer       :: obj           ! local

      nullify (obj)                 ! for intel compiler.
      call XXXX_create (obj)
      fpoint%obj => obj

      end subroutine XXXX_superwrap_create


!!---------------------------- delete ------------------------------------!!
!!---------------------------- delete ------------------------------------!!
!!---------------------------- delete ------------------------------------!!


      subroutine XXXX_superwrap_delete (fpoint)   
      use XXXX_superwrap_module
      implicit none
      type(XXXX_superwrap_struct),intent(inout) :: fpoint
      type(XXXX_struct)          ,pointer       :: obj           ! local

      obj => fpoint%obj
      if (.not. associated(obj)) return
      call XXXX_delete (obj)
      fpoint%obj => obj

      end subroutine XXXX_superwrap_delete


!!------------------------------- init ------------------------------------!!
!!------------------------------- init ------------------------------------!!
!!------------------------------- init ------------------------------------!!


      subroutine XXXX_superwrap_init (fpoint)      
      use XXXX_superwrap_module
      implicit none
      type(XXXX_superwrap_struct),intent(inout) :: fpoint
      type(XXXX_struct)          ,pointer       :: obj           ! local

      obj => fpoint%obj
      if (.not. associated(obj)) return
      call XXXX_initialize (obj)

      end subroutine XXXX_superwrap_init


!!---------------------------- update ------------------------------------!!
!!---------------------------- update ------------------------------------!!
!!---------------------------- update ------------------------------------!!


      subroutine XXXX_superwrap_update (fpoint)     
      use XXXX_superwrap_module
      implicit none
      type(XXXX_superwrap_struct),intent(inout) :: fpoint
      type(XXXX_struct)          ,pointer       :: obj           ! local

      obj => fpoint%obj
      if (.not. associated(obj)) return
      call XXXX_update (obj)

      end subroutine XXXX_superwrap_update


!!---------------------------- wrapup ------------------------------------!!
!!---------------------------- wrapup ------------------------------------!!
!!---------------------------- wrapup ------------------------------------!!


      subroutine XXXX_superwrap_wrapup (fpoint)      
      use XXXX_superwrap_module
      implicit none
      type(XXXX_superwrap_struct),intent(inout) :: fpoint
      type(XXXX_struct)          ,pointer       :: obj           ! local

      obj => fpoint%obj
      if (.not. associated(obj)) return
      call XXXX_wrapup (obj)

      end subroutine XXXX_superwrap_wrapup


!!---------------------------- oneset ------------------------------------!!
!!---------------------------- oneset ------------------------------------!!
!!---------------------------- oneset ------------------------------------!!


      subroutine XXXX_superwrap_oneset (fpoint,ntr,  &
                                        hd,tr,lenhd,lentr,num)
      use XXXX_superwrap_module
      implicit none
      type(XXXX_superwrap_struct),intent(inout) :: fpoint
      integer                    ,intent(in)    :: lenhd,lentr,num  ! argument
      integer                    ,intent(inout) :: ntr              ! argument
      double precision           ,intent(inout) :: hd(lenhd,num)    ! argument
      real                       ,intent(inout) :: tr(lentr,num)    ! argument
      type(XXXX_struct)          ,pointer       :: obj              ! local

      obj => fpoint%obj
      if (.not. associated(obj)) return
ONE   call XXXX (obj,ntr,hd,tr)                ! might need commenting out.

      end subroutine XXXX_superwrap_oneset


!!---------------------------- twosets ------------------------------------!!
!!---------------------------- twosets ------------------------------------!!
!!---------------------------- twosets ------------------------------------!!


      subroutine XXXX_superwrap_twosets (fpoint,ntr,                 &
                                         hd1,tr1,lenhd1,lentr1,num1, &
                                         hd2,tr2,lenhd2,lentr2,num2)
      use XXXX_superwrap_module
      implicit none
      type(XXXX_superwrap_struct),intent(inout) :: fpoint
      integer                    ,intent(in)    :: lenhd1,lentr1,num1 ! argument
      integer                    ,intent(in)    :: lenhd2,lentr2,num2 ! argument
      integer                    ,intent(inout) :: ntr                ! argument
      double precision           ,intent(inout) :: hd1(lenhd1,num1)   ! argument
      real                       ,intent(inout) :: tr1(lentr1,num1)   ! argument
      double precision           ,intent(inout) :: hd2(lenhd2,num2)   ! argument
      real                       ,intent(inout) :: tr2(lentr2,num2)   ! argument
      type(XXXX_struct)          ,pointer       :: obj                ! local

      obj => fpoint%obj
      if (.not. associated(obj)) return
TWO   call XXXX (obj,ntr,hd1,tr1,hd2,tr2)      ! might need commenting out.

      end subroutine XXXX_superwrap_twosets


!!----------------------------- end ---------------------------------------!!
!!----------------------------- end ---------------------------------------!!
!!----------------------------- end ---------------------------------------!!

