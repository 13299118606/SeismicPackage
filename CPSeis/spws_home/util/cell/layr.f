C23456789012345678901234567890123456789012345678901234567890123456789012
C<license>
C-------------------------------------------------------------------------------
C Copyright (c) 2007 ConocoPhillips Company
C
C Permission is hereby granted, free of charge, to any person obtaining a copy
C of this software and associated documentation files (the "Software"), to deal
C in the Software without restriction, including without limitation the rights
C to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
C copies of the Software, and to permit persons to whom the Software is
C furnished to do so, subject to the following conditions:
C
C The above copyright notice and this permission notice shall be included in all
C copies or substantial portions of the Software.
C
C THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
C IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
C AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
C LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
C SOFTWARE.
C-------------------------------------------------------------------------------
C</license>
      SUBROUTINE LAYR(XMIN,XMAX,ZMIN,ZMAX,NB,IXB,NXB,XB,ZB
     1,ML,MXL,NL,IML,IXL,NXL,XL,ZL,NV,IMV,ITV,IXV,NXV,XV,ZV,VEL
     1,NCV,ICV,XCV,ZCV,MWORK,WORK,IERR)
C***************************** COPYRIGHT NOTICE ********************************
C*                                                                             *
C*                 CONFIDENTIAL AND PROPRIETARY INFORMATION                    *
C*                              OF CONOCO INC.                                 *
C*                      PROTECTED BY THE COPYRIGHT LAW                         *
C*                          AS AN UNPUBLISHED WORK                             *
C*                                                                             *
C***************************** COPYRIGHT NOTICE ********************************
C        1         2         3         4         5         6         7
C23456789012345678901234567890123456789012345678901234567890123456789012
C\USER DOC
C-----------------------------------------------------------------------
C                       CONOCO PROCESSING SYSTEM
C                 EXPLORATION RESEARCH & SERVICES DIVISION
C                              CONOCO, INC.
C
C
CPrimitive name: LAYR
C        Author: D W Hanson
C       Written: 91/09/15
C  Last revised: 93/01/20 Hanson
C
C  Purpose:  Convert a set of boundaries into SIERRA layers
C-----------------------------------------------------------------------
C                           CALLING SEQUENCE
C
C      CALL LAYR(XMIN,XMAX,ZMIN,ZMAX,NB,IXB,NXB,XB,ZB
C     1,ML,MXL,NL,IML,IXL,NXL,XL,ZL,NV,IMV,ITV,IXV,NXV,XV,ZV,VEL
C     1,NCV,ICV,XCV,ZCV,MWORK,WORK,IERR)
C
C ARGUMENTS
C Name    Type*  Valid  Description         *Type: I=IN, O=OUT, B=BOTH
C ----    ----   -----  -----------
C XMIN     I     REAL    MINIMUM X COORDINATE IN MODEL.
C XMAX     I     REAL    MAXIMUM X COORDINATE IN MODEL.
C ZMIN     I     REAL    MINIMUM Z COORDINATE IN MODEL.
C ZMAX     I     REAL    MAXIMUM Z COORDINATE IN MODEL.
C
C  VARIABLES NB,IXB,NXB,XB,ZB DESCRIBE THE BOUNDARIES THAT
C  ARE CONVERTED INTO SIERRA FORMAT
C
C NB       I     INT>0   # OF BOUNDARIES IN MODEL
C IXB      I  INT ARRAY  POINTERS TO ARRAYS XB, ZB
C          BOUNDARY IB BEGINS AT THE IXB(IB)+1 ELEMENT OF XB, ZB
C NXB      I  INT ARRAY  NUMBER OF POINTS IN EACH BOUNDARY
C          BOUNDARY IB HAS NXB(IB) ELEMENTS
C XB       I REAL ARRAY  X COORDINATES OF BOUNDARIES.
C ZB       I REAL ARRAY  Z COORDINATES OF BOUNDARIES
C          IXB,NXB HAVE NB ELEMENTS
C          XB,ZB HAVE IXB(NB)+NXB(NB) ELEMENTS
C
C VARIABLES ML,MXL,NL,IML,IXL,NXL,XL,ZL
C  DESCRIBE THE SIERRA BOUNDARIES THAT ARE GENERATED
C
C ML      I     INT>0    # OF MEMORY LOCATIONS AVAILABLE IN ARRAYS IXL,...
C MXL     I     INT>0    # OF MEMORY LOCATIONS AVAILABLE IN ARRAYS XL,...
C NL      O     INT      # OF LAYS FOUND IN MODEL (SHOULD BE <=NB)
C IML     O  INT ARRAY   VELOCITY TYPE WITHIN LAYER
C                        LAYER BETWEEN SURFACE IL-1 AND IL USES 
C                        VELOCITY VEL(IXV(IL)+) - VEL(IXV(IL)+NXV(IL))
C                        NEEDS NL ELEMENTS
C IXL     O  INT ARRAY   POINTERS TO ARRAYS XL,ZL ETC
C                        LAY IL BEGINS AT THE IXL(IL)+1
C                        ELEMENT OF XL,...
C                        NEEDS NL ELEMENTS
C NXL     O  INT ARRAY   NUMBER OF ELEMENTS IN EACH LAY
C                        LAY IL HAS NXL(IL) POINTS IN IT
C                        NEEDS NL ELEMENTS
C XL      O  REAL ARRAY  LAYER WALL X COORDINATES
C ZL      O  REAL ARRAY  LAYER WALL Z COORDINATES
C          IXL,NXL NEED NL ELEMENTS
C          XL,ZL NEED MC = IXL(NL)+NXL(NL) ELEMENTS
C
C VARIABLES NV,IMV,ITV,IXV,NXV,XV,ZV,VEL,NCV,ICV,XCV,ZCV
C  ARE USED TO DESCRIBE THE VELOCITY STRUCTURE WITHIN LAYERS
C
C NV       I INTEGER     NUMBER OF MATERIAL TYPES
C IMV      I INT ARRAY   MATERIAL TYPE ARRAY
C ITV      I INT ARRAY   VELOCITY VARIATION FLAG
C                        1 = CONSTANT VELOCITY
C                        2 = V(X)
C                        3 = V(Z)
C IXV     I  INT ARRAY   POINTERS TO ARRAYS XV,ZV ANDF VEL
C                        VELOCITY IV BEGINS AT THE IXV(IV)+1
C                        ELEMENT OF XV,...
C NXV     I  INT ARRAY   NUMBER OF ELEMENTS IN EACH VELOCITY
C                        VELOCITY IV HAS NXV(IV) POINTS IN IT
C XV      I REAL ARRAY   VELOCITY X COORDINATES
C ZV      I REAL ARRAY   VELOCITY Z COORDINATES
C VEL     I REAL ARRAY   VELOCITY VALUES
C           IMV,ITV,IXV,NXV HAVE NV ELEMENTS
C           XV,ZV,VEL HAVE IXV(NV)+NXV(NV) ELEMENTS
C
C NCV     I  INTEGER     NUMBER OF MATERIAL TYPES
C ICV     I  INT ARRAY   CELL VELOCITY POINTER
C XCV     I  REAL ARRAY  CELL VELOCITY POINTER X COORDINATES
C ZCV     I  REAL ARRAY  CELL VELOCITY POINTER Z COORDINATES
C                        THE CELL SUROUNDING THE POINT XCV(I),ZCV(I)
C                        USES MATERIAL TYPE IMV(IV) = ICV(I)
C            ICV,XCV,ZCV HAVE NCV ELEMENTS
C
C  MWORK, WORK DESCRIBE THE WORK SPACE AVALIABLE
C MWORK   I  INTEGER     NUMBER OF WORDS IN WORK ARRAY
C WORK    O  REAL ARRAY  WORK ARRAY - SHOULD BE A LRAGE # 100K
C
C IERR    O     INT      ERROR FLAG IERR>0 MEANS ERROR DURING CALCULATION
C-----------------------------------------------------------------------
C                                 NOTES
C  NOTE 1. ALL X AND Z DISTANCES ARE ASSUMED TO BE IN THE SAME UNITS.
C  IF NOT THEY SHOULD BE CONVERTED BEFORE SUBROUTINE    LAYR IS USED.
C-----------------------------------------------------------------------
C                          REVISION HISTORY
C     Date     Author      Description
C     ----     ------      -----------
C 2.  93/01/20 Hanson      Modify LAYR call.
C 1.  91/09/15 Hanson      Original version
C-----------------------------------------------------------------------
C   SUBROUTINE   , FUNCTION, ENTRY AND COMMON BLOCK NAMES IN THIS MODULE
C
C   SUBROUTINE    NAMES IN THIS MODULE
C
C LAYR     LAYVEL   LAYPNT   LAYLOFS  LAYSEGE  LAYSINL  LAYXZTOL LAYFLOW 
C LAYMAKEL LAYCHKL  LAYANG   LAYAREA  LAYMOVEL LAYFTURN LAYATURN LAYCCON 
C LAYTURN  LAYCROSN LAYIM    LAYACONP LAYFSEG  LAYLENS  LAYCON   LAYSRA  
C LAYZOFX  LAYZSET  LAYZATX  LAYEQ    LAYNE    LAYSHN   LAYSHN1  LAYSHNW 
C LAYSWH   LAYSWV   LAYSWB   LAYFNDXZ LAYMOVEX LAYMEMC  LAYCHKX  LAYPCON 
C LAYSIER  LAYHDR1  LAYPARM  LAYHDR2 
C 
C-----------------------------------------------------------------------
C                  EXTERNALS REFERENCED BY THIS MODULE
C
C CELLVSRT CELLTOL  CELLSCAC CELLSCAL CELLWORS CELLWORK CELLADDN
C CELLSEG  CELLWORL CELLMAKE CELLPPLT CELLCOP  CELLPSEG CELLFCON CELLFNCN
C CELLWHER CELLSORT CELLIXNX CELLCOP2 CELLCROS CELLBTOS CELLSTOB 
C-----------------------------------------------------------------------
C                         MEMORY REQUIREMENTS
C
C  STORAGE       - NONE
C  HEAP(dynamic) - NONE
C-----------------------------------------------------------------------
C\END DOC
      DIMENSION IXB(1),NXB(1),XB(1),ZB(1),IXV(1),NXV(1)
     1,XV(1),ZV(1),VEL(1),IXL(1),NXL(1),XL(1),ZL(1)
      DIMENSION WORK(1)
      IPR = 0
      LPR = 0
      IERR = 0
C  SORT XV AND VEL IN TERMS OF INCREASING X,Z 
C23456789012345678901234567890123456789012345678901234567890123456789012
      PRINT*,' NB=',NB,' NV=',NV

      CALL CELLVSRT(NV,ITV,IXV,NXV,XV,ZV,VEL
     1,WORK,WORK(IXV(NV)+NXV(NV)+1))
C  MAKE A COPY OF THE BOUNDARY DATA
C  KEEP POINTS THAT FALL WITHIN THE BOUNDARY
      CALL CELLTOL(TOL,XMIN,XMAX)
      CALL CELLSCAC(SCALE,XMIN,XMAX,ZMIN,ZMAX)
      PRINT*,' TOL=',TOL,' SCALE=',SCALE
      CALL CELLSCAL(1,ZMIN,SCALE)
      CALL CELLSCAL(1,ZMAX,SCALE)
      CALL CELLSCAL(IXB(NB)+NXB(NB),ZB,SCALE)
      CALL CELLSCAL(IXV(NV)+NXV(NV),ZV,SCALE)
      CALL CELLSCAL(NCV,ZCV,SCALE)
      LU = 50
      MB = NB + 54
      MXB = IXB(NB) + NXB(NB) + 8 + 1000
      CALL CELLWORS(1,MWORK,*999)
      CALL CELLWORK(JIXB,MB,*999)
      CALL CELLWORK(JNXB,MB,*999)
      CALL CELLWORK(JXB,MXB,*999)
      CALL CELLWORK(JZB,MXB,*999)
      CALL CELLADDN(TOL,XMIN,XMAX,ZMIN,ZMAX,NB,IXB,NXB,XB,ZB
     1,MB,NB1,WORK(JIXB),WORK(JNXB),WORK(JXB),WORK(JZB),IPR,LPR,*999)

C  SHIFT POINTS THAT MAKE VERTICAL SEGMENTS  DON'T INCLUDE MODEL BOUNDARIES
      CALL LAYMOVEX(NB1-4,WORK(JIXB),WORK(JNXB),WORK(JXB))

C  DETERMINE SEGMENTS
C      CALL LAYMEMC(MXB,NB1,WORK(JIXB),WORK(JNXB))
      MS = MXB / 2 + 1000
      CALL CELLWORK(ILN,MS,*999)
      CALL CELLWORK(IBS,MS,*999)
      CALL CELLWORK(IXS,MS,*999)
      CALL CELLWORK(NXS,MS,*999)
      CALL CELLWORK(IW1,MS,*999)
      CALL CELLSEG(TOL,XMIN,XMAX,ZMIN,ZMAX,MXB
     1,NB1,WORK(JIXB),WORK(JNXB),WORK(JXB),WORK(JZB)
     1,NLN,WORK(ILN),NS,WORK(IBS),WORK(IXS),WORK(NXS),WORK(IW1)
     1,IPR,LPR,IERR,*999)
      IF (IERR .NE. 0) GOTO 999

C  FORM THE CELLS OUT OF THE SEGMENTS
      CALL LAYMEMC(MXC,NB1,WORK(JIXB),WORK(JNXB))
      MC = NS
      MXC = 2 * MXC + 1000

      CALL CELLWORK(IXC,MC ,*999)
      CALL CELLWORK(NXC,MC ,*999)
      CALL CELLWORK(JXC,MXC,*999)
      CALL CELLWORK(JZC,MXC,*999)

      CALL CELLWORL(MW2)
      CALL CELLWORK(ICN,4*NS,*999)
      CALL CELLWORK(IAC,4*NS,*999)
      CALL CELLWORK(ISC,  NS,*999)
      CALL CELLWORK(NSC,  NS,*999)
      CALL CELLWORK(ICS,2*NS,*999)
      CALL CELLWORK(IOB,  NS,*999)
      CALL CELLWORK(IW ,2*NS,*999)
      CALL CELLMAKE(TOL,XMIN,XMAX,ZMIN,ZMAX
     1,NB1,WORK(JIXB),WORK(JNXB),WORK(JXB),WORK(JZB)
     1,MC,MXC,NC,WORK(IXC),WORK(NXC),WORK(JXC),WORK(JZC)
     1,NLN,WORK(ILN),NS,WORK(IBS),WORK(IXS),WORK(NXS)
     1,WORK(ICN),WORK(IAC),WORK(ISC),WORK(NSC),WORK(ICS)
     1,WORK(IOB),WORK(IW),IPR,LPR,IERR,*999)
      CALL CELLPPLT(NC,WORK(IXC),WORK(NXC),WORK(JXC),WORK(JZC),LU
     1,'AFT CELLMAKE XX',1)
      IF (IERR .NE. 0) GOTO 999

C  DETERMINE THE CELL AND SEGMENT OPPOSITE EACH PAIR OF POINTS
      CALL CELLWORK(ICOP,MXC,*999)
      CALL CELLWORK(ISOP,MXC,*999)
      CALL CELLCOP(TOL,XMIN,XMAX,ZMIN,ZMAX,NC,WORK(IXC),WORK(NXC)
     1,WORK(JXC),WORK(JZC),WORK(ISOP),WORK(ICOP),0,0,IERR,*999)

C  ADD LENSES TO THE LIST OF SEGMENTS
      CALL LAYLENS(NLN,WORK(ILN),NB1,WORK(JTB),WORK(JIXB),WORK(JNXB)
     1,NS,WORK(IBS),WORK(IXS),WORK(NXS))
C      CALL CELLPSEG(NS,WORK(IBS),WORK(IXS),WORK(NXS)
C     1,WORK(JIXB),WORK(JXB),WORK(JZB),LU,'SEG AFTER LAYLENS XX',1)

C  ADD TURNING POINT CONNECTIONS TO BOUNDARIES AND SEGMENTS
      CALL CELLWORK(ITURN,MS,*999)
      CALL LAYFTURN(TOL,NC,WORK(IXC),WORK(NXC),WORK(JXC),WORK(JZC)
     1,WORK(ICOP),NB1,WORK(JIXB),WORK(JNXB),WORK(JXB),WORK(JZB)
     1,NS,WORK(IBS),WORK(IXS),WORK(NXS),WORK(ITURN))
C      CALL CELLPSEG(NS,WORK(IBS),WORK(IXS),WORK(NXS)
C     1,WORK(JIXB),WORK(JXB),WORK(JZB),LU,'SEG AFTER LAYTURN XX',1)

C  DETERMINE CONNECTIONS BETWEEN SEGMENTS
      CALL CELLWORS(ICN,MW2)
      CALL CELLWORK(ICN,NS*4,*999)
      CALL CELLWORK(IAC,NS*4,*999)
      CALL CELLWORK(IOB,NS  ,*999)
      CALL CELLWORK(IW ,NS*2,*999)
      CALL CELLWORL(MW)
      CALL CELLFCON(TOL,XMIN,XMAX,ZMIN,ZMAX
     1,NONB1,WORK(IAC),WORK(ICN),WORK(IOB),WORK(IW)
     1,NS,WORK(IBS),WORK(IXS),WORK(NXS),NB1,WORK(JIXB),WORK(JNXB)
     1,WORK(JXB),WORK(JZB),IPR,LPR,IERR,*999)

C  CONSTRUCT LAYERS FROM SEGMENTS
      CALL CELLPPLT(NB1,WORK(JIXB),WORK(JNXB),WORK(JXB),WORK(JZB)
     1,LU,'BEF LAYLOFS XX',1)
      CALL LAYLOFS(TOL,XMIN,XMAX,ZMIN,ZMAX
     1,NB1,WORK(JIXB),WORK(JNXB),WORK(JXB),WORK(JZB)
     1,NS,WORK(IBS),WORK(IXS),WORK(NXS),WORK(ICN),NONB1,WORK(IOB)
     1,ML,MXL,NL,IXL,NXL,XL,ZL,MW,WORK(IW),LU,*999)
      CALL CELLPPLT(NL,IXL,NXL,XL,ZL,LU,'AFT LAYLOFS XX',1)

C  DETERMINE THE VELOCITY IN EACH LAYER
      CALL CELLWORK(IMC   ,NC    ,*999)
      CALL LAYVEL(TOL,NL,IML,IXL,NXL,XL,ZL
     1,NC,WORK(IXC),WORK(NXC),WORK(JXC),WORK(JZC),WORK(IMC)
     1,NV,IMV,NCV,ICV,XCV,ZCV,LU,*999)
      CALL CELLPPLT(NL,IXL,NXL,XL,ZL,LU,'AFT LAYVEL XX',1)

C  CONVERT BACK TO TIME NOTE SCALE MAY BE 1. AND THIS DOES NOTHING
      CALL CELLSCAL(1,ZMIN,1./SCALE)
      CALL CELLSCAL(1,ZMAX,1./SCALE)
      CALL CELLSCAL(IXB(NB)+NXB(NB),ZB,1./SCALE)
      CALL CELLSCAL(IXV(NV)+NXV(NV),ZV,1./SCALE)
      CALL CELLSCAL(NCV,ZCV,1./SCALE)
      CALL CELLSCAL(IXL(NL)+NXL(NL),ZL,1./SCALE)
C      CALL CELLPPLT(NL,IXL,NXL,XL,ZL,LU,'AFT SCAL XX',1)
C  ALL DONE
      RETURN
  999 CONTINUE
      PRINT*,' ERROR IN LAYR'
      IERR = 1
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYVEL(TOL,NL,IML,IXL,NXL,XL,ZL
     1,NC,IXC,NXC,XC,ZC,IMC,NV,IMV,NCV,ICV,XCV,ZCV,LU,*)
C  DETERMINE LAYER VELOCITIES
      DIMENSION IML(1),IXL(1),NXL(1),XL(1),ZL(1),IMC(1)
     1,IMV(1),IXC(1),NXC(1),XC(1),ZC(1)

C  DETERMINE WHICH VELOCITY POINTER GOES WITH WHICH CELL
C      SUBROUTINE CELLFNCN(ITYPE,NCV,ICV,XCV,ZCV,NV,IMV
C     1,NC,IMC,IXC,NXC,XC,ZC,IERR)
C  DETERMINE WHICH VELOCITY TYPE IS USED IN WHICH CELL
C  ITYPE=0 FIND ICV VALUE ITYPE=1 FIND VELOCITY VALUE
      PRINT*,' NL=',NL,' NC=',NC,' NCV=',NCV,' NV=',NV
      PRINT*,' IMV=',IMV(1),IMV(NV)
      PRINT*,' IMC=',IMC(1),IMC(NC)
      PRINT*,' IXC=',IXC(1),IXC(NC)
      PRINT*,' NXC=',NXC(1),NXC(NC)
      PRINT*,' XC=',XC(1),XC(IXC(NC)+NXC(NC))
      PRINT*,' ZC=',ZC(1),ZC(IXC(NC)+NXC(NC))

      CALL CELLFNCN(1,NCV,ICV,XCV,ZCV,NV,IMV
     1,NC,IMC,IXC,NXC,XC,ZC,IERR)
      IF (IERR .NE. 0) GOTO 999

      DO 1 IL = 1 , NL-1
C  FIND A POINT WITHIN THIS LAYER
        IX1 = IXL(IL) + 1
        IX2 = IXL(IL+1) + 1
        CALL LAYPNT(X0,Z0,NXL(IL),XL(IX1),ZL(IX1)
     1,NXL(IL+1),XL(IX2),ZL(IX2),*2)
C  DETRMINE WHAT CELL THIS POINT IS INSIDE
        CALL CELLWHER(X0,Z0,IS,IC,XS,ZS,RS,NC,IXC,NXC,XC,ZC,*2)
    2   IC = MAX(1,MIN(NC,IC))
        IML(IL) = IMC(IC)
    1 CONTINUE
      IML(NL) = IML(NL-1)
      RETURN

  999 CONTINUE
      PRINT'('' ERROR IN LAYVEL IL='',I5,'' NL='',I5
     1,'' X0='',F12.4,'' Z0='',F12.4
     1,/,'' IL  VL  IXL  NXL'',200(/,1X,I5,1X,I5,1X,I5,1X,I5))'
     1,IL,NL,X0,Z0,(I,IML(I),IXL(I),NXL(I),I=1,MIN(200,NL))
      CALL CELLPPLT(NL,IXL,NXL,XL,ZL,41,'ERROR IN LAYVEL XX',0)
      RETURN 1
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYPNT(X0,Z0,NX1,X1,Z1,NX2,X2,Z2,*)
C  FIND A POINT BEWTWEEN X1,Z1 AND X2,Z2
      DIMENSION X1(1),Z1(1),X2(1),Z2(1)
C  FOR EACH SEGMENT OF 2 FIND A POINT IN 1
      I1 = 1
      DO 1 I2 = 1 , NX2-1
        XA = (X2(I2+1) + X2(I2)) / 2
        ZA = (Z2(I2+1) + Z2(I2)) / 2
        CALL LAYFNDXZ(XA,ZB,I1,NX1,X1,Z1)
        IF (ABS(ZA - ZB) .GT. .1) THEN
          X0 = XA
          Z0 = (ZA + ZB) / 2.
          RETURN
        ENDIF
    1 CONTINUE
      CALL CELLPPLT(1,0,NX1,X1,Z1,42,'ERROR IN LAYPNT XX',0)
      CALL CELLPPLT(1,0,NX2,X2,Z2,42,'ERROR IN LAYPNT XX',0)
      RETURN 1
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYLOFS(TOL,XMIN,XMAX,ZMIN,ZMAX,NB,IXB,NXB,XB,ZB
     1,NS,IBS,IXS,NXS,ICON,NONB,IONB,ML,MXL,NL,IXL,NXL,XL,ZL
     1,MWORK,WORK,LU,*)
C  DETERMINE THE SEGMENTS MAKING UP EACH LAYER

      DIMENSION IXB(1),XB(1),ZB(1),IBS(1),IXS(1),NXS(1)
     1,IXL(1),NXL(1),XL(1),ZL(1),WORK(1),ICON(2,2,1)

C  FOR EACH SEGMENT SET A FLAG FOR WHETHER IT IS AN EDGE OR NOT
      CALL CELLWORS(1,MWORK)
      CALL CELLWORK(IES,NS,*999)
      CALL LAYSEGE(NONB,IONB,NS,WORK(IES),IBS,IXS,NXS,XMIN,XMAX,IXB,XB)

C  DETERMINE LEFT AND RIGHT CONNECTIONS
      CALL CELLWORK(IONL,NS,*999)
      CALL CELLWORK(IONR,NS,*999)
C23456789012345678901234567890123456789012345678901234567890123456789012
      CALL LAYCON(NS,IBS,IXS,NXS,WORK(IES),IXB,XB,ZB,ICON,WORK(IONL),-1)
      CALL LAYCON(NS,IBS,IXS,NXS,WORK(IES),IXB,XB,ZB,ICON,WORK(IONR),+1)
C      CALL LAYPCON(NS,ICON,WORK(IONL),WORK(IONR),WORK(IES),LU,'LAYCO',1)
C      CALL CELLPSEG(NS,IBS,IXS,NXS,IXB,XB,ZB,LU,'SEG AFT LAYCON XX',1)

C  DETERMINE THE SEGMENTS THAT MAKE UP EACH LAYER
      CALL CELLWORK(IFLOWL,NS,*999)
      CALL CELLWORK(IFLOWR,NS,*999)
      CALL CELLWORK(NSINL ,NS,*999)
      CALL CELLWORK(ISINL ,NS,*999)
      CALL CELLWORK(ILS   ,NS*100,*999)
      CALL LAYSINL(NS,WORK(IES),WORK(IONL),WORK(IONR)
     1,WORK(IFLOWL),WORK(IFLOWR),WORK(NSINL),WORK(ISINL),WORK(ILS))

C MAKE LAYERS OUT OF THESE SEGMENTS
      NSX = 5000
      CALL CELLWORK(IXK,NS ,*999)
      CALL CELLWORK(NXK,NS ,*999)
      CALL CELLWORK(JXL,NSX,*999)
      CALL CELLWORK(JZL,NSX,*999)
      CALL LAYXZTOL(NS,IBS,IXS,NXS,WORK(NSINL),WORK(ISINL),WORK(ILS)
     1,IXB,XB,ZB,NL,WORK(IXK),WORK(NXK),WORK(JXL),WORK(JZL))

C  DETERMINE THE AREA BETWEEN THE SURFACE AND EACH LAYER
      CALL CELLWORK(IAREA,NL,*999)
      CALL LAYAREA(ZMIN,NL,WORK(IXK),WORK(NXK),WORK(JXL),WORK(JZL)
     1,WORK(IAREA))

C  ORDER THESE IN INCREASING AREA
      CALL CELLWORK(IORD,NL,*999)
      CALL CELLSORT(NL,WORK(IAREA),WORK(IORD))

C  NOW PUT THE LAYERS INTO THE ARRAYS
      CALL LAYMOVEL(ML,MXL,NL,IXL,NXL,XL,ZL
     1,WORK(IXK),WORK(NXK),WORK(JXL),WORK(JZL),WORK(IORD),*999)

      RETURN 
  999 CONTINUE
      PRINT*,' ERROR IN LAYLOFS'
      RETURN 1
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYSEGE(NONB,IONB,NS,IES
     1,IBS,IXS,NXS,XMIN,XMAX,IXB,XB)
      DIMENSION IONB(1),IES(1),IBS(1),IXS(1),NXS(1),IXB(1),XB(1)
C  DETERMINE WHETHER EACH SEGMENT IS A MODEL BOUNDARY
C      PRINT*,' XMIN=',XMIN,' XMAX=',XMAX
C      PRINT'('' IS IBS  IES  IX1  IX2  X1  X2'')'
      DX = .01
      DO 1 IS = 1 , NS
        IES(IS) = 0
        DO 2 JONB = 1 , NONB
          IF (IONB(JONB) .EQ. IS) THEN
            IES(IS) = JONB
C  CHECK EACH X TO SEE IF THIS SEGMENT STARTS ON THE LEFT OR RIGHT
            IX1 = IXB(IBS(IS)) + IXS(IS) + 1
            IX2 = IXB(IBS(IS)) + IXS(IS) + NXS(IS) 
            IF ((XB(IX1).LE.XMIN+DX.AND.XB(IX2).LE.XMIN+DX)
     1.OR. (XB(IX1).GE.XMAX-DX.AND.XB(IX2).GE.XMAX-DX)) IES(IS) = - JONB
            GOTO 1
          ENDIF    ! IF (IONB(JONB) .EQ. IS) THEN
    2   CONTINUE
    1 CONTINUE
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYSINL(NS,IES,IONL,IONR,IFLOWL,IFLOWR,NSINL,ISINL,ILS)
      DIMENSION IES(1),NSINL(1),ISINL(1),ILS(1)
C  CREATE A LAYER FROM EACH SEGMENT
      JSINL = 0
      DO 1 IL = 1 , NS
        NSINL(IL) = 0
        ISINL(IL) = JSINL
        IF (IES(IL) .LT. 0) GOTO 1
        CALL LAYFLOW(IL,IES,IONL,NFLOWL,IFLOWL)
        CALL LAYFLOW(IL,IES,IONR,NFLOWR,IFLOWR)
        CALL LAYMAKEL(IL,NFLOWL,IFLOWL,NFLOWR,IFLOWR
     1,NSINL(IL),ILS(JSINL+1))
        CALL LAYCHKL(IL,NSINL,ISINL,ILS)
        JSINL = JSINL + NSINL(IL)
    1 CONTINUE
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYXZTOL(NS,IBS,IXS,NXS,NSINL,ISINL,ILS
     1,IXB,XB,ZB,NL,IXL,NXL,XL,ZL)
      DIMENSION IXB(1),XB(1),ZB(1),IXL(1),NXL(1),XL(1),ZL(1)
     1,IBS(1),IXS(1),NXS(1),NSINL(1),ISINL(1),ILS(1)
C  ADD XZ POINTS TO EACH LAYER
      NL = 0
      JXL = 0
      DO 1 IL = 1 , NS
        IF (NSINL(IL) .EQ. 0) GOTO 1
        NL = NL + 1
        IXL(NL) = JXL
        DO 2 IS = 1 , NSINL(IL)
          JS = ILS(ISINL(IL)+IS)
          IB = IBS(JS)
          IXB1 = IXB(IB) + IXS(JS) + 1
          IXB2 = IXB(IB) + IXS(JS) + NXS(JS)
          IXDIR = 1
          IF (XB(IXB2) .LT. XB(IXB1)) THEN
            IXB3 = IXB2
            IXB2 = IXB1
            IXB1 = IXB3
            IXDIR = -1
          ENDIF
          DO 3 IX0 = IXB1 , IXB2 , IXDIR
            IF (JXL .EQ. IXL(NL) .OR. XB(IX0) .GT. XL(JXL)) THEN
              JXL = JXL + 1
              XL(JXL) = XB(IX0)
              ZL(JXL) = ZB(IX0)
            ENDIF
    3     CONTINUE
    2   CONTINUE
        NXL(NL) = JXL - IXL(NL)
        CALL LAYCHKX(1,0,NXL(NL),XL(IXL(NL)+1),ZL(IXL(NL)+1),96)
    1 CONTINUE
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYFLOW(IS,IES,ION,NFLOW,IFLOW)
      DIMENSION IES(1),ION(1),IFLOW(1)
C  STARTING FROM A POINT FOLLOW IT UNTIL IT REACHES THE SIDE
      NFLOW = 0
      IF (IES(IS) .LT. 0) RETURN
      JS = IS
    1 CONTINUE    ! COME HERE TO CHECK THE END POINT
C IF THIS IS AT THE SIDE WE ARE ALL DONE
      IF (IES(ION(JS)) .LT. 0) RETURN
      NFLOW = NFLOW + 1
      IFLOW(NFLOW) = ION(JS)
      JS = IFLOW(NFLOW)
      IF (NFLOW .GT. 30) PRINT*,' STOP NFLOW=',NFLOW
      IF (NFLOW .GT. 30) STOP
      GOTO 1
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYMAKEL(IS,NFLOWL,IFLOWL,NFLOWR,IFLOWR,NSINL,ILS)
      DIMENSION IFLOWL(1),IFLOWR(1),ILS(1)
C  CREATE A LAYER USING NFLOWL AND NFLOWR
C  ADD THE LEFT HAND SEGMENTS
      NSINL = 0
      DO 1 JFLOWL = NFLOWL , 1 , -1
        NSINL = NSINL + 1
        ILS(NSINL) = IFLOWL(JFLOWL)
    1 CONTINUE

C  ADD THE STARTING SEGMENT
      NSINL = NSINL + 1
      ILS(NSINL) = IS

C  ADD THE RIGHT HAND SEGMENTS
      DO 2 JFLOWR = 1 , NFLOWR
        NSINL = NSINL + 1
        ILS(NSINL) = IFLOWR(JFLOWR)
    2 CONTINUE
C      WRITE(81,'('' NSINL '',10(1X,I3))')
C     1NSINL,(ILS(I),I=1,NSINL)

      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYCHKL(NL,NSINL,ISINL,ILS)
      DIMENSION NSINL(1),ISINL(1),ILS(1)
C  COMPARE LAYER THIS TO EACH OF THE PREVIOUS ONES
C  OTHERS IF IT IS IDENTICAL DELETE IT
      DO 1 IL = 1 , NL-1
        IF (NSINL(IL) .NE. NSINL(NL)) GOTO 1
        DO 2 I = 1 , NSINL(IL)
          IF (ILS(ISINL(IL)+I) .NE. ILS(ISINL(NL)+I)) GOTO 1
    2   CONTINUE
        NSINL(NL) = 0
        RETURN
    1 CONTINUE
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYANG(TOL,X0,X1,Z0,Z1,N,IX,X,Z,A)
      DIMENSION IX(1),X(1),Z(1),A(1)
C  DETERMINE THE ANGLE MADE BY SEGMENTS STARTING OR ENDING ON EDGE
      PI = 2. * ASIN(1.)
      RD = 90. / ASIN(1.)
      DX1 = X1 - X0
      DZ1 = Z1 - Z0
      R1 = SQRT(DX1**2+DZ1**2)

C  DO THOSE POINTS STARTING  ON THE TOP, LEFT OR BOTTOM
      DO 1 I = 1 , N
        DX2 = X(IX(I)+1) - X0
        DZ2 = Z(IX(I)+1) - Z0
        R12 = SQRT(DX2**2+DZ2**2)*R1
        SN = -(DX1 * DZ2 - DZ1 * DX2)
        CS = (DX1 * DX2 + DZ1 * DZ2) / R12
        CS = SIGN(1.,CS) * MIN(1.,ABS(CS))
        A(I) = PI + SIGN(1.,SN) * (ACOS(CS) - PI)
    1 CONTINUE

      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYAREA(Z0,N,IX,NX,X,Z,A)
      DIMENSION IX(1),NX(1),X(1),Z(1),A(1)
C  DETERMINE THE AREA BETWEEN BETWEEN EACH LAYER AND THE TOP
C      PRINT*,' LAYAREA N=',N,' Z0=',Z0
      DO 1 I = 1 , N
        A(I) = 0.
        DO 2 JX = IX(I)+1 , IX(I)+NX(I)-1
          A(I) = A(I) + (X(JX+1)-X(JX)) * ((Z(JX+1)+Z(JX))*.5 - Z0)
C      PRINT*,' JX=',JX,' A=',A(I),' X=',X(JX),' Z=',Z(JX)
    2   CONTINUE
C      PRINT*,' I=',I,' A=',A(I)
    1 CONTINUE

      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYMOVEL(M,MX,N,IX1,NX1,X1,Z1,IX2,NX2,X2,Z2,I2,*)
C  TRABSFER X2 TO X1
      DIMENSION IX1(1),NX1(1),X1(1),Z1(1)
     1,IX2(1),NX2(1),X2(1),Z2(1),I2(1)
      IF (N .GT. M .OR. IX2(N)+NX2(N) .GT. MX) THEN
        PRINT'('' NEED MORE SPACE FOR LAYERS HAVE N='',I5,'' M='',I5
     1,'' NX='',I5,'' MX='',I5)',N,M,IX2(N)+NX2(N),MX
        RETURN 1
      ENDIF
      DO 1 I1 = 1 , N
        CALL CELLIXNX(I1,IX1,NX1)
        NX1(I1) = NX2(I2(I1))
        K1 = IX1(I1) + 1
        K2 = IX2(I2(I1)) + 1
        CALL CELLCOP2(NX1(I1),X2(K2),Z2(K2),X1(K1),Z1(K1))
    1 CONTINUE
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYFTURN(TOL,NC,IXC,NXC,XC,ZC,ICOP
     1,NB,IXB,NXB,XB,ZB,NS,IBS,IXS,NXS,ITURN)
C  FOR EACH CELL;
C  ADD BOUNDARIES WHICH WILL CONNECT EACH TURNING POINT IN A CELL
C  TO ANOTHER POINT ON THE CELL BOUNDARY.
      DIMENSION IXC(1),NXC(1),XC(1),ZC(1),ICOP(1)
     1,IXB(1),NXB(1),XB(1),ZB(1),IBS(1),IXS(1),NXS(1)
      DO 1 IC = 1 , NC
C      PRINT'('' LAYFTURN IC='',I5,'' IXC='',I5,'' NXC='',I5)'
C     1,IC,IXC(IC),NXC(IC)
        JXC = IXC(IC) + 1
        CALL LAYATURN(IC,ICOP(JXC),NXC(IC),XC(JXC),ZC(JXC)
     1,NB,IXB,NXB,XB,ZB,NS,IBS,IXS,NXS,ITURN)
    1 CONTINUE
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYATURN(IC,ICOP,N,X,Z,NB,IXB,NXB,XB,ZB
     1,NS,IBS,IXS,NXS,ITURN)
C  FOR A SINGLE CELL;
C  ADD BOUNDARIES WHICH WILL CONNECT EACH TURNING POINT IN A CELL
C  TO ANOTHER POINT ON THE CELL BOUNDARY.
      DIMENSION X(1),Z(1),ICOP(1),IBS(1),IXS(1),NXS(1),ITURN(1)
      DATA ICALL/0/
      ICALL = ICALL + 1

C      WRITE(87,'(/,'' LAYATURN ICALL='',I5,'' IC='',I5,'' N='',I5
C     1,'' NB='',I5,'' NS='',I5)')ICALL,IC,N,NB,NS
      NTURN = 0
      DO 1 I = 1 , N-1
C  IF THIS SEGMENT IS NOT PART OF THE BOUNDARY OR X IS DECREASING WE CAN 
C  SKIP THIS POINT - IF THIS IS A LENS CONNECTOR SKIP IT
C  FIND THE FIRST POINT IN THE REVERSE DIRECTION WHICH IS NOT A LENS CONNECTOR

        CALL LAYIM(IM,I,N,IC,ICOP,X,Z)
        IP = MOD(I,N-1) + 1
C  IF THIS IS A TURNING POINT
C      WRITE(87,'('' ICOP='',3(1X,I2),'' I='',3(1X,I3)
C     1,'' X='',3(1X,F7.0),'' Z='',3(1X,F7.0))')
C     1ICOP(IM),ICOP(I),ICOP(IM),IM,I,IP
C     1,X(IM),X(I),X(IP),Z(IM),Z(I),Z(IP)
        IF (ICOP(I) .NE. IC .AND. ICOP(I) .GT. 0 .AND. ICOP(IM) .GT. 0
     1 .AND. (X(IM)-X(I))*(Z(IP)-Z(I))-(X(IP)-X(I))*(Z(IM)-Z(I)) .LT. 0.
     1 .AND. ((X(I) .LT. X(IM) .AND. X(I) .LT. X(IP))
     1  .OR.  (X(I) .GT. X(IM) .AND. X(I) .GT. X(IP)))) THEN
C CHECK TO SEE IF THIS POINT HAS A CONNCECTION IN THE PROPER DIRECTION
           CALL LAYCCON(IM,I,N,X,Z,*1)
           NTURN = NTURN + 1
           ITURN(NTURN) = I
           IF (X(I) .LT. X(IP)) ITURN(NTURN) = -I
C      WRITE(87,'('' N='',I3,'' I='',3(1X,I3)
C     1,'' X='',3(1X,F7.0),'' Z='',3(1X,F7.0))')
C     1NTURN,IM,I,IP,X(IM),X(I),X(IP),Z(IM),Z(I),Z(IP)
         ENDIF
    1 CONTINUE
      IF (NTURN .NE. 0) CALL LAYTURN(NTURN,ITURN,IC,ICOP,N,X,Z
     1,NB,IXB,NXB,XB,ZB,NS,IBS,IXS,NXS)
C      WRITE(87,'('' LAYTURN NB='',I5,'' NS='',I5,'' NTURN='',I5)')
C     1NB,NS,NTURN
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYCCON(IM,I,N,X,Z,*)
      DIMENSION X(1),Z(1)
      DATA ICALL/0/
      ICALL = ICALL + 1
      XSIGN = SIGN(1.,X(I)-X(IM))
      DO 1 J = 1 , N-1
        IF (X(J) .EQ. X(I) .AND. Z(J) .EQ. Z(I) .AND. I .NE. J) THEN
          JP = MOD(J,N-1) + 1
          JM = MOD(J-3+N,N-1) + 1
          IF (SIGN(1.,X(JP)-X(I)) .EQ. XSIGN
     1   .OR. SIGN(1.,X(JM)-X(I)) .EQ. XSIGN) THEN
C            WRITE(87,'('' LAYCCON ICALL='',I5,'' N='',I3
C     1,'' IM='',I3,'' I='',I3,'' JM='',I3,'' J='',I3,'' JP='',I3)')
C     1ICALL,N,IM,IP,JM,J,JP
            RETURN 1
          ENDIF
        ENDIF
    1 CONTINUE
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYTURN(NTURN,ITURN,IC,ICOP,N,X,Z,NB,IXB,NXB,XB,ZB
     1,NS,IBS,IXS,NXS)
C  FOR EACH OF NTRUN POINTS AT WHICH X CHANGES DIRECTION
C  IDENTIFY A CONNECTION POINT
      DIMENSION ITURN(1),ICOP(1),X(1),Z(1),IXB(1),NXB(1),XB(1),ZB(1)
     1,IBS(1),IXS(1),NXS(1)
C  CONNECT THE POINTS ITURN(I) TO ANOTHER POINT ON THE CELL
C  DO NOT CONNECT THEM TO ANY POINT THAT IS A LENS CONNECTOR
C  IF ITURN(I) < 0 CONNECT TO SMALLER X
C  IF ITURN(I) > 0 CONNECT TO LARGER X

C  CHECK EACH OF THE OTHER TURNING POINTS TO SEE IF WE CAN CONNECT THEM
      NS0 = NS
C      WRITE(88,'('' TURN IC='',I3,'' N='',I3,'' NS='',I3,'' NT='',I3
C     1,'' IT='',10(1X,I3))')IC,N,NS,NTURN,(ITURN(I),I=1,NTURN)
      DO 1 J1 = 1 , NTURN
        I0 = 0
        I1 = IABS(ITURN(J1))
C      WRITE(88,'('' J1='',I3,'' IT='',I3,'' X='',F6.0,'' Z='',F6.0)')
C     1J1,ITURN(J1),X(I1),Z(I1)
        IF (I1 .EQ. 0) GOTO 1    ! ALREADY HAVE USED THIS POINT
        DO 2 J2 = 1 , NTURN
          I2 = IABS(ITURN(J2))
C      WRITE(88,'('' J='',I3,1X,I3,'' I='',I3,1X,I3,'' X1='',F6.0,1X,F6.0
C     1,'' X2='',F6.0,1X,F6.0)')
C     1J1,J2,ITURN(J1),ITURN(J2),X(I1),Z(I1),X(I2),Z(I2)
C  IF THIS POINT IS IN THE WRONG DIRECTION FORGET IT
          IF (I1 .EQ. I2 .OR. I2 .EQ. 0
     1 .OR. (ITURN(J1) .LT. 0 .AND. X(I1) .LT. X(I2))
     1 .OR. (ITURN(J1) .GT. 0 .AND. X(I1) .GT. X(I2))
     1 .OR. (ITURN(J2) .LT. 0 .AND. X(I2) .LT. X(I1))
     1 .OR. (ITURN(J2) .GT. 0 .AND. X(I2) .GT. X(I1))) GOTO 2
          CALL LAYCROSN(ICROS,I1,I2,IC,ICOP,N,X,Z,NB,IXB,NXB,XB,ZB
     1,NS0,NS,IBS,IXS,NXS)
C      WRITE(88,'('' J1='',I3,'' J2='',I3,'' IT1='',I3,'' IT2='',I3
C     1,'' ICR='',I3,'' NS0='',I3,'' NS='',I3)')
C     1J1,J2,ITURN(J1),ITURN(J2),ICROS,NS0,NS
          DZ = SQRT((X(I1)-X(I2))**2+(Z(I1)-Z(I2))**2)
          IF (ICROS .EQ. 0 .AND. (DZ .LT. DZMIN .OR. I0 .EQ. 0)) THEN
            I0 = I2
            J0 = J2
            DZMIN = DZ
          ENDIF

    2   CONTINUE
        IF (I0 .NE. 0) CALL LAYACONP(I1,I0,J1,J0,ITURN,IC,N,X,Z
     1,NB,IXB,NXB,XB,ZB,NS,IBS,IXS,NXS)
    1 CONTINUE
C      WRITE(88,'('' AFT 1 IT='',10(1X,I3))')(ITURN(I),I=1,NTURN)
C  NOW CHECK THE REST OF THE POINTS
C  CHECK EACH OF THE OTHER TURNING POINTS TO SEE IF WE CAN CONNECT THEM
      DO 3 J1 = 1 , NTURN
        I0 = 0
        I1 = IABS(ITURN(J1))
        IF (I1 .EQ. 0) GOTO 3    ! ALREADY HAVE USED THIS POINT
        I1M = MOD(I1-2+N,N) + 1
        I1P = MOD(I1,N) + 1
C      WRITE(88,'('' J1='',I3,'' IT='',I3,'' X='',F6.0,'' Z='',F6.0)')
C     1J1,ITURN(J1),X(I1),Z(I1)
        DO 4 I2 = 1 , N-1
C      WRITE(88,'('' I2='',I3,'' X='',F7.0,'' Z='',F7.0)')I2,X(I2),Z(I2)
C  IF THIS POINT IS IN THE WRONG DIRECTION FORGET IT
          IF (I1M .EQ. I2 .OR. I1 .EQ. I2 .OR. I1P .EQ. I2
     1 .OR. (ITURN(J1) .LT. 0 .AND. X(I1) .LT. X(I2))
     1 .OR. (ITURN(J1) .GT. 0 .AND. X(I1) .GT. X(I2))
     1 .OR. ICOP(I2) .EQ. IC) GOTO 4
          CALL LAYCROSN(ICROS,I1,I2,IC,ICOP,N,X,Z,NB,IXB,NXB,XB,ZB
     1,NS0,NS,IBS,IXS,NXS)
          DZ = SQRT((X(I1)-X(I2))**2+(Z(I1)-Z(I2))**2)
C      WRITE(88,'('' ICR='',I3,'' NS0='',I3,'' NS='',I3,'' DZ='',F7.0
C     1,'' DZMIN='',F7.0)')ICROS,NS0,NS,DZ,DZMIN

C  WE CAN CONNECT THESE TWO POINTS
          IF (ICROS .EQ. 0 .AND. (DZ .LT. DZMIN .OR. I0 .EQ. 0)) THEN
            I0 = I2
            DZMIN = DZ
C      WRITE(88,'('' I1='',I3,'' J1='',I3,'' I0='',I3,'' DZMIN'',F7.0)')
C     1I1,J1,I0,DZMIN
          ENDIF

    4   CONTINUE
        IF (I0 .NE. 0) CALL LAYACONP(I1,I0,J1,0,ITURN,IC,N,X,Z
     1,NB,IXB,NXB,XB,ZB,NS,IBS,IXS,NXS)
C      WRITE(88,*)' I0=',I0,' I1=',I1,' X=',X(I0),X(I1),' Z=',Z(I0),Z(I1)
C      WRITE(88,*)' DZMIN=',DZMIN
    3 CONTINUE
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYCROSN(ICROS,I1,I2,IC,ICOP,N,X,Z,NB,IXB,NXB,XB,ZB
     1,NS0,NS,IBS,IXS,NXS)
C DETERMINE IF THE SEGMENT FROM I1 TO I2 CROSSES ANY OTHER SEGMENT IN X,Z
C  AS WELL AS ANY SEGMENTS FROM NS0+1 - NS
C  IF IT DOES SET ICROS = 1
C  IF IT DOES NOT SET ICROS = 0
      DIMENSION ICOP(1),X(1),Z(1),IXB(1),NXB(1),XB(1),ZB(1)
     1,IBS(1),IXS(1),NXS(1)

      ICROS = 0
      DO 1 I = 1 , N-1
C  DETERMINE IF THE SEGMENT FROM I TO IP CROSSES I1 TO I2
        IP = MOD(I,N) + 1
C  IF THE CELL ON THE OTHER SIDE OF THIS SEGMENT IS THE SAME CELL OR
C  IF EITHER END OF THIS SEGMENT IS THE SAME AS ONE OF THE TWO ENDPOINTS SKIP IT
        IF (ICOP(I) .EQ. IC
     1 .OR. I.EQ.I1 .OR. IP.EQ.I1 .OR. I.EQ.I2 .OR. IP.EQ.I2) GOTO 1
        CALL CELLCROS(ICROS,X0,Z0,X(I1),X(I2),Z(I1),Z(I2)
     1,X(I),X(IP),Z(I),Z(IP))
        IF (ICROS .NE. 0) RETURN        
    1 CONTINUE
C  NOW CHECK THE SEGMENTS BETWEEN NS0 AND NS
      DO 2 IS = NS0+1 , NS
        J1 = IXB(IBS(IS)) + IXS(IS) + 1
        J2 = J1 + 1
C  IF THESE ARE THE SAME POINT FORGET THEM
        IF ((XB(J1).EQ.X(I1).AND.ZB(J1).EQ.Z(I1))
     1 .OR. (XB(J1).EQ.X(I2).AND.ZB(J1).EQ.Z(I2))
     1 .OR. (XB(J2).EQ.X(I1).AND.ZB(J2).EQ.Z(I1))
     1 .OR. (XB(J2).EQ.X(I2).AND.ZB(J2).EQ.Z(I2))) GOTO 2
        CALL CELLCROS(ICROS,X0,Z0,X(I1),X(I2),Z(I1),Z(I2)
     1,XB(J1),XB(J2),ZB(J1),ZB(J2))
        IF (ICROS .NE. 0) RETURN        
    2 CONTINUE
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYIM(IM,I,N,IC,ICOP,X,Z)
C  FIND THE FIRST POINT PRIOR TO I WHICH IS NOT A LENS CONNECTOR
      DIMENSION ICOP(1),X(1),Z(1)
      IM = MOD(I-3+N,N-1) + 1
C  LOOK BACKWARDS FOR THE NEXT POINT
      IF (ICOP(IM) .EQ. IC) THEN
        DO 1 J = 1 , N - 1
          IM = MOD(IM-3+N,N-1) + 1
          IF(X(IM).EQ.X(I).AND.Z(IM).EQ.Z(I))THEN
            IM = MOD(IM-3+N,N-1) + 1
            RETURN
          ENDIF
    1   CONTINUE
      ENDIF
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYACONP(I1,I2,J1,J2,ITURN,IC,N,X,Z,NB,IXB,NXB,XB,ZB
     1,NS,IBS,IXS,NXS)
C  ADD 2 POINTS TO CELL AND SEGMENTS  THESE CONNECT TURNNG POINTS
      DIMENSION ITURN(1),X(1),Z(1),IXB(1),NXB(1),XB(1),ZB(1)
     1,IBS(1),IXS(1),NXS(1)
C  ADD THESE TWO POINTS AS A NEW BOUNDARY AND SEGMENT
      NB = NB + 1
      IXB(NB) = IXB(NB-1) + NXB(NB-1)
      NXB(NB) = 2
      IF (X(I1) .LT. X(I2)) THEN
        IMIN = I1
        IMAX = I2
      ELSE
        IMIN = I2
        IMAX = I1
      ENDIF
      XB(IXB(NB)+1) = X(IMIN)
      XB(IXB(NB)+2) = X(IMAX)
      ZB(IXB(NB)+1) = Z(IMIN)
      ZB(IXB(NB)+2) = Z(IMAX)
      NS = NS + 1
      IBS(NS) = NB
      IXS(NS) = 0
      NXS(NS) = 2
C  DETERMINE IF THESE TWO POINTS ARE IN THE MIDDLE OF A SEGMENT
C  IF THEY ARE BREAK EACH ONE INTO TWO SEGMENTS
C  ONE WILL BE STORED IN THE ORIGINAL LOCATION C THE OTHER AT THE END
      CALL LAYFSEG(IS0,IX0,IXB(NB)+1,IXB,XB,ZB,NS,IBS,IXS,NXS)
      CALL LAYFSEG(IS0,IX0,IXB(NB)+2,IXB,XB,ZB,NS,IBS,IXS,NXS)
C  SET ITURN = 0 TO INDICATE IT HAS BEEN CONNECTED
      ITURN(J1) = 0
      IF (J2 .NE. 0) ITURN(J2) = 0
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYFSEG(IS,IX,I0,IXB,XB,ZB,NS,IBS,IXS,NXS)
C  DETERMINE IF THIS POINT IS IN THE MIDDLE OF A SEGMENT
C  IF IT IS BREAK THIS SEGMENTS INTO TWO SEGMENTS
C  ONE WILL BE STORED IN THE ORIGINAL LOCATION AND THE OTHER AT THE END
C  DETERMINE THE SEGMENT A POINT BELONGS TO
      DIMENSION IXB(1),XB(1),ZB(1),IBS(1),IXS(1),NXS(1)

      DO 1 JS = 1 , NS
        IB = IBS(JS)
        DO 2 JX = IXB(IB)+IXS(JS)+1 , IXB(IB)+IXS(JS)+NXS(JS)
          IF (XB(I0) .EQ. XB(JX) .AND. ZB(I0) .EQ. ZB(JX)
     1 .AND. I0 .NE. JX) THEN
            IS = JS
            IX = JX - IXB(IB) - IXS(JS)
C      PRINT*,' NS=',NS,' IS=',IS,' IB=',IB,' IX=',IX,' NXS=',NXS(JS)
            IF (IX .GT. 1 .AND. IX .LT. NXS(IS)) THEN
              NS = NS + 1
              IBS(NS) = IBS(IS)
              IXS(NS) = IXS(IS) + IX - 1
              NXS(NS) = NXS(IS) - IX + 1
              NXS(IS) = IX
C      PRINT*,' IS=',IS,' IBI=',IBS(IS),' IXI=',IXS(IS),' NXI=',NXS(IS)
C      PRINT*,' NS=',NS,' IBN=',IBS(NS),' IXN=',IXS(NS),' NXN=',NXS(NS)

            ENDIF
            RETURN
         ENDIF
    2   CONTINUE
    1 CONTINUE
      LU = 43
      PRINT*,' COULDNOT FIND POINT IN SEGMENTS X=',XB(I0),' Z=',ZB(I0)
      PRINT*,' NS=',NS,' I0=',I0
      CALL CELLPSEG(NS,IBS,IXS,NXS,IXB,XB,ZB,LU,'ERROR IN FSEG XX',0)
      WRITE(LU,'(1X,F10.2,1X,F10.2,1X,I5)')XB(I0)-10.,ZB(I0)-10.,0
     1,XB(I0)-10.,ZB(I0)+10.,0,XB(I0)+10.,ZB(I0)+10.,0
     1,XB(I0)+10.,ZB(I0)-10.,0,XB(I0)-10.,ZB(I0)-10.,0
      STOP
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYLENS(NLN,ILN,NB,IBT,IXB,NXB,NS,IBS,IXS,NXS)
C  BREAK LENS INTO 2 DIFFERENT SEGMENTS.
      DIMENSION ILN(1),IBT(1),IXB(1),NXB(1),IBS(1),IXS(1),NXS(1)
      DO 1 I = 1 , NLN
        JB = IABS(ILN(I))
        NS = NS + 1
        IBS(NS) = JB
        IXS(NS) = 0
        NXS(NS) = NXB(JB) / 2 + 1
        NS = NS + 1
        IBS(NS) = JB
        IXS(NS) = NXS(NS-1) - 1
        NXS(NS) = NXB(JB) - IXS(NS)
    1 CONTINUE
      NLN = 0
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYCON(NS,IBS,IXS,NXS,IES,IX,X,Z,ICON,ION,IDIR)
C  DETERMINE LAYER CONNECTIONS
C  IF IDR < 0 GO TO SMALLER X
C  IF IDR > 0 GO TO LARGER X
      DIMENSION IX(1),X(1),IBS(1),IXS(1),NXS(1),IES(1)
     1,ICON(2,2,1),ION(1)
      PRINT*,' LAYCON NS=',NS
      DO 1 IS = 1 , NS
C IF THIS POINT TRUNCATES ON THE LEFT BOUNDARY SKIP THIS SECTION
        ION(IS) = 0
        IF (IES(IS) .LT. 0) GOTO 1
        JS = IS
        JX1 = IX(IBS(JS)) + IXS(JS) + 1
        JX2 = IX(IBS(JS)) + IXS(JS) + NXS(JS) 
        JEND = 1 + (1 + IDIR * INT(SIGN(1.,X(JX2)-X(JX1)))) / 2
        JDIR = IDIR
C      PRINT'('' JS='',I5,'' JEND='',I5,'' JDIR='',I5
C     1,'' X='',2(1X,F6.0))',JS,JEND,JDIR,X(JX1),X(JX2)
C  DETERMINE THE FIRST SEGMENT WITH X DECREASING
    2   CONTINUE
C  IN A CLOCK WISE DIRECTION ICON(2,JEND) IS THE LARGEST ANGLE 
C  AND ICON(1,END) THE SMALLEST CONNECTED TO END JEND
C  IF ICON < 0 THE CONNECTION IS TO END 2
C  IF ICON > 0 THE CONNECTION IS TO END 1
        KS = IABS(ICON(2,JEND,JS))
        KEND = 1 + (1 - SIGN(1,ICON(2,JEND,JS))) / 2
        IF (KEND .EQ. 1) THEN
          KX1 = IX(IBS(KS)) + IXS(KS) + 1
          KX2 = KX1 + 1
        ELSE
          KX1 = IX(IBS(KS)) + IXS(KS) + NXS(KS)
          KX2 = KX1 - 1
        ENDIF
C        IF (X(KX1) .NE. X(XK1)) THEN
          KDIR = INT(SIGN(1.,X(KX2)-X(KX1)))
C        ELSE
C          KDIR = - JDIR
C        ENDIF
C      PRINT'('' KS='',I5,'' KEND='',I5,'' KDIR='',I5
C     1,'' X='',2(1X,F6.0))',KS,KEND,KDIR,X(KX1),X(KX2)
C        IF (IES(KS) .LT. 0 .OR. JDIR .EQ. KDIR) THEN
C          ION(IS) = KS
        IF (IES(KS) .LT. 0 .OR. JDIR .EQ. KDIR) THEN
          ION(IS) = KS
C          ION(IS) = IABS(ICON(2,JEND,JS))
      IF(ION(IS).EQ.IS)THEN
      PRINT*,' ERROR IN LAYCON'
      PRINT*,' NS=',NS,' IS=',IS,' ION=',ION(IS),' KS=',KS
      PRINT*,' X1=',X(KX1),' X2=',X(KX2)
      PRINT*,' JS=',JS,' IES=',IES(JS),' JDIR=',JDIR
      PRINT*,' KS=',KS,' IES=',IES(KS),' KDIR=',KDIR
      PRINT*,' IS=',IS,' IES=',IES(IS)
      CALL CELLPSEG(NS,IBS,IXS,NXS,IX,X,Z,21,'SEG INS LAYCON XX',0)
      STOP
      ENDIF

        ELSE
          JEND = KEND
          JS = KS
          GOTO 2
        ENDIF

    1 CONTINUE
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYSRA(LU,SRAFIL,UNITS,TORZ,XMIN,XMAX,ZMIN,ZMAX
     1,NL,IML,IXL,NXL,XL,ZL,NV,ITV,IXV,NXV,XV,ZV,VEL)
C  CREATE GRIDDED Z AND V IN SIERRA FORMAT
C  NOTE WE HAVE NL LAYERS
C  THE FIRST IS AT THE TOP AND THE LAST AT THE BOTTOM
C  SIERRA DOESN'T WANT EITHER THE TOP OR BOTTOM
C  IF ZMIN < 0. PASS OUT LAYERS IN REVERSE ORDER
      CHARACTER SRAFIL*(*),UNITS*(*),TORZ*(*)
      PARAMETER (MX=501,ML=70)
      DIMENSION Z(MX,ML),V(MX,ML+1),IML(1),IXL(1),NXL(1),XL(1),ZL(1)
     1,ITV(1),IXV(1),NXV(1),XV(1),ZV(1),VEL(1)

      NX = MX
      XINC = (XMAX - XMIN) / (NX - 1)
      DO 1 JL = 1 , NL - 2
        IL = JL + 1
        IF (ZMIN .LT. 0.) IL = NL - JL
C  COMPUTE Z(X)
        CALL LAYZOFX(NX,XMIN,XINC,Z(1,JL)
     1,NXL(IL),XL(IXL(IL)+1),ZL(IXL(IL)+1))
C  COMPUTE V(X)
        IVEL = IML(IL-1)
        IF (ZMIN .LT. 0.) IVEL = IML(IL)
        JXV = IXV(IVEL) + 1
        IF (NXV(IVEL) .EQ. 1 .OR. ITV(IVEL) .EQ. 1) THEN
          V(1,JL) = -1
          DO 2 IX = 2 , NX
            V(IX,JL) = VEL(JXV)
    2     CONTINUE
        ELSEIF (ITV(IVEL) .EQ. 2) THEN
          CALL LAYZOFX(NX,XMIN,XINC,V(1,JL)
     1,NXV(IVEL),XV(JXV),VEL(JXV))
        ELSEIF (ITV(IVEL) .EQ. 3) THEN
          JXV = IXV(IVEL) + 1
          V(1,JL) = -2
          V(2,JL) = VEL(JXV)
          V(3,JL) = ZV(JXV)
          V(4,JL) = (VEL(JXV+1) - VEL(JXV)) / (ZV(JXV+1) - ZV(JXV))
          IF (ZMIN .LT. 0.) V(4,JL) = - V(4,JL)
        ELSE
          PRINT*,' ITV=',ITV(IVEL)
          STOP
        ENDIF
    1 CONTINUE
      JL = NL - 1
      IL = JL
      IF (ZMIN .LT. 0.) IL = 1
      V(1,JL) = -1
      DO 3 IX = 2 , NX
        V(IX,JL) = VEL(IXV(IML(IL))+1)
    3 CONTINUE
      ZBOT = ZMAX
      IF (ZMIN .LT. 0.) ZBOT = ZMIN
      CALL LAYSIER(LU,SRAFIL,NL-2,XMIN,XMAX,NX,ZBOT,UNITS,Z,V,TORZ
     1,MX,ML)
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYZOFX(NX1,XMIN,XINC,Z1,NX2,X2,Z2)
C  GIVEN X2,Z2 COMPUT Z(X) AT X=(I-1)*XINC+XMIN FOR I=1,NX1
      DIMENSION Z1(1),X2(1),Z2(1)
      I1 = (INT(X2(1) - XMIN)/ XINC) + 1
      IMIN = I1
      IMAX = I1
      DO 1 IX2 = 1 , NX2-1
        I2 =  INT((X2(IX2+1) - XMIN)/ XINC) + 1
        DZDX = (Z2(IX2+1) - Z2(IX2)) / (X2(IX2+1) - X2(IX2))
        DO 2 IX1 = I1 , I2
          X1 = (IX1 - 1) * XINC + XMIN
          Z1(IX1) = Z2(IX2) + (X1 - X2(IX2)) * DZDX
    2   CONTINUE
        IMIN = MIN(IMIN,I1)
        IMAX = MAX(IMAX,I2)
        IF (I2 .GE. NX1) GOTO 3
        I1 = MAX(I1,I2+1)
    1 CONTINUE
    3 CONTINUE
      DO 4 I = 1 , IMIN - 1
        Z1(I) = Z1(IMIN)
    4 CONTINUE
      DO 5 I = IMAX+1 , NX1
        Z1(I) = Z1(IMAX)
    5 CONTINUE

      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYZSET(TOL,X0,Z0,N,X,Z)
C  IF TWO POINTS ARE WITHIN TOL OF ONE ANOTHER SET X0 = X AND Z0 = Z
      DIMENSION X(1),Z(1)
      LOGICAL CELLSAME
      DO 1 I = 1 , N
        IF (CELLSAME(TOL,X0,Z0,X(I),Z(I))) THEN
          X0 = X(I)
          Z0 = Z(I)
          RETURN
        ENDIF
    1 CONTINUE
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYZATX(NX1,X1,Z1,NX2,X2,Z2)
C  GIVNE X1,Z1 COMPUTE Z2 AT ALL X2 S
      DIMENSION X1(1),Z1(1),X2(1),Z2(1)
      IX2A = 0
      IX2B = NX2 + 1
      DO 1 IX2 = 1 , NX2
        IF (X1(1) .LE. X2(IX2)) GOTO 2
        Z2(IX2) = Z1(1)
        IX2A = IX2
    1 CONTINUE
    2 CONTINUE
      DO 3 IX2 = NX2 , 1 , -1
        IF (X1(NX1) .GE. X2(IX2)) GOTO 4
        Z2(IX2) = Z1(NX1)
        IX2B = IX2
    3 CONTINUE
    4 CONTINUE
      IX2A = IX2A + 1
      IX2B = IX2B - 1
      IX1 = 1
      DO 5 IX2 = IX2A , IX2B
    6   CONTINUE
        IF ((X2(IX2) .GE. X1(IX1) .AND. X2(IX2) .LE. X1(IX1+1))
     1.OR. IX1 .EQ. NX1-1) THEN
        Z2(IX2) = Z1(IX1) + (Z1(IX1+1) - Z1(IX1))
     1 * ((X2(IX2) - X1(IX1)) / (X1(IX1+1) - X1(IX1)))
        ELSE
          IX1 = IX1 + 1
          GOTO 6
        ENDIF
    5 CONTINUE

      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYEQ(TOL,IEQ,J,I,N,A,B)
C  STARTING AT I DETERMINE THE FIRST PAIR OF A,B THAT ARE THE SAME
      DIMENSION A(1),B(1)
      IEQ = 1
      DO 1 K = I , N
        J = K
        IF (ABS(A(J)-B(J)) .LT. TOL) RETURN
    1 CONTINUE
      IEQ = -1
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYNE(TOL,INE,J,I,N,A,B)
C  STARTING AT I DETERMINE THE FIRST PAIR OF A,B THAT ARE THE SAME
      DIMENSION A(1),B(1)
      INE = 1
      DO 1 K = I , N
        J = K
        IF (ABS(A(J)-B(J)) .GE. TOL) RETURN
    1 CONTINUE
      INE = -1
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYSHN(LU,SHNFIL,XMIN,XMAX,ZMIN,ZMAX
     1,SHOT,BASE,BASEINC,NHMOD,NB,IVB,IXB,NXB,XB,ZB
     1,NL,IML,IXL,NXL,XL,ZL,NV,IVT,IXV,NXV,XV,ZV,V,WORK)
C  CREATE SHEINS BOUNDARIES FROM THE PRESENT ONES
      DIMENSION IVB(1),IXB(1),NXB(1),XB(1),ZB(1)
     1,IML(1),IXL(1),NXL(1),XL(1),ZL(1)
     1,IVT(1),IXV(1),NXV(1),XV(1),ZV(1),V(1)
C      PRINT'('' NL='',I3,'' IML='',10(1X,I3))',NL,(IML(I),I=1,NL)
C      PRINT'('' NV='',I3,'' IVT='',10(1X,I3))',NV,(IVT(I),I=1,NV)
C      PRINT'('' NV='',I3,'' IXV='',10(1X,I3))',NV,(IXV(I),I=1,NV)
C      PRINT'('' NV='',I3,'' NXV='',10(1X,I3))',NV,(NXV(I),I=1,NV)
      IVB(1) = IML(1)
      NB = 1
      IXB(NB) = 0
      NXB(NB) = NXL(1)
      CALL CELLCOP2(NXL(1),XL(IXL(1)+1),ZL(IXL(1)+1)
     1,XB(IXB(NB)+1),ZB(IXB(NB)+1))
      DO 1 IL = 2 , NL
        IX1 = IXL(IL-1) + 1
        IX2 = IXL(IL) + 1
        CALL LAYSHN1(NB,IVB,IXB,NXB,XB,ZB
     1,IML(IL),NXL(IL-1),XL(IX1),ZL(IX1),NXL(IL),XL(IX2),ZL(IX2),WORK)
    1 CONTINUE
C  IF NEED BE ADD AN EXTRA BOUNDARY ON THE BOTTOM
      IF (XB(IXB(NB)+1) .NE. XMIN .OR. XB(IXB(NB)+2) .NE. XMAX
     1 .OR. NXB(NB) .GT. 2) THEN
        NB = NB + 1
        IVB(NB) = IML(NL)
        IXB(NB) = IXB(NB-1) + NXB(NB-1)
        NXB(NB) = 2
        XB(IXB(NB)+1) = XMIN
        XB(IXB(NB)+2) = XMAX
        ZB(IXB(NB)+1) = ZMAX + 100
        ZB(IXB(NB)+2) = ZMAX + 100
      ENDIF
      CALL LAYSHNW(LU,SHNFIL,SHOT,BASE,BASEINC,NHMOD
     1,NB,IVB,IXB,NXB,XB,ZB,IDB,NV,IXV,NXV,XV,V)
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYSHN1(NB,IVB,IXB,NXB,XB,ZB,IV,NX1,X1,Z1,NX2,X2,Z2,Z3)
C  TRANSFORM A SINGLE BOUNDARY FROM SIERRA FORMAT TO SHEINS FORMAT
      DIMENSION IVB(1),IXB(1),NXB(1),XB(1),ZB(1),X1(1),Z1(1),X2(1),Z2(1)
     1,Z3(1)
      DATA ICALL/0/
      ICALL = ICALL + 1
C  COMPUTE Z1 AT EACH X2
      TOL = 1.
      CALL LAYZATX(NX1,X1,Z1,NX2,X2,Z3)
      I = 1
      NB0 = NB
    1 CONTINUE
C  DETERMINE THE FIRST PAIR OF X'S THAT ARE NOT THE SAME
      CALL LAYNE(TOL,INE,J,I,NX2,Z2,Z3)
      CALL LAYEQ(TOL,IEQ,K,J,NX2,Z2,Z3)
      IF (INE .GT. 0) THEN
C  J = FIRST POINT AT WHICH Z2 .NE. Z3
C  K = FIRST POINT AFTER THAT AT WHICH Z2 = Z3
        J = MAX(J-1,1)
        NB = NB + 1
        IVB(NB) = IV
        IXB(NB) = IXB(NB-1) + NXB(NB-1)
        NXB(NB) = K - J + 1
        CALL CELLCOP2(NXB(NB),X2(J),Z2(J),XB(IXB(NB)+1),ZB(IXB(NB)+1))
        I = K
        IF (IEQ .GT. 0 .AND. I .LT. NX2) GOTO 1
      ENDIF
      DO 2 IB = NB0+1 , NB
        CALL LAYZSET(TOL,X2(IXB(IB)+1),Z2(IXB(IB)+1),NX1,X1,Z1)
        CALL LAYZSET(TOL,X2(IXB(IB)+NXB(IB)),Z2(IXB(IB)+NXB(IB))
     1,NX1,X1,Z1)
    2 CONTINUE
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYSHNW(LU,SHNFIL,SHOT,BASE,BASEINC,NHMOD
     1,NB,IVB,IXB,NXB,XB,ZB,IDB,NV,IXV,NXV,XV,V)
C  WRITE A MODEL IN SHEIN'S FORMAT
      DIMENSION IVB(1),IXB(1),NXB(1),XB(1),ZB(1),IDB(1)
     1,IXV(1),NXV(1),XV(1),V(1)
      CHARACTER SHNFIL*(*)
      OPEN(UNIT=LU,FILE=SHNFIL,STATUS='NEW',FORM='FORMATTED')
C  TRANSFORM X COORDS FROM SHOT POINT TO BASEMENT IF NHMOD .NE. 17 OR 18
C      CALL CELLBTOS(XB,IXB(NB)+NXB(NB),SHOT,BASE,BASEINC,NHMOD)
C      CALL CELLBTOS(XV,IXV(NV)+NXV(NV),SHOT,BASE,BASEINC,NHMOD)
C  WRITE HEADERS
      CALL LAYSWH(LU,SHOT,BASE,BASEINC,NHMOD,NB,NXB)
      DO 1 IB = 1 , NB
C  IF THIS IS NOT THE FIRST BOUNDARY WE WRITE THE X,VELOCITY PAIRS FIRST
C  WRITE VELOCITIES
      CALL LAYSWB(LU,NXB(IB),XB(IXB(IB)+1),ZB(IXB(IB)+1),IDB(IXB(IB)+1))
      IV = IVB(IB)
      IF (IB .NE. NB) CALL LAYSWV(LU,NXV(IV),XV(IXV(IV)+1),V(IXV(IV)+1))
C  WRITE BOUNDARIES
    1 CONTINUE
      CLOSE(LU)
C  TRANSFORM X COORDS FROM BASEMENT TO SHOT POINT IF NHMOD .NE. 17 OR 18
C      CALL CELLSTOB(XB,IXB(NB)+NXB(NB),SHOT,BASE,BASEINC,NHMOD)
C      CALL CELLSTOB(XV,IXV(NV)+NXV(NV),SHOT,BASE,BASEINC,NHMOD)
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYSWH(LU,SHOT,BASE,BASEINC,NHMOD,NB,NXB)
C  WRITE OUT HEADER IN SHEIN'S FORMAT
      DIMENSION NXB(1)
      WRITE(LU,*)SHOT,BASE,BASEINC,NHMOD
      WRITE(LU,'(15I5)')NB,(NXB(IB),IB=1,MIN(14,NB))
      IF (NB .GT. 14) THEN
        DO 1 I = 15 , NB , 14
          WRITE(LU,'(5X,14I5)')(NXB(IB),IB=I,MIN(I+13,NB))
    1   CONTINUE
      ENDIF
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYSWV(LU,NXV,XV,V)
C  WRITE OUT VELOCITIES IN SHEIN'S FORMAT
      DIMENSION XV(1),V(1)
      WRITE(LU,'(I3,2F8.1,3(3X,2F8.1))')
     1NXV,(XV(I),V(I),I=1,MIN(4,ABS(NXV)))
      IF (ABS(NXV) .GT. 4) THEN
        DO 1 I = 5 , ABS(NXV) , 4
          WRITE(LU,'(4(3X,2F8.1))')(XV(J),V(J),J=I,MIN(I+3,ABS(NXV)))
    1   CONTINUE
      ENDIF
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYSWB(LU,NXB,XB,ZB,IDB)
C  WRITE OUT BOUNDARIES IN SHEIN'S FORMAT
      DIMENSION XB(1),ZB(1),IDB(1)
      DO 1 I = 1 , NXB , 4
C        WRITE(LU,'(4(I3,2F8.1))')(MAX(-1,ISIGN(1,-1)*J)
        WRITE(LU,'(4(I3,2F8.1))')(J
     1,XB(J),ZB(J),J=I,MIN(I+3,NXB))
C     1(MAX(-1,ISIGN(1,IDB(J))*J)
    1 CONTINUE
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYFNDXZ(X0,Z0,J,N,X,Z)
C FIND THE PAIR OF X AROUND X0
      DIMENSION X(1),Z(1)
      IF (X0 .LT. X(J)) THEN
        I1 = J-1
        I2 = 1
        IDIR = -1
      ELSE
        I1 = J
        I2 = N
        IDIR = 1
      ENDIF
      DO 1 I = I1 , I2 , IDIR
        J = I
        IF (X(I) .LE. X0 .AND. X(I+1) .GE. X0) THEN
          DZDX = 0.
          IF (X(I) .NE. X(I+1)) DZDX = (Z(I+1) - Z(I)) / (X(I+1) - X(I))
          Z0 = Z(I) + (X0 - X(I)) * DZDX
          RETURN
        ENDIF
    1 CONTINUE
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYMOVEX(N,IX,NX,X)
C  MOVE DUPLICATE X VALUES
      DIMENSION IX(1),NX(1),X(1)
      DO 1 I = 1 , N
        DO 2 JX = IX(I)+2 , IX(I)+NX(I)
          IF (X(JX) .EQ. X(JX-1)) X(JX) = X(JX) + 1.
    2   CONTINUE
    1 CONTINUE
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYMEMC(M,N,IX,NX)
C  CALCULATE FINAL MEMORY LOCATION FOR POINTED ARRAY
      DIMENSION IX(1),NX(1)
      M = IX(N) + NX(N)
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYCHKX(N,IX,NX,X,Z,LU)
C  MAKE SURE X'S INCREASE
      DIMENSION IX(1),NX(1),X(1),Z(1)
      DATA ICALL/0/
      ICALL = ICALL + 1
      IERR = 0
      DO 1 I = 1 , N
        DO 2 J = IX(I)+2 , IX(I)+NX(I)
          IF (X(J) .LT. X(J-1)) THEN
            PRINT*,' I=',I,' J=',J,' X=',X(J-1),X(J)
            IERR = I
          ENDIF
    2   CONTINUE
    1 CONTINUE
      IF (IERR.NE.0) CALL CELLPPLT(N,IX,NX,X,Z,LU,'LAYCHKX XX',1)
      IF (IERR .NE. 0) PRINT*,' LAYCHKX STOP ICALL=',ICALL,' LU=',LU
     1,' N=',N,' IX=',IX(IERR),' NX=',NX(IERR)
      IF (IERR .NE. 0) STOP
      RETURN
      END



C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYPCON(NS,ICON,IONL,IONR,IES,LU,TITLE,INC)
C PRINT CONNECTIONS
      DIMENSION ICON(2,2,1),IONL(1),IONR(1),IES(1)
      DATA ICALL/0/
      CHARACTER TITLE*(*)
      ICALL = ICALL + 1
      IF (TITLE(1:1) .NE. ' ')PRINT'(1X,A20,'' ICALL='',I5,'' LU='',I2)'
     1,TITLE(1:20),ICALL,LU
      WRITE(LU,'('' NS='',I5,/
     1,'' I     IES IONL IONR IC11  IC12  IC21  IC22''
     1,100(/,8(1X,I5)))')NS,(I,IES(I),IONL(I),IONR(I)
     1,ICON(1,1,I),ICON(1,2,I),ICON(2,1,I),ICON(2,2,I),I=1,NS)
      IF (INC .NE. 0) LU = LU + INC
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYSIER(LU,SRAFIL,NLAYERS,XMIN,XMAX,XNODES,ZMAX,UNITS
     1,Z,V,TYPE,MX,ML)
      DIMENSION Z(MX,ML),V(MX,ML+1)
      CHARACTER SRAFIL*(*),TYPE*(*),UNITS*6
      INTEGER XNODES,YNODES
C          TYPE='TIME'
C      UNITS='FEET'

C ONLY SUPPORT SAME UNITS IN X AND Y AND ONLY 'FEET' OR 'METERS'
C       DO 5 I=1,NLAYERS+1
C   5 PRINT *,V(1,I),V(2,I),V(3,I),V(4,I)
      

      YNODES=5
C     OPEN (UNIT=LU,FILE=SRAFIL,STATUS='NEW',CARRIAGE CONTROL='NONE')
      OPEN (UNIT=LU,FILE=SRAFIL,STATUS='NEW')

C ARE Z VALUES POSITIVE DOWNWARD OR NEGATIVE DOWNWARD
C THEY ARE WRITTEN AS NEGATIVE SO THIS TELLS WHICH WAY AXIS GOES
         ZS=-1.0
         DO 23 I=1,XNODES
   23    IF (Z(I,NLAYERS).LT.0.0) ZS=1.0
         IF(TYPE.NE.'TIME') ZS=ZS/1000.

C COUNT THE NUMBER OF (HORIZONTAL) VARIABLE VELOCITY LAYERS 
         NVVL=0
         DO 30 I=1,NLAYERS
   30    IF (V(1,I).GT.0.0) NVVL=NVVL+1
      
C  GET HALF SPACE VELOCITY
         VELP=V(2,NLAYERS+1)

      CALL LAYHDR1(LU,NLAYERS,XMIN,XMAX,XNODES,YNODES,TYPE,UNITS,
     +NVVL,VELP,ZMAX,ZS)
      CALL LAYHDR2(LU,Z,V,NLAYERS,XNODES,YNODES,UNITS,ZS,MX,ML)
      CLOSE(LU)
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYHDR1(LU,NLAYERS,XMIN,XMAX,XNODES,YNODES,TYPE,UNITS
     1,NVVL,VELP,ZMAX,ZS)
      CHARACTER TYPE*5,UNITS*6
      INTEGER XUNITS,ZUNITS,ZUPDOWN,XNODES,YNODES,DATE,VLN
    
C BE REALLY CAREFUL ABOUT UNITS !!!!!!!!!!!!!!
C VELOCITIES ARE STORED AS KILOxunits/SEC EVEN WHEN MODEL IS SPECIFED
C AS FEET OR METERS.
       VS=0.001
C MODEL LIMITS STORED AS KILOunits
       XS=0.001
C DEPTH PICKS ENTERED IN DEPTH UNITS ARE CONVERTED TO X UNITS IN FILE
C      ZS=X UNITS/ Z UNITS
C WE WILL ONLY PERMIT THE USE OF FEET OR METERS AND BOTH AXIS MUST BE
C THE SAME UNITS.

       IF ((UNITS.NE.'FEET').AND.(UNITS.NE.'METERS')) THEN
       PRINT *, 'DISTANCE AND DEPTH UNITS MUST BE THE SAME IE FEET 
     +OR METERS'
       RETURN
       ENDIF

      BLANK=-1.0
      IBLANK=-1
      DATE=111111111

C   X AXIS RUNS FROM W-E, Y AXIS RUNS FROM N-S
      YMIN=0.0
C     XMIN=START OF MODEL
      YMAX=0.0
C     XMAX=END OF MODEL
      IF (UNITS.EQ.'METERS') THEN
        XUNITS=3
         ELSE
        XUNITS=4
         ENDIF
      ZUNITS=XUNITS
      
      IF (TYPE.EQ.'DEPTH') THEN
        MODTYPE=0
        MODTYPE2=0
         ELSE
        MODTYPE=1
        MODTYPE2=2
         ENDIF
      IF (ZS.LT.0.0) THEN
        ZUPDOWN=2
         ELSE
        ZUPDOWN=1
         ENDIF
      
      VLN=0
      YINC=0
      XINC=(XMAX-XMIN)/(XNODES-1)

      CALL LAYPARM(VELP,UNITS,VSVP,VELS,RHO,QP,QS)
       L=0
       IF (TYPE.EQ.'TIME') L=2    
   10 WRITE(LU,100) L
   11 WRITE(LU,102) YMIN*XS,XMIN*XS,YMAX*XS,XMAX*XS,
     +ZUPDOWN,ZUNITS,MODTYPE,0   
   12 WRITE(LU,103) YNODES,XNODES,NLAYERS,XUNITS,DATE,MODTYPE2,NVVL,
     +VLN
   13 WRITE(LU,104) YINC*XS,XINC*XS,ABS(ZMAX*ZS),VELP*VS,VSVP,RHO,QP,QS
   14 WRITE(LU,104) BLANK,BLANK,BLANK,BLANK,BLANK,BLANK,BLANK,BLANK

  100 FORMAT ('*(     ',I1,')*MIMIC MODEL FILE'/'THEORETICAL RESEARCH
     + DEPTH MODEL'/' REVISION 3.2',//)
  102 FORMAT (2F10.4,F20.4,F10.4,4I5)
  103 FORMAT (4I5,I12,3I5)
  104 FORMAT (6F10.5,2F10.2)
       RETURN
         END

C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYPARM(VELP,UNITS,VSVP,VELS,RHO,QP,QS)
      CHARACTER UNITS*6
       VSVP=0.577350
       VELS=VELP*VSVP
        IF (UNITS.EQ.'FEET') THEN
        VP=VELP
        ELSE
        VP=VELP*3.281
        ENDIF
       RHO=0.23*VP**0.25
        IF (UNITS.EQ.'FEET') THEN
        QS=(0.929*RHO*VELS**2*0.001**2)+6.28
        ELSE
        QS=(10.*RHO*VELS**2*0.001**2)+6.28
        ENDIF 
       QP=QS*0.75/(VSVP**2) 
       RETURN
         END
 
C23456789012345678901234567890123456789012345678901234567890123456789012
      SUBROUTINE LAYHDR2(LU,Z,V,NLAYERS,XNODES,YNODES,UNITS,ZS,MX,ML)
      CHARACTER UNITS*5    
      DIMENSION Z(MX,ML),V(MX,ML+1)
      INTEGER VVL,DATE,XNODES,YNODES
       DATE=111111111
       BLANK=-1.0
       IBLANK=-1
C REMEMBER MOST OF DATA IN MODEL FILE IS IN KILOunits
C REQUIRES DEPTHS STORED NEGATIVE DOWNWARD
C        ZS=-0.001
        VS=0.001
        
       VVL=0
      DO 250, I=1,NLAYERS
      WRITE(LU,200) I
        
C THE VELOCITY ARRAY CONTAINS GRIDDED VELOCITIES FOR ALL VVLS, IN THE 
C CASE OF CONSTANT VELOCITY V(1,LAYER)=-1 AND V(2,LAYER)=CONSTANT VP
C FOR VERTICAL VELOCITY GRADIENT V(1,LAYER)=-2, V(2,LAYER)=V(Z0), 
C V(3,LAYER)=Z0,V(4,LAYER)=GRADIENT
      IF (V(1,I).GT.0.0) THEN
C VARIABLE VELOCITY LAYER
      VVL=VVL+1
      WRITE(LU,205) 0.,0.,0,0
      WRITE(LU,201) DATE,VVL
C CALCULATE AVERAGE VELOCITY IN VVL
        VP=0.0 
        DO 210 J=1,XNODES
  210   VP=VP+V(J,I)
        AVVEL=VP/XNODES
        VELP=-1000.

      ELSE
        VELP=V(2,I)
        AVVEL=VELP
        IF (V(1,I).GT.-1.1) THEN
C CONSTANT VELOCITY LAYER
        WRITE(LU,205) 0.,0.,0,0
        ELSE
C SINGLE VERTICAL GRADIENT
        WRITE(LU,205) V(4,I),V(3,I)*ZS,0,0
        ENDIF
        WRITE(LU,201) DATE,0
      ENDIF

         ZMIN=Z(1,I)*ZS
         ZMAX=ZMIN    
         DO 220 J=2,XNODES
         ZMIN=AMIN1(ZMIN,Z(J,I)*ZS)
  220    ZMAX=AMAX1(ZMAX,Z(J,I)*ZS)
 
      CALL LAYPARM(AVVEL,UNITS,VSVP,VELS,RHO,QP,QS)
      WRITE(LU,104) ZMIN,ZMAX,VELP*VS,VSVP,RHO,0.0,QP,QS
      WRITE(LU,104) BLANK,BLANK,BLANK,BLANK,BLANK,BLANK,BLANK,BLANK      
  200 FORMAT (I3/'GEOPHYSICAL RESEARCH MODEL BUILDER')
  205 FORMAT (2F12.5,I6,I1)
  201 FORMAT (I12,I5)
  104 FORMAT (6F10.5,2F10.2)

  250 CONTINUE
  
      DO 270 I=1,NLAYERS
       IF (V(1,I).LT.0.0) GOTO 270
         VMIN=V(1,I)
         VMAX=VMIN
         DO 260 J=2,XNODES
         VMIN=AMIN1(VMIN,V(J,I))
  260    VMAX=AMAX1(VMAX,V(J,I))
         WRITE(LU,261) DATE
         WRITE(LU,104) VMIN*VS,VMAX*VS
  261 FORMAT ('2-D VARIABLE VELOCITY FILE'/'GEOPHYSICS 
     +RESEARCH MODEL BUILDER'//I12)

  270 CONTINUE
  275 CONTINUE

C NOW WRITE OUT ALL THE LAYER POINTS
       DO 330 I=1,NLAYERS
       DO 320 J=1,XNODES
  320  WRITE(LU,300) (Z(J,I)*ZS,K=1,YNODES) 
  330  CONTINUE
  300 FORMAT (5E16.7)
 
C NOW WRITE OUT ALL VARIABLE VELOCITY LAYERS
       DO 350 I=1,NLAYERS
       IF (V(1,I).LT.0.0) GOTO 350
       DO 340 J=1,XNODES
  340  WRITE(LU,300) (V(J,I)*VS,K=1,YNODES)
  350 CONTINUE

       WRITE(LU,301) 0
  301  FORMAT (I5)

       RETURN
       END
