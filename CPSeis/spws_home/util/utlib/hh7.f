      SUBROUTINE HEADGETH(FILE,COORDX,COORDY,COORDZ,TRANS,TYPE,
C<license>
C-------------------------------------------------------------------------------
C Copyright (c) 2007 ConocoPhillips Company
C
C Permission is hereby granted, free of charge, to any person obtaining a copy
C of this software and associated documentation files (the "Software"), to deal
C in the Software without restriction, including without limitation the rights
C to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
C copies of the Software, and to permit persons to whom the Software is
C furnished to do so, subject to the following conditions:
C
C The above copyright notice and this permission notice shall be included in all
C copies or substantial portions of the Software.
C
C THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
C IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
C AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
C LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
C SOFTWARE.
C-------------------------------------------------------------------------------
C</license>
     &  N1,N2,N3,O1,O2,O3,D1,D2,D3, HEAD)
      CHARACTER*(*) FILE,COORDX,COORDY,COORDZ,TRANS,TYPE,HEAD
      INTEGER N1,N2,N3
      REAL O1,O2,O3,D1,D2,D3
C GET SAMPLING RATE AND FILENAMES FROM HEADER FILE. SET OWN DEFAULTS 1ST
C HEAD IS NAME OF INPUT HEADER FILE.
C THE REST ARE VALUES OF PARAMETERS SET IN THE PARAMETER FILE.
      INTEGER NC
      REAL E1,E2,E3
      CALL HEADGVOP(HEAD)
        CALL HEADGVI(N1,'NZ')
        CALL HEADGVI(N2,'NX')
        CALL HEADGVI(N3,'NY')
        CALL HEADGVR(O1,'ZMIN')
        CALL HEADGVR(O2,'XMIN')
        CALL HEADGVR(O3,'YMIN')
        CALL HEADGVR(D1,'ZINC')
        CALL HEADGVR(D2,'XINC')
        CALL HEADGVR(D3,'YINC')
        CALL HEADGVR(D1,'DZ')
        CALL HEADGVR(D2,'DX')
        CALL HEADGVR(D3,'DY')
C THE FOLLOWING ARE OFFICIAL NAMES AND WILL OVERRIDE PREVIOUS NAMES
        CALL HEADGVI(N1,'N1')
        CALL HEADGVI(N2,'N2')
        CALL HEADGVI(N3,'N3')
        CALL HEADGVR(O1,'O1')
        CALL HEADGVR(O2,'O2')
        CALL HEADGVR(O3,'O3')
        CALL HEADGVR(D1,'D1')
        CALL HEADGVR(D2,'D2')
        CALL HEADGVR(D3,'D3')
        CALL HEADGVC(FILE,NC, 'FILE')
        CALL HEADGVC(TYPE,NC, 'TYPE')
        CALL HEADGVC(TRANS,NC, 'TRANSFORM')
        CALL HEADGVC(COORDX,NC, 'XCOORDINATE')
        CALL HEADGVC(COORDY,NC, 'YCOORDINATE')
        CALL HEADGVC(COORDZ,NC, 'ZCOORDINATE')
CC      CALL HEADGVCL()
      RETURN
C23456789012345678901234567890123456789012345678901234567890123456789012
      ENTRY HEADPUTH(FILE,COORDX,COORDY,COORDZ,TRANS,TYPE,
     &  N1,N2,N3,O1,O2,O3,D1,D2,D3, HEAD)
C PUT SAMPLING RATE AND FILENAMES INTO HEADER FILE.
      CALL HEADPVOP(HEAD)
        CALL HEADPVC(
     &    'These names are most convenient to change by hand:',
     &    '#')
        E1 = O1 + FLOAT(N1-1)*D1
        E2 = O2 + FLOAT(N2-1)*D2
        E3 = O3 + FLOAT(N3-1)*D3
         CALL HEADPVI(N1,'NZ')
        CALL HEADPVR(O1,'ZMIN')
        CALL HEADPVR(D1,'ZINC')
         CALL HEADPVI(N2,'NX')
        CALL HEADPVR(O2,'XMIN')
        CALL HEADPVR(D2,'XINC')
         CALL HEADPVI(N3,'NY')
        CALL HEADPVR(O3,'YMIN')
        CALL HEADPVR(D3,'YINC')
        CALL HEADPVC(FILE, 'FILE')
        CALL HEADPVC(TYPE, 'TYPE')
        CALL HEADPVC(TRANS, 'TRANSFORM')
        CALL HEADPVC(COORDX, 'XCOORDINATE')
        CALL HEADPVC(COORDY, 'YCOORDINATE')
        CALL HEADPVC(COORDZ, 'ZCOORDINATE')
C THE FOLLOWING ARE OFFICIAL NAMES AND SHOULD OVERRIDE PREVIOUS NAMES
        CALL HEADPVC(
     &   'Delete everything below this line if you change by hand:',
     &   '#')
        CALL HEADPVR(E1,'ZMAX_(for_reference)')
        CALL HEADPVR(E2,'XMAX_(for_reference)')
        CALL HEADPVR(E3,'YMAX_(for_reference)')
        CALL HEADPVC(
     &   'These are valid alternative names:',
     &   '#')
        CALL HEADPVR(D1,'DZ')
        CALL HEADPVR(D2,'DX')
        CALL HEADPVR(D3,'DY')
        CALL HEADPVC(
     &   'These are more general names that override others:',
     &   '#')
        CALL HEADPVI(N1,'N1')
        CALL HEADPVI(N2,'N2')
        CALL HEADPVI(N3,'N3')
        CALL HEADPVR(O1,'O1')
        CALL HEADPVR(O2,'O2')
        CALL HEADPVR(O3,'O3')
        CALL HEADPVR(D1,'D1')
        CALL HEADPVR(D2,'D2')
        CALL HEADPVR(D3,'D3')
CC      CALL HEADPVCL()
      RETURN
      END



C23456789012345678901234567890123456789012345678901234567890123456789012
C     DCOD(

      SUBROUTINE HEADDCOD(VALUE, CARD)
      REAL VALUE
      CHARACTER*(*) CARD
C DECODE A REAL NUMBER, PERHAPS IN SCIENTIFIC NOTATION.
CNDXI DCOD( I
      INTEGER N,I,N1,N2
      LOGICAL EE
      REAL R1,R2
      CHARACTER*20 C20
C SHIFT TO LEFT
      CALL HEADCLFT(CARD)
C FIND OUT IF IN EXPONENTIAL NOTATION
      N = LEN(CARD)
      EE = .FALSE.
      DO 100 I=1,N
        EE = (CARD(I:I).EQ.'E'.OR.CARD(I:I).EQ.'e')
        IF(EE) THEN
          N1 = I - 1
          N2 = I + 1
          GOTO 200
        ENDIF
  100 CONTINUE
  200 CONTINUE
      IF(.NOT.EE) THEN
C...        NO EXPONENT
        C20 = ' '
        C20 = CARD
        CALL HEADCADP(C20,20)
        READ(C20,1401,ERR=1301) VALUE
      ELSE
C...        HAVE AN EXPONENT, READ MANTISSA FIRST
        C20 = ' '
        C20 = CARD(:N1)
        CALL HEADCADP(C20,20)
        READ(C20,1401,ERR=1301) R1
C...        READ EXPONENT SECOND
        C20 = ' '
        C20 = CARD(N2:)
        CALL HEADCADP(C20,20)
        READ(C20,1401,ERR=1301) R2
        VALUE = R1 * EXP(LOG(10.)*R2)
      ENDIF
      RETURN
 1301 CONTINUE
        CALL HEADHEYU('DCOD: PROBLEM DECODING CARD')
        CALL HEADHEYU(CARD)
      RETURN
 1401 FORMAT(F20.7)
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
C     DEVN(

      SUBROUTINE HEADDEVN(IDEV)
      INTEGER IDEV
C GET A FREE DEVICE NUMBER FOR FORTRAN OPEN, USE FOR INPUT FILES.
CNDXI DEVN( I
      INTEGER IOUT
      DATA IOUT/0/
      CALL GETLUN(IDEV)
      RETURN
C***********************************************************************
      ENTRY HEADDEVO(IDEV)
C GETS DEVICE # FOR FORMATTED OUTPUT, RETURNS IDEV=6 IF DEV6() CALLED.
C  IS CALLED FIRST.
      IF(IOUT.NE.0) THEN
        IDEV = IOUT
      ELSE
        CALL GETLUN(IDEV)
      ENDIF
      RETURN
C***********************************************************************
      ENTRY HEADDEV6()
C CALL THIS IF DEVO SHOULD GO TO STANDARD OUTPUT
        IOUT = 6
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
C     FNEW(

      SUBROUTINE HEADFNEW(FILE)
C OPEN A PSEUDO FILE WITHIN A FILE; FEND CLOSES IT.
CNDXI FNEW( I
      CHARACTER FILE*(*),FILENO*20,C*3
      CALL HEADGETC(C)
      CALL HEADCCAT(FILENO, FILE,C)
      WRITE(6,*) 'BEGINNING OUTPUT OF FILE ',FILENO
      WRITE(6,*) '@BEGIN@'
      WRITE(6,*) FILENO
      RETURN
C**********************************
      ENTRY HEADFEND()
      WRITE(6,*) '@END@'
      WRITE(6,*) 'END OF OUTPUT OF FILE ',FILENO
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
C     GETC(

      SUBROUTINE HEADGETC(C)
      CHARACTER*1 C(3)
C GET NEXT CONSECUTIVE INTEGER (FROM 1) IN CHARACTER FORM FOR FILE NAMES
CNDXC GETC( C
      CHARACTER*1 CC(10)
      INTEGER IC,JC(3),I,KC,NC(10),J,L,ION
      DATA IC/0/
      DATA CC/'0','1','2','3','4','5','6','7','8','9'/
      DATA NC/0,1,2,3,4,5,6,7,8,9/
      DATA ION/-1/
      IF(ION.GT.0) THEN
        IC = IC + 1
        KC = IC
        DO 100 I=1,3
          JC(I) = MOD(KC,10)
          KC = KC/10
  100   CONTINUE
        DO 300 I=1,3
          L = 4 - I
          DO 200 J=1,10
            IF(NC(J).EQ.JC(I)) C(L) = CC(J)
  200     CONTINUE
  300   CONTINUE
      ELSE
        C(1) = ' '
        C(2) = ' '
        C(3) = ' '
      ENDIF
      RETURN
C***********************************************************************
      ENTRY HEADGTC1()
C TURN OFF NUMBERING OF FILES.
       ION = - 1
      RETURN
C***********************************************************************
      ENTRY HEADGTC2()
C TURN ON NUMBERING OF FILES.
       ION = 1
      RETURN
      END

C23456789012345678901234567890123456789012345678901234567890123456789012
C     GV1(

      SUBROUTINE HEADGV1(VALUE,NVALUE, CARD,NAME)
      CHARACTER*(*) VALUE,CARD,NAME
      INTEGER NVALUE
C GET CHARACTER VALUE OF A VARIABLE 'NAME' FROM CARD.  NAME=VALUE.
CNDXC GV1( C
      CHARACTER CCARD*160,CNAME*80
      INTEGER IC1,IC2,IN1,NNAME,I,JC1,NCARD,IGAP,IBEGIN
      LOGICAL LQUOTE,HEADSPAC
C
      NCARD = LEN(CARD)

C  MODIFY SO # SIGN COMMENTS OUT FOLLOWING CHARACTERS DWH 05-03-94
      DO IC1 = 1 , NCARD
        IF (CARD(IC1:IC1) .EQ. '#') THEN
          NCARD = IC1 - 1
          GOTO 301
        ENDIF    ! IF (CARD(IC1:IC1) .EQ. '#') THEN
      ENDDO    ! DO IC1 = 1 , NCARD
  301 CONTINUE

C CAPITALIZE NAME AND CARD
      CALL HEADCAPS(CCARD, CARD)
      CALL HEADCAPS(CNAME, NAME)
      CALL HEADCLFT(CNAME)
      NVALUE = 0
      VALUE = ' '
      CALL HEADLENL(NNAME, NAME)
      NNAME = MIN(80, NNAME)
      DO 300 IC1=1,NCARD
        IF(CARD(IC1:IC1).EQ.'=') THEN
C COUNT IGAP, THE NUMBER OF INTERVENING BLANKS
          IGAP = 0
   50     CONTINUE
          IC2 = IC1 - IGAP - 1
          IF(IC2.LT.1) GOTO 300
          IF(CCARD(IC2:IC2).EQ.' ') THEN
            IGAP = IGAP + 1
            GOTO 50
          ENDIF
C SEE IF STRING MATCHES BEFORE BLANKS
          DO 100 IN1=1,NNAME
            IC2 = IC1 - NNAME - 1 + IN1 - IGAP
              IF(IC2.LT.1) GOTO 300
              IF(CCARD(IC2:IC2).NE.CNAME(IN1:IN1)) GOTO 300
  100     CONTINUE
C CHECK TO SEE IF CNAME IS NOT THE LAST PART OF ANOTHER NAME.
          IC2 = IC1 - NNAME - 1 - IGAP
          IF(IC2.GT.0) THEN
            IF (.NOT.HEADSPAC(CARD(IC2:IC2))) GOTO 300
C            IF(      CCARD(IC2:IC2).NE.' '.AND.
C     &               CCARD(IC2:IC2).NE.','.AND.
C     &               CCARD(IC2:IC2).NE.';'.AND.
C     &               CCARD(IC2:IC2).NE.'('         ) GOTO 300
          ENDIF
C HAVE A MATCH ; IGNORE FIRST BLANKS AFTER EQUALS SIGN
          IBEGIN = IC1 + 1
  150     CONTINUE
            IF(CARD(IBEGIN:IBEGIN).EQ.' ') THEN
              IBEGIN = IBEGIN + 1
              IF(IBEGIN.GT.NCARD) GOTO 300
              GOTO 150
            ENDIF
C CHECK TO SEE IF STRING IS IN QUOTES
          LQUOTE = (CARD(IBEGIN:IBEGIN).EQ.'"')
          IF(LQUOTE) IBEGIN = IBEGIN + 1
C START LOOP TO SET OUTPUT STRING
          VALUE = ' '
          JC1 = IBEGIN - 1
          NVALUE = 1
  200     CONTINUE
            IC2 = JC1 + NVALUE
            IF(IC2.LE.NCARD) THEN
              IF( ((.NOT.LQUOTE).AND.(.NOT.HEADSPAC(CARD(IC2:IC2))))
     &      .OR. (LQUOTE.AND.CARD(IC2:IC2).NE.'"') ) THEN
C              IF( ((.NOT.LQUOTE).AND.
C     &           CARD(IC2:IC2).NE.' '.AND.
C     &           CARD(IC2:IC2).NE.')'.AND.
C     &           CARD(IC2:IC2).NE.';'.AND.
C     &           CARD(IC2:IC2).NE.',').OR.
C     &           (LQUOTE.AND.CARD(IC2:IC2).NE.'"') ) THEN
                VALUE(NVALUE:NVALUE) = CARD(IC2:IC2)
                NVALUE = NVALUE + 1
                GOTO 200
              ENDIF
            ENDIF
          NVALUE = NVALUE - 1
        ENDIF
  300 CONTINUE
CC    WRITE(6,*) 'NAME VALUE ',CNAME(:NNAME),' ',VALUE(:NVALUE), NVALUE
      RETURN
      END

      SUBROUTINE HEADGV2(VALUE,NVALUE, NAME,IDEV)
      CHARACTER*(*) VALUE,NAME
      INTEGER NVALUE,IDEV
      SAVE MLINES,NFORL
      DATA MLINES,NFORL/200,-1/
C GET THE VALUE OF A VARIABLE 'NAME' FROM DEVICE IDEV
CNDXC GV2( C
C  USE FORMAT   'NAME=VALUE',  RETURNED VALUE IS A STRING.
C  STRING IS DELIMITED ON RIGHT BY BLANK, COMMA, OR PARENTHESIS.
C  KEEP LAST ASSIGNMENT IN FILE
C FIRST OPEN IDEV WITH
      CHARACTER CARD*160, VAL*80
      INTEGER NNAME,NVAL,NLINES,JLINES,MLINES,IFORL,JFORL,NFORL
      REWIND(IDEV)
      NVALUE = 0
      NLINES = 1
      IFORL = 0
  100 CONTINUE
        READ(IDEV,1401,END=200,ERR=1301) CARD
        CALL HEADGV1(VAL,NVAL, CARD,NAME)
        IF(NVAL.GT.0) THEN
          VALUE = VAL(:NVAL)
          NVALUE = NVAL
          IFORL = IFORL + 1
          IF (IFORL .EQ. NFORL) GOTO 200
        ENDIF
      NLINES = NLINES + 1
      IF(NLINES.LT.MLINES) GOTO 100
  200 CONTINUE
        CALL HEADLENL(NNAME,NAME)
CC        WRITE(6,*) 'NAME VALUE ',NAME(:NNAME),' ',VALUE(:NVALUE)
      RETURN
 1301 CONTINUE
C      WRITE(6,*) 'ERROR READING DEVICE ',IDEV
      RETURN
 1401 FORMAT(160A)
      ENTRY HEADPLIN(JLINES)
C SET THE NUMBER OF LINES TO READ IN GV2
      MLINES = JLINES
      RETURN
      ENTRY HEADGLIN(JLINES)
C RETURN THE NUMBER OF LINES TO READ IN GV2
      JLINES = MLINES
      RETURN
      ENTRY HEADPORL(JFORL)
C  SE THE NUMBER OF OCCURENCES TO SEARCH FOR
      NFORL = JFORL
      RETURN
      ENTRY HEADGORL(JFORL)
C  RETURN THE NUMBER OF OCCURENCES TO SEARCH FOR
      JFORL = NFORL
      RETURN
      END


C23456789012345678901234567890123456789012345678901234567890123456789012
      LOGICAL FUNCTION HEADSPAC(CARD)
C  IS CARD OONE OF THE DELIMITERS
      CHARACTER *1 CARD
      PARAMETER (MC=3)
      CHARACTER C(3)*1
      DATA C/' ',',','('/
      HEADSPAC = .FALSE.
      DO 1 I = 1 , MC
        HEADSPAC = HEADSPAC .OR. (CARD .EQ. C(I))
    1 CONTINUE
      RETURN
      END

